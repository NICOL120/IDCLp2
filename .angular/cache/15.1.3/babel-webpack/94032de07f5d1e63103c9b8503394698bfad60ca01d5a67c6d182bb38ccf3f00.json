{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { TaskExec } from '../common/tesk-exec/task-exec';\nexport function memoizeAsyncify(originalMethod, input) {\n  const defaultConfig = {\n    cache: new Map()\n  };\n  const runner = new TaskExec();\n  const promCache = new Map();\n  let resolvedConfig = Object.assign({}, defaultConfig);\n  if (typeof input === 'number') {\n    resolvedConfig.expirationTimeMs = input;\n  } else {\n    resolvedConfig = Object.assign(Object.assign({}, resolvedConfig), input);\n  }\n  return function (...args) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const keyResolver = typeof resolvedConfig.keyResolver === 'string' ? this[resolvedConfig.keyResolver].bind(this) : resolvedConfig.keyResolver;\n      let key;\n      if (keyResolver) {\n        key = keyResolver(...args);\n      } else {\n        key = JSON.stringify(args);\n      }\n      if (promCache.has(key)) {\n        return promCache.get(key);\n      }\n      const prom = new Promise((resolve, reject) => __awaiter(this, void 0, void 0, function* () {\n        let inCache;\n        try {\n          inCache = yield resolvedConfig.cache.has(key);\n        } catch (e) {\n          reject(e);\n          return;\n        }\n        if (inCache) {\n          let data;\n          try {\n            data = yield resolvedConfig.cache.get(key);\n          } catch (e) {\n            reject(e);\n            return;\n          }\n          resolve(data);\n        } else {\n          try {\n            const data = yield originalMethod.apply(this, args);\n            resolvedConfig.cache.set(key, data);\n            if (resolvedConfig.expirationTimeMs !== undefined) {\n              runner.exec(() => {\n                resolvedConfig.cache.delete(key);\n              }, resolvedConfig.expirationTimeMs);\n            }\n            resolve(data);\n          } catch (e) {\n            reject(e);\n          }\n        }\n        promCache.delete(key);\n      }));\n      promCache.set(key, prom);\n      return prom;\n    });\n  };\n}\n//# sourceMappingURL=memoize-asyncify.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}