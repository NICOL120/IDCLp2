{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.UpdateInstantiateConfigProposal = exports.AccessConfigUpdate = exports.UnpinCodesProposal = exports.PinCodesProposal = exports.ClearAdminProposal = exports.UpdateAdminProposal = exports.ExecuteContractProposal = exports.SudoContractProposal = exports.MigrateContractProposal = exports.InstantiateContractProposal = exports.StoreCodeProposal = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst types_1 = require(\"../../../cosmwasm/wasm/v1/types\");\nconst coin_1 = require(\"../../../cosmos/base/v1beta1/coin\");\nexports.protobufPackage = \"cosmwasm.wasm.v1\";\nconst baseStoreCodeProposal = {\n  title: \"\",\n  description: \"\",\n  runAs: \"\"\n};\nexports.StoreCodeProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.runAs !== \"\") {\n      writer.uint32(26).string(message.runAs);\n    }\n    if (message.wasmByteCode.length !== 0) {\n      writer.uint32(34).bytes(message.wasmByteCode);\n    }\n    if (message.instantiatePermission !== undefined) {\n      types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(58).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseStoreCodeProposal);\n    message.wasmByteCode = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.runAs = reader.string();\n          break;\n        case 4:\n          message.wasmByteCode = reader.bytes();\n          break;\n        case 7:\n          message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseStoreCodeProposal);\n    message.wasmByteCode = new Uint8Array();\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.runAs !== undefined && object.runAs !== null) {\n      message.runAs = String(object.runAs);\n    } else {\n      message.runAs = \"\";\n    }\n    if (object.wasmByteCode !== undefined && object.wasmByteCode !== null) {\n      message.wasmByteCode = bytesFromBase64(object.wasmByteCode);\n    }\n    if (object.instantiatePermission !== undefined && object.instantiatePermission !== null) {\n      message.instantiatePermission = types_1.AccessConfig.fromJSON(object.instantiatePermission);\n    } else {\n      message.instantiatePermission = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.runAs !== undefined && (obj.runAs = message.runAs);\n    message.wasmByteCode !== undefined && (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== undefined ? message.wasmByteCode : new Uint8Array()));\n    message.instantiatePermission !== undefined && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseStoreCodeProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.runAs !== undefined && object.runAs !== null) {\n      message.runAs = object.runAs;\n    } else {\n      message.runAs = \"\";\n    }\n    if (object.wasmByteCode !== undefined && object.wasmByteCode !== null) {\n      message.wasmByteCode = object.wasmByteCode;\n    } else {\n      message.wasmByteCode = new Uint8Array();\n    }\n    if (object.instantiatePermission !== undefined && object.instantiatePermission !== null) {\n      message.instantiatePermission = types_1.AccessConfig.fromPartial(object.instantiatePermission);\n    } else {\n      message.instantiatePermission = undefined;\n    }\n    return message;\n  }\n};\nconst baseInstantiateContractProposal = {\n  title: \"\",\n  description: \"\",\n  runAs: \"\",\n  admin: \"\",\n  codeId: long_1.default.UZERO,\n  label: \"\"\n};\nexports.InstantiateContractProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.runAs !== \"\") {\n      writer.uint32(26).string(message.runAs);\n    }\n    if (message.admin !== \"\") {\n      writer.uint32(34).string(message.admin);\n    }\n    if (!message.codeId.isZero()) {\n      writer.uint32(40).uint64(message.codeId);\n    }\n    if (message.label !== \"\") {\n      writer.uint32(50).string(message.label);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(58).bytes(message.msg);\n    }\n    for (const v of message.funds) {\n      coin_1.Coin.encode(v, writer.uint32(66).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseInstantiateContractProposal);\n    message.funds = [];\n    message.msg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.runAs = reader.string();\n          break;\n        case 4:\n          message.admin = reader.string();\n          break;\n        case 5:\n          message.codeId = reader.uint64();\n          break;\n        case 6:\n          message.label = reader.string();\n          break;\n        case 7:\n          message.msg = reader.bytes();\n          break;\n        case 8:\n          message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseInstantiateContractProposal);\n    message.funds = [];\n    message.msg = new Uint8Array();\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.runAs !== undefined && object.runAs !== null) {\n      message.runAs = String(object.runAs);\n    } else {\n      message.runAs = \"\";\n    }\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = String(object.admin);\n    } else {\n      message.admin = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.label !== undefined && object.label !== null) {\n      message.label = String(object.label);\n    } else {\n      message.label = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = bytesFromBase64(object.msg);\n    }\n    if (object.funds !== undefined && object.funds !== null) {\n      for (const e of object.funds) {\n        message.funds.push(coin_1.Coin.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.runAs !== undefined && (obj.runAs = message.runAs);\n    message.admin !== undefined && (obj.admin = message.admin);\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    message.label !== undefined && (obj.label = message.label);\n    message.msg !== undefined && (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n    if (message.funds) {\n      obj.funds = message.funds.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.funds = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseInstantiateContractProposal);\n    message.funds = [];\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.runAs !== undefined && object.runAs !== null) {\n      message.runAs = object.runAs;\n    } else {\n      message.runAs = \"\";\n    }\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = object.admin;\n    } else {\n      message.admin = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.label !== undefined && object.label !== null) {\n      message.label = object.label;\n    } else {\n      message.label = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = object.msg;\n    } else {\n      message.msg = new Uint8Array();\n    }\n    if (object.funds !== undefined && object.funds !== null) {\n      for (const e of object.funds) {\n        message.funds.push(coin_1.Coin.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseMigrateContractProposal = {\n  title: \"\",\n  description: \"\",\n  contract: \"\",\n  codeId: long_1.default.UZERO\n};\nexports.MigrateContractProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(34).string(message.contract);\n    }\n    if (!message.codeId.isZero()) {\n      writer.uint32(40).uint64(message.codeId);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(50).bytes(message.msg);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMigrateContractProposal);\n    message.msg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 4:\n          message.contract = reader.string();\n          break;\n        case 5:\n          message.codeId = reader.uint64();\n          break;\n        case 6:\n          message.msg = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMigrateContractProposal);\n    message.msg = new Uint8Array();\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = bytesFromBase64(object.msg);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    message.msg !== undefined && (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMigrateContractProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = object.msg;\n    } else {\n      message.msg = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseSudoContractProposal = {\n  title: \"\",\n  description: \"\",\n  contract: \"\"\n};\nexports.SudoContractProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(26).string(message.contract);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(34).bytes(message.msg);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSudoContractProposal);\n    message.msg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.contract = reader.string();\n          break;\n        case 4:\n          message.msg = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSudoContractProposal);\n    message.msg = new Uint8Array();\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = bytesFromBase64(object.msg);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.msg !== undefined && (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSudoContractProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = object.msg;\n    } else {\n      message.msg = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseExecuteContractProposal = {\n  title: \"\",\n  description: \"\",\n  runAs: \"\",\n  contract: \"\"\n};\nexports.ExecuteContractProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.runAs !== \"\") {\n      writer.uint32(26).string(message.runAs);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(34).string(message.contract);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(42).bytes(message.msg);\n    }\n    for (const v of message.funds) {\n      coin_1.Coin.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseExecuteContractProposal);\n    message.funds = [];\n    message.msg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.runAs = reader.string();\n          break;\n        case 4:\n          message.contract = reader.string();\n          break;\n        case 5:\n          message.msg = reader.bytes();\n          break;\n        case 6:\n          message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseExecuteContractProposal);\n    message.funds = [];\n    message.msg = new Uint8Array();\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.runAs !== undefined && object.runAs !== null) {\n      message.runAs = String(object.runAs);\n    } else {\n      message.runAs = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = bytesFromBase64(object.msg);\n    }\n    if (object.funds !== undefined && object.funds !== null) {\n      for (const e of object.funds) {\n        message.funds.push(coin_1.Coin.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.runAs !== undefined && (obj.runAs = message.runAs);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.msg !== undefined && (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n    if (message.funds) {\n      obj.funds = message.funds.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.funds = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseExecuteContractProposal);\n    message.funds = [];\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.runAs !== undefined && object.runAs !== null) {\n      message.runAs = object.runAs;\n    } else {\n      message.runAs = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = object.msg;\n    } else {\n      message.msg = new Uint8Array();\n    }\n    if (object.funds !== undefined && object.funds !== null) {\n      for (const e of object.funds) {\n        message.funds.push(coin_1.Coin.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseUpdateAdminProposal = {\n  title: \"\",\n  description: \"\",\n  newAdmin: \"\",\n  contract: \"\"\n};\nexports.UpdateAdminProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.newAdmin !== \"\") {\n      writer.uint32(26).string(message.newAdmin);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(34).string(message.contract);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseUpdateAdminProposal);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.newAdmin = reader.string();\n          break;\n        case 4:\n          message.contract = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseUpdateAdminProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.newAdmin !== undefined && object.newAdmin !== null) {\n      message.newAdmin = String(object.newAdmin);\n    } else {\n      message.newAdmin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.newAdmin !== undefined && (obj.newAdmin = message.newAdmin);\n    message.contract !== undefined && (obj.contract = message.contract);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseUpdateAdminProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.newAdmin !== undefined && object.newAdmin !== null) {\n      message.newAdmin = object.newAdmin;\n    } else {\n      message.newAdmin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  }\n};\nconst baseClearAdminProposal = {\n  title: \"\",\n  description: \"\",\n  contract: \"\"\n};\nexports.ClearAdminProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(26).string(message.contract);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseClearAdminProposal);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.contract = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseClearAdminProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.contract !== undefined && (obj.contract = message.contract);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseClearAdminProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  }\n};\nconst basePinCodesProposal = {\n  title: \"\",\n  description: \"\",\n  codeIds: long_1.default.UZERO\n};\nexports.PinCodesProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    writer.uint32(26).fork();\n    for (const v of message.codeIds) {\n      writer.uint64(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, basePinCodesProposal);\n    message.codeIds = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.codeIds.push(reader.uint64());\n            }\n          } else {\n            message.codeIds.push(reader.uint64());\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, basePinCodesProposal);\n    message.codeIds = [];\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.codeIds !== undefined && object.codeIds !== null) {\n      for (const e of object.codeIds) {\n        message.codeIds.push(long_1.default.fromString(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    if (message.codeIds) {\n      obj.codeIds = message.codeIds.map(e => (e || long_1.default.UZERO).toString());\n    } else {\n      obj.codeIds = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, basePinCodesProposal);\n    message.codeIds = [];\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.codeIds !== undefined && object.codeIds !== null) {\n      for (const e of object.codeIds) {\n        message.codeIds.push(e);\n      }\n    }\n    return message;\n  }\n};\nconst baseUnpinCodesProposal = {\n  title: \"\",\n  description: \"\",\n  codeIds: long_1.default.UZERO\n};\nexports.UnpinCodesProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    writer.uint32(26).fork();\n    for (const v of message.codeIds) {\n      writer.uint64(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseUnpinCodesProposal);\n    message.codeIds = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.codeIds.push(reader.uint64());\n            }\n          } else {\n            message.codeIds.push(reader.uint64());\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseUnpinCodesProposal);\n    message.codeIds = [];\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.codeIds !== undefined && object.codeIds !== null) {\n      for (const e of object.codeIds) {\n        message.codeIds.push(long_1.default.fromString(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    if (message.codeIds) {\n      obj.codeIds = message.codeIds.map(e => (e || long_1.default.UZERO).toString());\n    } else {\n      obj.codeIds = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseUnpinCodesProposal);\n    message.codeIds = [];\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.codeIds !== undefined && object.codeIds !== null) {\n      for (const e of object.codeIds) {\n        message.codeIds.push(e);\n      }\n    }\n    return message;\n  }\n};\nconst baseAccessConfigUpdate = {\n  codeId: long_1.default.UZERO\n};\nexports.AccessConfigUpdate = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.codeId.isZero()) {\n      writer.uint32(8).uint64(message.codeId);\n    }\n    if (message.instantiatePermission !== undefined) {\n      types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseAccessConfigUpdate);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.codeId = reader.uint64();\n          break;\n        case 2:\n          message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseAccessConfigUpdate);\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.instantiatePermission !== undefined && object.instantiatePermission !== null) {\n      message.instantiatePermission = types_1.AccessConfig.fromJSON(object.instantiatePermission);\n    } else {\n      message.instantiatePermission = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    message.instantiatePermission !== undefined && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseAccessConfigUpdate);\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.instantiatePermission !== undefined && object.instantiatePermission !== null) {\n      message.instantiatePermission = types_1.AccessConfig.fromPartial(object.instantiatePermission);\n    } else {\n      message.instantiatePermission = undefined;\n    }\n    return message;\n  }\n};\nconst baseUpdateInstantiateConfigProposal = {\n  title: \"\",\n  description: \"\"\n};\nexports.UpdateInstantiateConfigProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    for (const v of message.accessConfigUpdates) {\n      exports.AccessConfigUpdate.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseUpdateInstantiateConfigProposal);\n    message.accessConfigUpdates = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.accessConfigUpdates.push(exports.AccessConfigUpdate.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseUpdateInstantiateConfigProposal);\n    message.accessConfigUpdates = [];\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.accessConfigUpdates !== undefined && object.accessConfigUpdates !== null) {\n      for (const e of object.accessConfigUpdates) {\n        message.accessConfigUpdates.push(exports.AccessConfigUpdate.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    if (message.accessConfigUpdates) {\n      obj.accessConfigUpdates = message.accessConfigUpdates.map(e => e ? exports.AccessConfigUpdate.toJSON(e) : undefined);\n    } else {\n      obj.accessConfigUpdates = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseUpdateInstantiateConfigProposal);\n    message.accessConfigUpdates = [];\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.accessConfigUpdates !== undefined && object.accessConfigUpdates !== null) {\n      for (const e of object.accessConfigUpdates) {\n        message.accessConfigUpdates.push(exports.AccessConfigUpdate.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=proposal.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}