{"ast":null,"code":"import BigNumber from 'bignumber.js';\nimport { div } from '../../libs/math';\nimport { getStablePrice } from '../../libs/stable';\nexport const balance_transform = (stableCoinDenoms, value, poolResponse, poolResponseB) => {\n  var _a, _b;\n  if (typeof value !== 'string' && typeof value !== 'number' || !poolResponse) {\n    return undefined;\n  }\n  const asset0IsStableCoin = isAssetStableCoin(stableCoinDenoms, poolResponse.assets[0].info);\n  const asset1IsStableCoin = isAssetStableCoin(stableCoinDenoms, poolResponse.assets[1].info);\n  if (asset0IsStableCoin) {\n    return new BigNumber(value).times(poolResponse.assets[0].amount).div(poolResponse.assets[1].amount).toString();\n  } else if (asset1IsStableCoin) {\n    return new BigNumber(value).times(poolResponse.assets[1].amount).div(poolResponse.assets[0].amount).toString();\n  } else if (poolResponseB) {\n    const basePrice = balance_transform(stableCoinDenoms, '1', poolResponseB);\n    const baseAsset = poolResponseB.assets.find(asset => !isAssetStableCoin(stableCoinDenoms, asset.info));\n    const [assetA, assetB] = ((_a = poolResponse.assets[0].info.token) === null || _a === void 0 ? void 0 : _a['contract_addr']) === ((_b = baseAsset.info.token) === null || _b === void 0 ? void 0 : _b['contract_addr']) ? [poolResponse.assets[0], poolResponse.assets[1]] : [poolResponse.assets[1], poolResponse.assets[0]];\n    const assetPerBaseAsset = div(assetA.amount, assetB.amount);\n    return new BigNumber(value).times(assetPerBaseAsset).times(basePrice).toString();\n  } else {\n    return null;\n  }\n};\nconst isAssetStableCoin = (stableCoinDenoms, assetInfo) => {\n  var _a, _b;\n  return stableCoinDenoms.has(((_a = assetInfo.native_token) === null || _a === void 0 ? void 0 : _a['denom']) || ((_b = assetInfo.token) === null || _b === void 0 ? void 0 : _b['contract_addr']));\n};\nexport const lp_balance_transform = (lp, info, config, key) => {\n  var _a, _b, _c, _d, _e, _f;\n  if (typeof lp !== 'string' && typeof lp !== 'number' || !info.poolResponses[key]) {\n    return undefined;\n  }\n  const poolResponse = info.poolResponses[key];\n  const stableCoinDenoms = config.STABLE_COIN_DENOMS;\n  const asset0IsStableCoin = isAssetStableCoin(stableCoinDenoms, poolResponse.assets[0].info);\n  const asset1IsStableCoin = isAssetStableCoin(stableCoinDenoms, poolResponse.assets[1].info);\n  if (asset0IsStableCoin) {\n    if (asset1IsStableCoin) {\n      const amount1 = new BigNumber(lp).times(poolResponse.assets[0].amount).div(poolResponse.total_share);\n      const amount2 = new BigNumber(lp).times(poolResponse.assets[1].amount).div(poolResponse.total_share);\n      return amount1.plus(amount2).toString();\n    } else {\n      return new BigNumber(lp).times(poolResponse.assets[0].amount).div(poolResponse.total_share).times(2).toString();\n    }\n  } else if (asset1IsStableCoin) {\n    return new BigNumber(lp).times(poolResponse.assets[1].amount).div(poolResponse.total_share).times(2).toString();\n  } else {\n    const dex = key.split('|')[0];\n    const [stableCoin] = stableCoinDenoms;\n    const asset1Token = poolResponse.assets[1].info.token ? (_a = poolResponse.assets[1].info.token) === null || _a === void 0 ? void 0 : _a['contract_addr'] : (_b = poolResponse.assets[1].info.native_token) === null || _b === void 0 ? void 0 : _b['denom'];\n    const token1Price = balance_transform(stableCoinDenoms, '1', info.poolResponses[`${dex}|${asset1Token}|${stableCoin}`] || info.poolResponses[`${dex}|${stableCoin}|${asset1Token}`]);\n    if (token1Price) {\n      if ((_c = info.pairInfos[key].pair_type) === null || _c === void 0 ? void 0 : _c['stable']) {\n        const amp = info.ampStablePairs[key];\n        const asset0Price = getStablePrice(+poolResponse.assets[0].amount, +poolResponse.assets[1].amount, +amp);\n        const asset0Swap = new BigNumber(lp).times(poolResponse.assets[0].amount).div(poolResponse.total_share).times(asset0Price).integerValue(BigNumber.ROUND_DOWN);\n        return new BigNumber(lp).times(poolResponse.assets[1].amount).div(poolResponse.total_share).plus(asset0Swap).times(token1Price).toString();\n      } else {\n        return new BigNumber(lp).times(poolResponse.assets[1].amount).div(poolResponse.total_share).times(token1Price).times(2).toString();\n      }\n    }\n    const asset0Token = poolResponse.assets[0].info.token ? (_d = poolResponse.assets[0].info.token) === null || _d === void 0 ? void 0 : _d['contract_addr'] : (_e = poolResponse.assets[0].info.native_token) === null || _e === void 0 ? void 0 : _e['denom'];\n    const token0Price = balance_transform(stableCoinDenoms, '1', info.poolResponses[`${dex}|${asset0Token}|${stableCoin}`] || info.poolResponses[`${dex}|${stableCoin}|${asset0Token}`]);\n    if (token0Price) {\n      if ((_f = info.pairInfos[key].pair_type) === null || _f === void 0 ? void 0 : _f['stable']) {\n        const amp = info.ampStablePairs[key];\n        const asset1Price = getStablePrice(+poolResponse.assets[1].amount, +poolResponse.assets[0].amount, +amp);\n        const asset1Swap = new BigNumber(lp).times(poolResponse.assets[1].amount).div(poolResponse.total_share).times(asset1Price).integerValue(BigNumber.ROUND_DOWN);\n        return new BigNumber(lp).times(poolResponse.assets[0].amount).div(poolResponse.total_share).plus(asset1Swap).times(token0Price).toString();\n      } else {\n        return new BigNumber(lp).times(poolResponse.assets[0].amount).div(poolResponse.total_share).times(token0Price).times(2).toString();\n      }\n    }\n    return null;\n  }\n};","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}