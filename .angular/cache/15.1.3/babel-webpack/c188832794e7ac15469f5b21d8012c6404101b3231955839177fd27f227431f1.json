{"ast":null,"code":"const createHmac = require('create-hmac');\nconst ONE1 = Buffer.alloc(1, 1);\nconst ZERO1 = Buffer.alloc(1, 0);\n\n// https://tools.ietf.org/html/rfc6979#section-3.2\nfunction deterministicGenerateK(hash, x, checkSig, isPrivate, extraEntropy) {\n  // Step A, ignored as hash already provided\n  // Step B\n  // Step C\n  let k = Buffer.alloc(32, 0);\n  let v = Buffer.alloc(32, 1);\n\n  // Step D\n  k = createHmac('sha256', k).update(v).update(ZERO1).update(x).update(hash).update(extraEntropy || '').digest();\n\n  // Step E\n  v = createHmac('sha256', k).update(v).digest();\n\n  // Step F\n  k = createHmac('sha256', k).update(v).update(ONE1).update(x).update(hash).update(extraEntropy || '').digest();\n\n  // Step G\n  v = createHmac('sha256', k).update(v).digest();\n\n  // Step H1/H2a, ignored as tlen === qlen (256 bit)\n  // Step H2b\n  v = createHmac('sha256', k).update(v).digest();\n  let T = v;\n\n  // Step H3, repeat until T is within the interval [1, n - 1] and is suitable for ECDSA\n  while (!isPrivate(T) || !checkSig(T)) {\n    k = createHmac('sha256', k).update(v).update(ZERO1).digest();\n    v = createHmac('sha256', k).update(v).digest();\n\n    // Step H1/H2a, again, ignored as tlen === qlen (256 bit)\n    // Step H2b again\n    v = createHmac('sha256', k).update(v).digest();\n    T = v;\n  }\n  return T;\n}\nmodule.exports = deterministicGenerateK;","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}