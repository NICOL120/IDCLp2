{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Coin = void 0;\nvar json_1 = require(\"../util/json\");\nvar numeric_1 = require(\"./numeric\");\nvar coin_1 = require(\"@terra-money/terra.proto/cosmos/base/v1beta1/coin\");\n/**\n * Captures `sdk.Coin` and `sdk.DecCoin` from Cosmos SDK. A composite value that combines\n * a denomination with an amount value. Coins are immutable once created, and operations\n * that return Coin will return a new Coin. See [[Coins]] for a collection of Coin objects.\n */\nvar Coin = /** @class */function (_super) {\n  __extends(Coin, _super);\n  /**\n   * Creates a new coin. Depending on the type of amount, it will be converted to an\n   * integer coin or decimal coin.\n   *\n   * @param denom denomination\n   * @param amount coin's amount\n   */\n  function Coin(denom, amount) {\n    var _this = _super.call(this) || this;\n    _this.denom = denom;\n    _this.amount = numeric_1.Numeric.parse(amount);\n    return _this;\n  }\n  /**\n   * Checks whether the Coin is an Integer coin.\n   */\n  Coin.prototype.isIntCoin = function () {\n    // TODO: convert into typeguard\n    return this.amount instanceof numeric_1.Int;\n  };\n  /**\n   * Checks whether the Coin is a Decimal coin.\n   */\n  Coin.prototype.isDecCoin = function () {\n    return this.amount instanceof numeric_1.Dec;\n  };\n  /**\n   * Turns the Coin into an Integer coin.\n   */\n  Coin.prototype.toIntCoin = function () {\n    return new Coin(this.denom, new numeric_1.Int(this.amount));\n  };\n  /**\n   * Turns the Coin into an Integer coin with ceiling the amount.\n   */\n  Coin.prototype.toIntCeilCoin = function () {\n    return new Coin(this.denom, new numeric_1.Int(this.amount.ceil()));\n  };\n  /**\n   * Turns the Coin into a Decimal coin.\n   */\n  Coin.prototype.toDecCoin = function () {\n    return new Coin(this.denom, new numeric_1.Dec(this.amount));\n  };\n  /**\n   * Outputs `<amount><denom>`.\n   *\n   * Eg: `Coin('uluna', 1500) -> 1500uluna`\n   */\n  Coin.prototype.toString = function () {\n    var amount = this.amount.toFixed();\n    if (this.isDecCoin() && amount.indexOf('.') === -1) {\n      return \"\".concat(amount, \".0\").concat(this.denom);\n    }\n    return \"\".concat(amount).concat(this.denom);\n  };\n  Coin.fromString = function (str) {\n    var m = str.match(/^(-?[0-9]+(\\.[0-9]+)?)([0-9a-zA-Z/]+)$/);\n    if (m === null) {\n      throw new Error(\"failed to parse to Coin: \".concat(str));\n    }\n    var amount = m[1];\n    var denom = m[3];\n    return new Coin(denom, amount);\n  };\n  /**\n   * Creates a new Coin adding to the current value.\n   *\n   * @param other\n   */\n  Coin.prototype.add = function (other) {\n    var otherAmount;\n    if (other instanceof Coin) {\n      if (other.denom !== this.denom) {\n        throw new Coin.ArithmeticError(\"cannot add two Coins of different denoms: \".concat(this.denom, \" and \").concat(other.denom));\n      }\n      otherAmount = other.amount;\n    } else {\n      otherAmount = other;\n    }\n    otherAmount = numeric_1.Numeric.parse(otherAmount);\n    return new Coin(this.denom, this.amount.add(otherAmount));\n  };\n  /**\n   * Creates a new Coin subtracting from the current value.\n   * @param other\n   */\n  Coin.prototype.sub = function (other) {\n    var otherAmount;\n    if (other instanceof Coin) {\n      if (other.denom !== this.denom) {\n        throw new Coin.ArithmeticError(\"cannot subtract two Coins of different denoms: \".concat(this.denom, \" and \").concat(other.denom));\n      }\n      otherAmount = other.amount;\n    } else {\n      otherAmount = other;\n    }\n    otherAmount = numeric_1.Numeric.parse(otherAmount);\n    return new Coin(this.denom, this.amount.sub(otherAmount));\n  };\n  /**\n   * Multiplies the current value with an amount.\n   * @param other\n   */\n  Coin.prototype.mul = function (other) {\n    var otherAmount = numeric_1.Numeric.parse(other);\n    return new Coin(this.denom, this.amount.mul(otherAmount));\n  };\n  /**\n   * Divides the current value with an amount.\n   * @param other\n   */\n  Coin.prototype.div = function (other) {\n    var otherAmount = numeric_1.Numeric.parse(other);\n    return new Coin(this.denom, this.amount.div(otherAmount));\n  };\n  /**\n   * Modulo the current value with an amount.\n   * @param other\n   */\n  Coin.prototype.mod = function (other) {\n    var otherAmount = numeric_1.Numeric.parse(other);\n    return new Coin(this.denom, this.amount.mod(otherAmount));\n  };\n  Coin.fromAmino = function (data) {\n    var denom = data.denom,\n      amount = data.amount;\n    return new Coin(denom, amount);\n  };\n  Coin.prototype.toAmino = function () {\n    var _a = this,\n      denom = _a.denom,\n      amount = _a.amount;\n    return {\n      denom: denom,\n      amount: amount.toString()\n    };\n  };\n  Coin.fromData = function (data) {\n    var denom = data.denom,\n      amount = data.amount;\n    return new Coin(denom, amount);\n  };\n  Coin.prototype.toData = function () {\n    var _a = this,\n      denom = _a.denom,\n      amount = _a.amount;\n    return {\n      denom: denom,\n      amount: amount.toString()\n    };\n  };\n  Coin.fromProto = function (proto) {\n    return new Coin(proto.denom, numeric_1.Numeric.parse(proto.amount));\n  };\n  Coin.prototype.toProto = function () {\n    return coin_1.Coin.fromPartial({\n      denom: this.denom,\n      amount: this.amount.toString()\n    });\n  };\n  return Coin;\n}(json_1.JSONSerializable);\nexports.Coin = Coin;\n(function (Coin) {\n  var ArithmeticError = /** @class */function () {\n    function ArithmeticError(message) {\n      this.message = message;\n    }\n    return ArithmeticError;\n  }();\n  Coin.ArithmeticError = ArithmeticError;\n})(Coin = exports.Coin || (exports.Coin = {}));\nexports.Coin = Coin;\n//# sourceMappingURL=Coin.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}