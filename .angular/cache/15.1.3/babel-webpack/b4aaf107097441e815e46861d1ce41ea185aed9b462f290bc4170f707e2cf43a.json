{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PolicyConstraints = void 0;\nvar json_1 = require(\"../../util/json\");\nvar Coin_1 = require(\"../Coin\");\nvar numeric_1 = require(\"../numeric\");\nvar treasury_1 = require(\"@terra-money/legacy.proto/terra/treasury/v1beta1/treasury\");\n/**\n * This captures the Treasury module's `tax_policy` and `reward_policy` parameters, which\n * determine how the Tax Rate and Reward Weight values are allowed to change.\n */\nvar PolicyConstraints = /** @class */function (_super) {\n  __extends(PolicyConstraints, _super);\n  /**\n   *\n   * @param rate_min minimum value\n   * @param rate_max maximum value\n   * @param cap Tax Cap (only applicable for Tax Rate)\n   * @param change_rate_max max change %\n   */\n  function PolicyConstraints(rate_min, rate_max, cap, change_rate_max) {\n    var _this = _super.call(this) || this;\n    _this.cap = cap;\n    _this.rate_min = new numeric_1.Dec(rate_min);\n    _this.rate_max = new numeric_1.Dec(rate_max);\n    _this.change_rate_max = new numeric_1.Dec(change_rate_max);\n    return _this;\n  }\n  PolicyConstraints.fromAmino = function (data) {\n    var rate_min = data.rate_min,\n      rate_max = data.rate_max,\n      cap = data.cap,\n      change_rate_max = data.change_rate_max;\n    return new PolicyConstraints(rate_min, rate_max, Coin_1.Coin.fromAmino(cap), change_rate_max);\n  };\n  PolicyConstraints.prototype.toAmino = function () {\n    var _a = this,\n      rate_min = _a.rate_min,\n      rate_max = _a.rate_max,\n      cap = _a.cap,\n      change_rate_max = _a.change_rate_max;\n    return {\n      rate_min: rate_min.toString(),\n      rate_max: rate_max.toString(),\n      cap: cap.toAmino(),\n      change_rate_max: change_rate_max.toString()\n    };\n  };\n  PolicyConstraints.fromData = function (data) {\n    var rate_min = data.rate_min,\n      rate_max = data.rate_max,\n      cap = data.cap,\n      change_rate_max = data.change_rate_max;\n    return new PolicyConstraints(rate_min, rate_max, Coin_1.Coin.fromData(cap), change_rate_max);\n  };\n  PolicyConstraints.prototype.toData = function () {\n    var _a = this,\n      rate_min = _a.rate_min,\n      rate_max = _a.rate_max,\n      cap = _a.cap,\n      change_rate_max = _a.change_rate_max;\n    return {\n      rate_min: rate_min.toString(),\n      rate_max: rate_max.toString(),\n      cap: cap.toData(),\n      change_rate_max: change_rate_max.toString()\n    };\n  };\n  PolicyConstraints.fromProto = function (proto) {\n    return new PolicyConstraints(proto.rateMax, proto.rateMin, Coin_1.Coin.fromProto(proto.cap), proto.changeRateMax);\n  };\n  PolicyConstraints.prototype.toProto = function () {\n    var _a = this,\n      rate_min = _a.rate_min,\n      rate_max = _a.rate_max,\n      cap = _a.cap,\n      change_rate_max = _a.change_rate_max;\n    return treasury_1.PolicyConstraints.fromPartial({\n      cap: cap.toProto(),\n      changeRateMax: change_rate_max.toString(),\n      rateMax: rate_max.toString(),\n      rateMin: rate_min.toString()\n    });\n  };\n  /**\n   * You can simulate the result of the clamping algorithm, which subjects updates in\n   * rate to the rules defined by the `PolicyConstraints`.\n   *\n   * @param prevRate previous rate\n   * @param newRate next rate\n   * @returns New rate, after clamping constraints have been applied\n   */\n  PolicyConstraints.prototype.clamp = function (prevRate, newRate) {\n    var p = new numeric_1.Dec(prevRate); // prev\n    var n = new numeric_1.Dec(newRate); // new\n    if (n.lt(this.rate_min)) {\n      n = this.rate_min;\n    } else if (n.gt(this.rate_max)) {\n      n = this.rate_max;\n    }\n    var delta = n.sub(p);\n    if (n.gt(p)) {\n      if (delta.gt(this.change_rate_max)) {\n        n = p.add(this.change_rate_max);\n      }\n    } else {\n      if (delta.abs().gt(this.change_rate_max)) {\n        n = p.sub(this.change_rate_max);\n      }\n    }\n    return n;\n  };\n  return PolicyConstraints;\n}(json_1.JSONSerializable);\nexports.PolicyConstraints = PolicyConstraints;\n//# sourceMappingURL=PolicyConstraints.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}