{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GrpcWebImpl = exports.ABCIApplicationApplySnapshotChunkDesc = exports.ABCIApplicationLoadSnapshotChunkDesc = exports.ABCIApplicationOfferSnapshotDesc = exports.ABCIApplicationListSnapshotsDesc = exports.ABCIApplicationEndBlockDesc = exports.ABCIApplicationBeginBlockDesc = exports.ABCIApplicationInitChainDesc = exports.ABCIApplicationCommitDesc = exports.ABCIApplicationQueryDesc = exports.ABCIApplicationCheckTxDesc = exports.ABCIApplicationDeliverTxDesc = exports.ABCIApplicationSetOptionDesc = exports.ABCIApplicationInfoDesc = exports.ABCIApplicationFlushDesc = exports.ABCIApplicationEchoDesc = exports.ABCIApplicationDesc = exports.ABCIApplicationClientImpl = exports.Snapshot = exports.Evidence = exports.VoteInfo = exports.ValidatorUpdate = exports.Validator = exports.TxResult = exports.EventAttribute = exports.Event = exports.LastCommitInfo = exports.BlockParams = exports.ConsensusParams = exports.ResponseApplySnapshotChunk = exports.ResponseLoadSnapshotChunk = exports.ResponseOfferSnapshot = exports.ResponseListSnapshots = exports.ResponseCommit = exports.ResponseEndBlock = exports.ResponseDeliverTx = exports.ResponseCheckTx = exports.ResponseBeginBlock = exports.ResponseQuery = exports.ResponseInitChain = exports.ResponseSetOption = exports.ResponseInfo = exports.ResponseFlush = exports.ResponseEcho = exports.ResponseException = exports.Response = exports.RequestApplySnapshotChunk = exports.RequestLoadSnapshotChunk = exports.RequestOfferSnapshot = exports.RequestListSnapshots = exports.RequestCommit = exports.RequestEndBlock = exports.RequestDeliverTx = exports.RequestCheckTx = exports.RequestBeginBlock = exports.RequestQuery = exports.RequestInitChain = exports.RequestSetOption = exports.RequestInfo = exports.RequestFlush = exports.RequestEcho = exports.Request = exports.responseApplySnapshotChunk_ResultToJSON = exports.responseApplySnapshotChunk_ResultFromJSON = exports.ResponseApplySnapshotChunk_Result = exports.responseOfferSnapshot_ResultToJSON = exports.responseOfferSnapshot_ResultFromJSON = exports.ResponseOfferSnapshot_Result = exports.evidenceTypeToJSON = exports.evidenceTypeFromJSON = exports.EvidenceType = exports.checkTxTypeToJSON = exports.checkTxTypeFromJSON = exports.CheckTxType = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst grpc_web_1 = require(\"@improbable-eng/grpc-web\");\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst types_1 = require(\"../../tendermint/types/types\");\nconst proof_1 = require(\"../../tendermint/crypto/proof\");\nconst params_1 = require(\"../../tendermint/types/params\");\nconst keys_1 = require(\"../../tendermint/crypto/keys\");\nconst browser_headers_1 = require(\"browser-headers\");\nconst timestamp_1 = require(\"../../google/protobuf/timestamp\");\nexports.protobufPackage = \"tendermint.abci\";\nvar CheckTxType;\n(function (CheckTxType) {\n  CheckTxType[CheckTxType[\"NEW\"] = 0] = \"NEW\";\n  CheckTxType[CheckTxType[\"RECHECK\"] = 1] = \"RECHECK\";\n  CheckTxType[CheckTxType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(CheckTxType = exports.CheckTxType || (exports.CheckTxType = {}));\nfunction checkTxTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NEW\":\n      return CheckTxType.NEW;\n    case 1:\n    case \"RECHECK\":\n      return CheckTxType.RECHECK;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return CheckTxType.UNRECOGNIZED;\n  }\n}\nexports.checkTxTypeFromJSON = checkTxTypeFromJSON;\nfunction checkTxTypeToJSON(object) {\n  switch (object) {\n    case CheckTxType.NEW:\n      return \"NEW\";\n    case CheckTxType.RECHECK:\n      return \"RECHECK\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.checkTxTypeToJSON = checkTxTypeToJSON;\nvar EvidenceType;\n(function (EvidenceType) {\n  EvidenceType[EvidenceType[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  EvidenceType[EvidenceType[\"DUPLICATE_VOTE\"] = 1] = \"DUPLICATE_VOTE\";\n  EvidenceType[EvidenceType[\"LIGHT_CLIENT_ATTACK\"] = 2] = \"LIGHT_CLIENT_ATTACK\";\n  EvidenceType[EvidenceType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(EvidenceType = exports.EvidenceType || (exports.EvidenceType = {}));\nfunction evidenceTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return EvidenceType.UNKNOWN;\n    case 1:\n    case \"DUPLICATE_VOTE\":\n      return EvidenceType.DUPLICATE_VOTE;\n    case 2:\n    case \"LIGHT_CLIENT_ATTACK\":\n      return EvidenceType.LIGHT_CLIENT_ATTACK;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return EvidenceType.UNRECOGNIZED;\n  }\n}\nexports.evidenceTypeFromJSON = evidenceTypeFromJSON;\nfunction evidenceTypeToJSON(object) {\n  switch (object) {\n    case EvidenceType.UNKNOWN:\n      return \"UNKNOWN\";\n    case EvidenceType.DUPLICATE_VOTE:\n      return \"DUPLICATE_VOTE\";\n    case EvidenceType.LIGHT_CLIENT_ATTACK:\n      return \"LIGHT_CLIENT_ATTACK\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.evidenceTypeToJSON = evidenceTypeToJSON;\nvar ResponseOfferSnapshot_Result;\n(function (ResponseOfferSnapshot_Result) {\n  /** UNKNOWN - Unknown result, abort all snapshot restoration */\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  /** ACCEPT - Snapshot accepted, apply chunks */\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"ACCEPT\"] = 1] = \"ACCEPT\";\n  /** ABORT - Abort all snapshot restoration */\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"ABORT\"] = 2] = \"ABORT\";\n  /** REJECT - Reject this specific snapshot, try others */\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"REJECT\"] = 3] = \"REJECT\";\n  /** REJECT_FORMAT - Reject all snapshots of this format, try others */\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"REJECT_FORMAT\"] = 4] = \"REJECT_FORMAT\";\n  /** REJECT_SENDER - Reject all snapshots from the sender(s), try others */\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"REJECT_SENDER\"] = 5] = \"REJECT_SENDER\";\n  ResponseOfferSnapshot_Result[ResponseOfferSnapshot_Result[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ResponseOfferSnapshot_Result = exports.ResponseOfferSnapshot_Result || (exports.ResponseOfferSnapshot_Result = {}));\nfunction responseOfferSnapshot_ResultFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return ResponseOfferSnapshot_Result.UNKNOWN;\n    case 1:\n    case \"ACCEPT\":\n      return ResponseOfferSnapshot_Result.ACCEPT;\n    case 2:\n    case \"ABORT\":\n      return ResponseOfferSnapshot_Result.ABORT;\n    case 3:\n    case \"REJECT\":\n      return ResponseOfferSnapshot_Result.REJECT;\n    case 4:\n    case \"REJECT_FORMAT\":\n      return ResponseOfferSnapshot_Result.REJECT_FORMAT;\n    case 5:\n    case \"REJECT_SENDER\":\n      return ResponseOfferSnapshot_Result.REJECT_SENDER;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ResponseOfferSnapshot_Result.UNRECOGNIZED;\n  }\n}\nexports.responseOfferSnapshot_ResultFromJSON = responseOfferSnapshot_ResultFromJSON;\nfunction responseOfferSnapshot_ResultToJSON(object) {\n  switch (object) {\n    case ResponseOfferSnapshot_Result.UNKNOWN:\n      return \"UNKNOWN\";\n    case ResponseOfferSnapshot_Result.ACCEPT:\n      return \"ACCEPT\";\n    case ResponseOfferSnapshot_Result.ABORT:\n      return \"ABORT\";\n    case ResponseOfferSnapshot_Result.REJECT:\n      return \"REJECT\";\n    case ResponseOfferSnapshot_Result.REJECT_FORMAT:\n      return \"REJECT_FORMAT\";\n    case ResponseOfferSnapshot_Result.REJECT_SENDER:\n      return \"REJECT_SENDER\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.responseOfferSnapshot_ResultToJSON = responseOfferSnapshot_ResultToJSON;\nvar ResponseApplySnapshotChunk_Result;\n(function (ResponseApplySnapshotChunk_Result) {\n  /** UNKNOWN - Unknown result, abort all snapshot restoration */\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"UNKNOWN\"] = 0] = \"UNKNOWN\";\n  /** ACCEPT - Chunk successfully accepted */\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"ACCEPT\"] = 1] = \"ACCEPT\";\n  /** ABORT - Abort all snapshot restoration */\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"ABORT\"] = 2] = \"ABORT\";\n  /** RETRY - Retry chunk (combine with refetch and reject) */\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"RETRY\"] = 3] = \"RETRY\";\n  /** RETRY_SNAPSHOT - Retry snapshot (combine with refetch and reject) */\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"RETRY_SNAPSHOT\"] = 4] = \"RETRY_SNAPSHOT\";\n  /** REJECT_SNAPSHOT - Reject this snapshot, try others */\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"REJECT_SNAPSHOT\"] = 5] = \"REJECT_SNAPSHOT\";\n  ResponseApplySnapshotChunk_Result[ResponseApplySnapshotChunk_Result[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ResponseApplySnapshotChunk_Result = exports.ResponseApplySnapshotChunk_Result || (exports.ResponseApplySnapshotChunk_Result = {}));\nfunction responseApplySnapshotChunk_ResultFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"UNKNOWN\":\n      return ResponseApplySnapshotChunk_Result.UNKNOWN;\n    case 1:\n    case \"ACCEPT\":\n      return ResponseApplySnapshotChunk_Result.ACCEPT;\n    case 2:\n    case \"ABORT\":\n      return ResponseApplySnapshotChunk_Result.ABORT;\n    case 3:\n    case \"RETRY\":\n      return ResponseApplySnapshotChunk_Result.RETRY;\n    case 4:\n    case \"RETRY_SNAPSHOT\":\n      return ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT;\n    case 5:\n    case \"REJECT_SNAPSHOT\":\n      return ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ResponseApplySnapshotChunk_Result.UNRECOGNIZED;\n  }\n}\nexports.responseApplySnapshotChunk_ResultFromJSON = responseApplySnapshotChunk_ResultFromJSON;\nfunction responseApplySnapshotChunk_ResultToJSON(object) {\n  switch (object) {\n    case ResponseApplySnapshotChunk_Result.UNKNOWN:\n      return \"UNKNOWN\";\n    case ResponseApplySnapshotChunk_Result.ACCEPT:\n      return \"ACCEPT\";\n    case ResponseApplySnapshotChunk_Result.ABORT:\n      return \"ABORT\";\n    case ResponseApplySnapshotChunk_Result.RETRY:\n      return \"RETRY\";\n    case ResponseApplySnapshotChunk_Result.RETRY_SNAPSHOT:\n      return \"RETRY_SNAPSHOT\";\n    case ResponseApplySnapshotChunk_Result.REJECT_SNAPSHOT:\n      return \"REJECT_SNAPSHOT\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.responseApplySnapshotChunk_ResultToJSON = responseApplySnapshotChunk_ResultToJSON;\nconst baseRequest = {};\nexports.Request = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.echo !== undefined) {\n      exports.RequestEcho.encode(message.echo, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.flush !== undefined) {\n      exports.RequestFlush.encode(message.flush, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.info !== undefined) {\n      exports.RequestInfo.encode(message.info, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.setOption !== undefined) {\n      exports.RequestSetOption.encode(message.setOption, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.initChain !== undefined) {\n      exports.RequestInitChain.encode(message.initChain, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.query !== undefined) {\n      exports.RequestQuery.encode(message.query, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.beginBlock !== undefined) {\n      exports.RequestBeginBlock.encode(message.beginBlock, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.checkTx !== undefined) {\n      exports.RequestCheckTx.encode(message.checkTx, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.deliverTx !== undefined) {\n      exports.RequestDeliverTx.encode(message.deliverTx, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.endBlock !== undefined) {\n      exports.RequestEndBlock.encode(message.endBlock, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.commit !== undefined) {\n      exports.RequestCommit.encode(message.commit, writer.uint32(90).fork()).ldelim();\n    }\n    if (message.listSnapshots !== undefined) {\n      exports.RequestListSnapshots.encode(message.listSnapshots, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.offerSnapshot !== undefined) {\n      exports.RequestOfferSnapshot.encode(message.offerSnapshot, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.loadSnapshotChunk !== undefined) {\n      exports.RequestLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(114).fork()).ldelim();\n    }\n    if (message.applySnapshotChunk !== undefined) {\n      exports.RequestApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(122).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequest);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.echo = exports.RequestEcho.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.flush = exports.RequestFlush.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.info = exports.RequestInfo.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.setOption = exports.RequestSetOption.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.initChain = exports.RequestInitChain.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.query = exports.RequestQuery.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.beginBlock = exports.RequestBeginBlock.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.checkTx = exports.RequestCheckTx.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.deliverTx = exports.RequestDeliverTx.decode(reader, reader.uint32());\n          break;\n        case 10:\n          message.endBlock = exports.RequestEndBlock.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.commit = exports.RequestCommit.decode(reader, reader.uint32());\n          break;\n        case 12:\n          message.listSnapshots = exports.RequestListSnapshots.decode(reader, reader.uint32());\n          break;\n        case 13:\n          message.offerSnapshot = exports.RequestOfferSnapshot.decode(reader, reader.uint32());\n          break;\n        case 14:\n          message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.decode(reader, reader.uint32());\n          break;\n        case 15:\n          message.applySnapshotChunk = exports.RequestApplySnapshotChunk.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequest);\n    if (object.echo !== undefined && object.echo !== null) {\n      message.echo = exports.RequestEcho.fromJSON(object.echo);\n    } else {\n      message.echo = undefined;\n    }\n    if (object.flush !== undefined && object.flush !== null) {\n      message.flush = exports.RequestFlush.fromJSON(object.flush);\n    } else {\n      message.flush = undefined;\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = exports.RequestInfo.fromJSON(object.info);\n    } else {\n      message.info = undefined;\n    }\n    if (object.setOption !== undefined && object.setOption !== null) {\n      message.setOption = exports.RequestSetOption.fromJSON(object.setOption);\n    } else {\n      message.setOption = undefined;\n    }\n    if (object.initChain !== undefined && object.initChain !== null) {\n      message.initChain = exports.RequestInitChain.fromJSON(object.initChain);\n    } else {\n      message.initChain = undefined;\n    }\n    if (object.query !== undefined && object.query !== null) {\n      message.query = exports.RequestQuery.fromJSON(object.query);\n    } else {\n      message.query = undefined;\n    }\n    if (object.beginBlock !== undefined && object.beginBlock !== null) {\n      message.beginBlock = exports.RequestBeginBlock.fromJSON(object.beginBlock);\n    } else {\n      message.beginBlock = undefined;\n    }\n    if (object.checkTx !== undefined && object.checkTx !== null) {\n      message.checkTx = exports.RequestCheckTx.fromJSON(object.checkTx);\n    } else {\n      message.checkTx = undefined;\n    }\n    if (object.deliverTx !== undefined && object.deliverTx !== null) {\n      message.deliverTx = exports.RequestDeliverTx.fromJSON(object.deliverTx);\n    } else {\n      message.deliverTx = undefined;\n    }\n    if (object.endBlock !== undefined && object.endBlock !== null) {\n      message.endBlock = exports.RequestEndBlock.fromJSON(object.endBlock);\n    } else {\n      message.endBlock = undefined;\n    }\n    if (object.commit !== undefined && object.commit !== null) {\n      message.commit = exports.RequestCommit.fromJSON(object.commit);\n    } else {\n      message.commit = undefined;\n    }\n    if (object.listSnapshots !== undefined && object.listSnapshots !== null) {\n      message.listSnapshots = exports.RequestListSnapshots.fromJSON(object.listSnapshots);\n    } else {\n      message.listSnapshots = undefined;\n    }\n    if (object.offerSnapshot !== undefined && object.offerSnapshot !== null) {\n      message.offerSnapshot = exports.RequestOfferSnapshot.fromJSON(object.offerSnapshot);\n    } else {\n      message.offerSnapshot = undefined;\n    }\n    if (object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null) {\n      message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);\n    } else {\n      message.loadSnapshotChunk = undefined;\n    }\n    if (object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null) {\n      message.applySnapshotChunk = exports.RequestApplySnapshotChunk.fromJSON(object.applySnapshotChunk);\n    } else {\n      message.applySnapshotChunk = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.echo !== undefined && (obj.echo = message.echo ? exports.RequestEcho.toJSON(message.echo) : undefined);\n    message.flush !== undefined && (obj.flush = message.flush ? exports.RequestFlush.toJSON(message.flush) : undefined);\n    message.info !== undefined && (obj.info = message.info ? exports.RequestInfo.toJSON(message.info) : undefined);\n    message.setOption !== undefined && (obj.setOption = message.setOption ? exports.RequestSetOption.toJSON(message.setOption) : undefined);\n    message.initChain !== undefined && (obj.initChain = message.initChain ? exports.RequestInitChain.toJSON(message.initChain) : undefined);\n    message.query !== undefined && (obj.query = message.query ? exports.RequestQuery.toJSON(message.query) : undefined);\n    message.beginBlock !== undefined && (obj.beginBlock = message.beginBlock ? exports.RequestBeginBlock.toJSON(message.beginBlock) : undefined);\n    message.checkTx !== undefined && (obj.checkTx = message.checkTx ? exports.RequestCheckTx.toJSON(message.checkTx) : undefined);\n    message.deliverTx !== undefined && (obj.deliverTx = message.deliverTx ? exports.RequestDeliverTx.toJSON(message.deliverTx) : undefined);\n    message.endBlock !== undefined && (obj.endBlock = message.endBlock ? exports.RequestEndBlock.toJSON(message.endBlock) : undefined);\n    message.commit !== undefined && (obj.commit = message.commit ? exports.RequestCommit.toJSON(message.commit) : undefined);\n    message.listSnapshots !== undefined && (obj.listSnapshots = message.listSnapshots ? exports.RequestListSnapshots.toJSON(message.listSnapshots) : undefined);\n    message.offerSnapshot !== undefined && (obj.offerSnapshot = message.offerSnapshot ? exports.RequestOfferSnapshot.toJSON(message.offerSnapshot) : undefined);\n    message.loadSnapshotChunk !== undefined && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.RequestLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : undefined);\n    message.applySnapshotChunk !== undefined && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.RequestApplySnapshotChunk.toJSON(message.applySnapshotChunk) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequest);\n    if (object.echo !== undefined && object.echo !== null) {\n      message.echo = exports.RequestEcho.fromPartial(object.echo);\n    } else {\n      message.echo = undefined;\n    }\n    if (object.flush !== undefined && object.flush !== null) {\n      message.flush = exports.RequestFlush.fromPartial(object.flush);\n    } else {\n      message.flush = undefined;\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = exports.RequestInfo.fromPartial(object.info);\n    } else {\n      message.info = undefined;\n    }\n    if (object.setOption !== undefined && object.setOption !== null) {\n      message.setOption = exports.RequestSetOption.fromPartial(object.setOption);\n    } else {\n      message.setOption = undefined;\n    }\n    if (object.initChain !== undefined && object.initChain !== null) {\n      message.initChain = exports.RequestInitChain.fromPartial(object.initChain);\n    } else {\n      message.initChain = undefined;\n    }\n    if (object.query !== undefined && object.query !== null) {\n      message.query = exports.RequestQuery.fromPartial(object.query);\n    } else {\n      message.query = undefined;\n    }\n    if (object.beginBlock !== undefined && object.beginBlock !== null) {\n      message.beginBlock = exports.RequestBeginBlock.fromPartial(object.beginBlock);\n    } else {\n      message.beginBlock = undefined;\n    }\n    if (object.checkTx !== undefined && object.checkTx !== null) {\n      message.checkTx = exports.RequestCheckTx.fromPartial(object.checkTx);\n    } else {\n      message.checkTx = undefined;\n    }\n    if (object.deliverTx !== undefined && object.deliverTx !== null) {\n      message.deliverTx = exports.RequestDeliverTx.fromPartial(object.deliverTx);\n    } else {\n      message.deliverTx = undefined;\n    }\n    if (object.endBlock !== undefined && object.endBlock !== null) {\n      message.endBlock = exports.RequestEndBlock.fromPartial(object.endBlock);\n    } else {\n      message.endBlock = undefined;\n    }\n    if (object.commit !== undefined && object.commit !== null) {\n      message.commit = exports.RequestCommit.fromPartial(object.commit);\n    } else {\n      message.commit = undefined;\n    }\n    if (object.listSnapshots !== undefined && object.listSnapshots !== null) {\n      message.listSnapshots = exports.RequestListSnapshots.fromPartial(object.listSnapshots);\n    } else {\n      message.listSnapshots = undefined;\n    }\n    if (object.offerSnapshot !== undefined && object.offerSnapshot !== null) {\n      message.offerSnapshot = exports.RequestOfferSnapshot.fromPartial(object.offerSnapshot);\n    } else {\n      message.offerSnapshot = undefined;\n    }\n    if (object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null) {\n      message.loadSnapshotChunk = exports.RequestLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);\n    } else {\n      message.loadSnapshotChunk = undefined;\n    }\n    if (object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null) {\n      message.applySnapshotChunk = exports.RequestApplySnapshotChunk.fromPartial(object.applySnapshotChunk);\n    } else {\n      message.applySnapshotChunk = undefined;\n    }\n    return message;\n  }\n};\nconst baseRequestEcho = {\n  message: \"\"\n};\nexports.RequestEcho = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.message !== \"\") {\n      writer.uint32(10).string(message.message);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestEcho);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.message = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestEcho);\n    if (object.message !== undefined && object.message !== null) {\n      message.message = String(object.message);\n    } else {\n      message.message = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.message !== undefined && (obj.message = message.message);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestEcho);\n    if (object.message !== undefined && object.message !== null) {\n      message.message = object.message;\n    } else {\n      message.message = \"\";\n    }\n    return message;\n  }\n};\nconst baseRequestFlush = {};\nexports.RequestFlush = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestFlush);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseRequestFlush);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseRequestFlush);\n    return message;\n  }\n};\nconst baseRequestInfo = {\n  version: \"\",\n  blockVersion: long_1.default.UZERO,\n  p2pVersion: long_1.default.UZERO\n};\nexports.RequestInfo = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.version !== \"\") {\n      writer.uint32(10).string(message.version);\n    }\n    if (!message.blockVersion.isZero()) {\n      writer.uint32(16).uint64(message.blockVersion);\n    }\n    if (!message.p2pVersion.isZero()) {\n      writer.uint32(24).uint64(message.p2pVersion);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestInfo);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.version = reader.string();\n          break;\n        case 2:\n          message.blockVersion = reader.uint64();\n          break;\n        case 3:\n          message.p2pVersion = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestInfo);\n    if (object.version !== undefined && object.version !== null) {\n      message.version = String(object.version);\n    } else {\n      message.version = \"\";\n    }\n    if (object.blockVersion !== undefined && object.blockVersion !== null) {\n      message.blockVersion = long_1.default.fromString(object.blockVersion);\n    } else {\n      message.blockVersion = long_1.default.UZERO;\n    }\n    if (object.p2pVersion !== undefined && object.p2pVersion !== null) {\n      message.p2pVersion = long_1.default.fromString(object.p2pVersion);\n    } else {\n      message.p2pVersion = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.version !== undefined && (obj.version = message.version);\n    message.blockVersion !== undefined && (obj.blockVersion = (message.blockVersion || long_1.default.UZERO).toString());\n    message.p2pVersion !== undefined && (obj.p2pVersion = (message.p2pVersion || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestInfo);\n    if (object.version !== undefined && object.version !== null) {\n      message.version = object.version;\n    } else {\n      message.version = \"\";\n    }\n    if (object.blockVersion !== undefined && object.blockVersion !== null) {\n      message.blockVersion = object.blockVersion;\n    } else {\n      message.blockVersion = long_1.default.UZERO;\n    }\n    if (object.p2pVersion !== undefined && object.p2pVersion !== null) {\n      message.p2pVersion = object.p2pVersion;\n    } else {\n      message.p2pVersion = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nconst baseRequestSetOption = {\n  key: \"\",\n  value: \"\"\n};\nexports.RequestSetOption = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key !== \"\") {\n      writer.uint32(10).string(message.key);\n    }\n    if (message.value !== \"\") {\n      writer.uint32(18).string(message.value);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestSetOption);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.string();\n          break;\n        case 2:\n          message.value = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestSetOption);\n    if (object.key !== undefined && object.key !== null) {\n      message.key = String(object.key);\n    } else {\n      message.key = \"\";\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = String(object.value);\n    } else {\n      message.value = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = message.key);\n    message.value !== undefined && (obj.value = message.value);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestSetOption);\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = \"\";\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = object.value;\n    } else {\n      message.value = \"\";\n    }\n    return message;\n  }\n};\nconst baseRequestInitChain = {\n  chainId: \"\",\n  initialHeight: long_1.default.ZERO\n};\nexports.RequestInitChain = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.time !== undefined) {\n      timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(10).fork()).ldelim();\n    }\n    if (message.chainId !== \"\") {\n      writer.uint32(18).string(message.chainId);\n    }\n    if (message.consensusParams !== undefined) {\n      exports.ConsensusParams.encode(message.consensusParams, writer.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.validators) {\n      exports.ValidatorUpdate.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.appStateBytes.length !== 0) {\n      writer.uint32(42).bytes(message.appStateBytes);\n    }\n    if (!message.initialHeight.isZero()) {\n      writer.uint32(48).int64(message.initialHeight);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestInitChain);\n    message.validators = [];\n    message.appStateBytes = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.chainId = reader.string();\n          break;\n        case 3:\n          message.consensusParams = exports.ConsensusParams.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.appStateBytes = reader.bytes();\n          break;\n        case 6:\n          message.initialHeight = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestInitChain);\n    message.validators = [];\n    message.appStateBytes = new Uint8Array();\n    if (object.time !== undefined && object.time !== null) {\n      message.time = fromJsonTimestamp(object.time);\n    } else {\n      message.time = undefined;\n    }\n    if (object.chainId !== undefined && object.chainId !== null) {\n      message.chainId = String(object.chainId);\n    } else {\n      message.chainId = \"\";\n    }\n    if (object.consensusParams !== undefined && object.consensusParams !== null) {\n      message.consensusParams = exports.ConsensusParams.fromJSON(object.consensusParams);\n    } else {\n      message.consensusParams = undefined;\n    }\n    if (object.validators !== undefined && object.validators !== null) {\n      for (const e of object.validators) {\n        message.validators.push(exports.ValidatorUpdate.fromJSON(e));\n      }\n    }\n    if (object.appStateBytes !== undefined && object.appStateBytes !== null) {\n      message.appStateBytes = bytesFromBase64(object.appStateBytes);\n    }\n    if (object.initialHeight !== undefined && object.initialHeight !== null) {\n      message.initialHeight = long_1.default.fromString(object.initialHeight);\n    } else {\n      message.initialHeight = long_1.default.ZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.time !== undefined && (obj.time = message.time.toISOString());\n    message.chainId !== undefined && (obj.chainId = message.chainId);\n    message.consensusParams !== undefined && (obj.consensusParams = message.consensusParams ? exports.ConsensusParams.toJSON(message.consensusParams) : undefined);\n    if (message.validators) {\n      obj.validators = message.validators.map(e => e ? exports.ValidatorUpdate.toJSON(e) : undefined);\n    } else {\n      obj.validators = [];\n    }\n    message.appStateBytes !== undefined && (obj.appStateBytes = base64FromBytes(message.appStateBytes !== undefined ? message.appStateBytes : new Uint8Array()));\n    message.initialHeight !== undefined && (obj.initialHeight = (message.initialHeight || long_1.default.ZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestInitChain);\n    message.validators = [];\n    if (object.time !== undefined && object.time !== null) {\n      message.time = object.time;\n    } else {\n      message.time = undefined;\n    }\n    if (object.chainId !== undefined && object.chainId !== null) {\n      message.chainId = object.chainId;\n    } else {\n      message.chainId = \"\";\n    }\n    if (object.consensusParams !== undefined && object.consensusParams !== null) {\n      message.consensusParams = exports.ConsensusParams.fromPartial(object.consensusParams);\n    } else {\n      message.consensusParams = undefined;\n    }\n    if (object.validators !== undefined && object.validators !== null) {\n      for (const e of object.validators) {\n        message.validators.push(exports.ValidatorUpdate.fromPartial(e));\n      }\n    }\n    if (object.appStateBytes !== undefined && object.appStateBytes !== null) {\n      message.appStateBytes = object.appStateBytes;\n    } else {\n      message.appStateBytes = new Uint8Array();\n    }\n    if (object.initialHeight !== undefined && object.initialHeight !== null) {\n      message.initialHeight = object.initialHeight;\n    } else {\n      message.initialHeight = long_1.default.ZERO;\n    }\n    return message;\n  }\n};\nconst baseRequestQuery = {\n  path: \"\",\n  height: long_1.default.ZERO,\n  prove: false\n};\nexports.RequestQuery = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.data.length !== 0) {\n      writer.uint32(10).bytes(message.data);\n    }\n    if (message.path !== \"\") {\n      writer.uint32(18).string(message.path);\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(24).int64(message.height);\n    }\n    if (message.prove === true) {\n      writer.uint32(32).bool(message.prove);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestQuery);\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n        case 2:\n          message.path = reader.string();\n          break;\n        case 3:\n          message.height = reader.int64();\n          break;\n        case 4:\n          message.prove = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestQuery);\n    message.data = new Uint8Array();\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    if (object.path !== undefined && object.path !== null) {\n      message.path = String(object.path);\n    } else {\n      message.path = \"\";\n    }\n    if (object.height !== undefined && object.height !== null) {\n      message.height = long_1.default.fromString(object.height);\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    if (object.prove !== undefined && object.prove !== null) {\n      message.prove = Boolean(object.prove);\n    } else {\n      message.prove = false;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    message.path !== undefined && (obj.path = message.path);\n    message.height !== undefined && (obj.height = (message.height || long_1.default.ZERO).toString());\n    message.prove !== undefined && (obj.prove = message.prove);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestQuery);\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    if (object.path !== undefined && object.path !== null) {\n      message.path = object.path;\n    } else {\n      message.path = \"\";\n    }\n    if (object.height !== undefined && object.height !== null) {\n      message.height = object.height;\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    if (object.prove !== undefined && object.prove !== null) {\n      message.prove = object.prove;\n    } else {\n      message.prove = false;\n    }\n    return message;\n  }\n};\nconst baseRequestBeginBlock = {};\nexports.RequestBeginBlock = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.hash.length !== 0) {\n      writer.uint32(10).bytes(message.hash);\n    }\n    if (message.header !== undefined) {\n      types_1.Header.encode(message.header, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.lastCommitInfo !== undefined) {\n      exports.LastCommitInfo.encode(message.lastCommitInfo, writer.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.byzantineValidators) {\n      exports.Evidence.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestBeginBlock);\n    message.byzantineValidators = [];\n    message.hash = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.bytes();\n          break;\n        case 2:\n          message.header = types_1.Header.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.lastCommitInfo = exports.LastCommitInfo.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.byzantineValidators.push(exports.Evidence.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestBeginBlock);\n    message.byzantineValidators = [];\n    message.hash = new Uint8Array();\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = bytesFromBase64(object.hash);\n    }\n    if (object.header !== undefined && object.header !== null) {\n      message.header = types_1.Header.fromJSON(object.header);\n    } else {\n      message.header = undefined;\n    }\n    if (object.lastCommitInfo !== undefined && object.lastCommitInfo !== null) {\n      message.lastCommitInfo = exports.LastCommitInfo.fromJSON(object.lastCommitInfo);\n    } else {\n      message.lastCommitInfo = undefined;\n    }\n    if (object.byzantineValidators !== undefined && object.byzantineValidators !== null) {\n      for (const e of object.byzantineValidators) {\n        message.byzantineValidators.push(exports.Evidence.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));\n    message.header !== undefined && (obj.header = message.header ? types_1.Header.toJSON(message.header) : undefined);\n    message.lastCommitInfo !== undefined && (obj.lastCommitInfo = message.lastCommitInfo ? exports.LastCommitInfo.toJSON(message.lastCommitInfo) : undefined);\n    if (message.byzantineValidators) {\n      obj.byzantineValidators = message.byzantineValidators.map(e => e ? exports.Evidence.toJSON(e) : undefined);\n    } else {\n      obj.byzantineValidators = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestBeginBlock);\n    message.byzantineValidators = [];\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = new Uint8Array();\n    }\n    if (object.header !== undefined && object.header !== null) {\n      message.header = types_1.Header.fromPartial(object.header);\n    } else {\n      message.header = undefined;\n    }\n    if (object.lastCommitInfo !== undefined && object.lastCommitInfo !== null) {\n      message.lastCommitInfo = exports.LastCommitInfo.fromPartial(object.lastCommitInfo);\n    } else {\n      message.lastCommitInfo = undefined;\n    }\n    if (object.byzantineValidators !== undefined && object.byzantineValidators !== null) {\n      for (const e of object.byzantineValidators) {\n        message.byzantineValidators.push(exports.Evidence.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseRequestCheckTx = {\n  type: 0\n};\nexports.RequestCheckTx = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.tx.length !== 0) {\n      writer.uint32(10).bytes(message.tx);\n    }\n    if (message.type !== 0) {\n      writer.uint32(16).int32(message.type);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestCheckTx);\n    message.tx = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tx = reader.bytes();\n          break;\n        case 2:\n          message.type = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestCheckTx);\n    message.tx = new Uint8Array();\n    if (object.tx !== undefined && object.tx !== null) {\n      message.tx = bytesFromBase64(object.tx);\n    }\n    if (object.type !== undefined && object.type !== null) {\n      message.type = checkTxTypeFromJSON(object.type);\n    } else {\n      message.type = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.tx !== undefined && (obj.tx = base64FromBytes(message.tx !== undefined ? message.tx : new Uint8Array()));\n    message.type !== undefined && (obj.type = checkTxTypeToJSON(message.type));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestCheckTx);\n    if (object.tx !== undefined && object.tx !== null) {\n      message.tx = object.tx;\n    } else {\n      message.tx = new Uint8Array();\n    }\n    if (object.type !== undefined && object.type !== null) {\n      message.type = object.type;\n    } else {\n      message.type = 0;\n    }\n    return message;\n  }\n};\nconst baseRequestDeliverTx = {};\nexports.RequestDeliverTx = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.tx.length !== 0) {\n      writer.uint32(10).bytes(message.tx);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestDeliverTx);\n    message.tx = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.tx = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestDeliverTx);\n    message.tx = new Uint8Array();\n    if (object.tx !== undefined && object.tx !== null) {\n      message.tx = bytesFromBase64(object.tx);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.tx !== undefined && (obj.tx = base64FromBytes(message.tx !== undefined ? message.tx : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestDeliverTx);\n    if (object.tx !== undefined && object.tx !== null) {\n      message.tx = object.tx;\n    } else {\n      message.tx = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseRequestEndBlock = {\n  height: long_1.default.ZERO\n};\nexports.RequestEndBlock = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.height.isZero()) {\n      writer.uint32(8).int64(message.height);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestEndBlock);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestEndBlock);\n    if (object.height !== undefined && object.height !== null) {\n      message.height = long_1.default.fromString(object.height);\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.height !== undefined && (obj.height = (message.height || long_1.default.ZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestEndBlock);\n    if (object.height !== undefined && object.height !== null) {\n      message.height = object.height;\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    return message;\n  }\n};\nconst baseRequestCommit = {};\nexports.RequestCommit = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestCommit);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseRequestCommit);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseRequestCommit);\n    return message;\n  }\n};\nconst baseRequestListSnapshots = {};\nexports.RequestListSnapshots = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestListSnapshots);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseRequestListSnapshots);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseRequestListSnapshots);\n    return message;\n  }\n};\nconst baseRequestOfferSnapshot = {};\nexports.RequestOfferSnapshot = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.snapshot !== undefined) {\n      exports.Snapshot.encode(message.snapshot, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.appHash.length !== 0) {\n      writer.uint32(18).bytes(message.appHash);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestOfferSnapshot);\n    message.appHash = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.snapshot = exports.Snapshot.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.appHash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestOfferSnapshot);\n    message.appHash = new Uint8Array();\n    if (object.snapshot !== undefined && object.snapshot !== null) {\n      message.snapshot = exports.Snapshot.fromJSON(object.snapshot);\n    } else {\n      message.snapshot = undefined;\n    }\n    if (object.appHash !== undefined && object.appHash !== null) {\n      message.appHash = bytesFromBase64(object.appHash);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.snapshot !== undefined && (obj.snapshot = message.snapshot ? exports.Snapshot.toJSON(message.snapshot) : undefined);\n    message.appHash !== undefined && (obj.appHash = base64FromBytes(message.appHash !== undefined ? message.appHash : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestOfferSnapshot);\n    if (object.snapshot !== undefined && object.snapshot !== null) {\n      message.snapshot = exports.Snapshot.fromPartial(object.snapshot);\n    } else {\n      message.snapshot = undefined;\n    }\n    if (object.appHash !== undefined && object.appHash !== null) {\n      message.appHash = object.appHash;\n    } else {\n      message.appHash = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseRequestLoadSnapshotChunk = {\n  height: long_1.default.UZERO,\n  format: 0,\n  chunk: 0\n};\nexports.RequestLoadSnapshotChunk = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.height.isZero()) {\n      writer.uint32(8).uint64(message.height);\n    }\n    if (message.format !== 0) {\n      writer.uint32(16).uint32(message.format);\n    }\n    if (message.chunk !== 0) {\n      writer.uint32(24).uint32(message.chunk);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestLoadSnapshotChunk);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.uint64();\n          break;\n        case 2:\n          message.format = reader.uint32();\n          break;\n        case 3:\n          message.chunk = reader.uint32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestLoadSnapshotChunk);\n    if (object.height !== undefined && object.height !== null) {\n      message.height = long_1.default.fromString(object.height);\n    } else {\n      message.height = long_1.default.UZERO;\n    }\n    if (object.format !== undefined && object.format !== null) {\n      message.format = Number(object.format);\n    } else {\n      message.format = 0;\n    }\n    if (object.chunk !== undefined && object.chunk !== null) {\n      message.chunk = Number(object.chunk);\n    } else {\n      message.chunk = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.height !== undefined && (obj.height = (message.height || long_1.default.UZERO).toString());\n    message.format !== undefined && (obj.format = message.format);\n    message.chunk !== undefined && (obj.chunk = message.chunk);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestLoadSnapshotChunk);\n    if (object.height !== undefined && object.height !== null) {\n      message.height = object.height;\n    } else {\n      message.height = long_1.default.UZERO;\n    }\n    if (object.format !== undefined && object.format !== null) {\n      message.format = object.format;\n    } else {\n      message.format = 0;\n    }\n    if (object.chunk !== undefined && object.chunk !== null) {\n      message.chunk = object.chunk;\n    } else {\n      message.chunk = 0;\n    }\n    return message;\n  }\n};\nconst baseRequestApplySnapshotChunk = {\n  index: 0,\n  sender: \"\"\n};\nexports.RequestApplySnapshotChunk = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.index !== 0) {\n      writer.uint32(8).uint32(message.index);\n    }\n    if (message.chunk.length !== 0) {\n      writer.uint32(18).bytes(message.chunk);\n    }\n    if (message.sender !== \"\") {\n      writer.uint32(26).string(message.sender);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRequestApplySnapshotChunk);\n    message.chunk = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.index = reader.uint32();\n          break;\n        case 2:\n          message.chunk = reader.bytes();\n          break;\n        case 3:\n          message.sender = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRequestApplySnapshotChunk);\n    message.chunk = new Uint8Array();\n    if (object.index !== undefined && object.index !== null) {\n      message.index = Number(object.index);\n    } else {\n      message.index = 0;\n    }\n    if (object.chunk !== undefined && object.chunk !== null) {\n      message.chunk = bytesFromBase64(object.chunk);\n    }\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.index !== undefined && (obj.index = message.index);\n    message.chunk !== undefined && (obj.chunk = base64FromBytes(message.chunk !== undefined ? message.chunk : new Uint8Array()));\n    message.sender !== undefined && (obj.sender = message.sender);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRequestApplySnapshotChunk);\n    if (object.index !== undefined && object.index !== null) {\n      message.index = object.index;\n    } else {\n      message.index = 0;\n    }\n    if (object.chunk !== undefined && object.chunk !== null) {\n      message.chunk = object.chunk;\n    } else {\n      message.chunk = new Uint8Array();\n    }\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    return message;\n  }\n};\nconst baseResponse = {};\nexports.Response = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.exception !== undefined) {\n      exports.ResponseException.encode(message.exception, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.echo !== undefined) {\n      exports.ResponseEcho.encode(message.echo, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.flush !== undefined) {\n      exports.ResponseFlush.encode(message.flush, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.info !== undefined) {\n      exports.ResponseInfo.encode(message.info, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.setOption !== undefined) {\n      exports.ResponseSetOption.encode(message.setOption, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.initChain !== undefined) {\n      exports.ResponseInitChain.encode(message.initChain, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.query !== undefined) {\n      exports.ResponseQuery.encode(message.query, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.beginBlock !== undefined) {\n      exports.ResponseBeginBlock.encode(message.beginBlock, writer.uint32(66).fork()).ldelim();\n    }\n    if (message.checkTx !== undefined) {\n      exports.ResponseCheckTx.encode(message.checkTx, writer.uint32(74).fork()).ldelim();\n    }\n    if (message.deliverTx !== undefined) {\n      exports.ResponseDeliverTx.encode(message.deliverTx, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.endBlock !== undefined) {\n      exports.ResponseEndBlock.encode(message.endBlock, writer.uint32(90).fork()).ldelim();\n    }\n    if (message.commit !== undefined) {\n      exports.ResponseCommit.encode(message.commit, writer.uint32(98).fork()).ldelim();\n    }\n    if (message.listSnapshots !== undefined) {\n      exports.ResponseListSnapshots.encode(message.listSnapshots, writer.uint32(106).fork()).ldelim();\n    }\n    if (message.offerSnapshot !== undefined) {\n      exports.ResponseOfferSnapshot.encode(message.offerSnapshot, writer.uint32(114).fork()).ldelim();\n    }\n    if (message.loadSnapshotChunk !== undefined) {\n      exports.ResponseLoadSnapshotChunk.encode(message.loadSnapshotChunk, writer.uint32(122).fork()).ldelim();\n    }\n    if (message.applySnapshotChunk !== undefined) {\n      exports.ResponseApplySnapshotChunk.encode(message.applySnapshotChunk, writer.uint32(130).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exception = exports.ResponseException.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.echo = exports.ResponseEcho.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.flush = exports.ResponseFlush.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.info = exports.ResponseInfo.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.setOption = exports.ResponseSetOption.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.initChain = exports.ResponseInitChain.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.query = exports.ResponseQuery.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.beginBlock = exports.ResponseBeginBlock.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.checkTx = exports.ResponseCheckTx.decode(reader, reader.uint32());\n          break;\n        case 10:\n          message.deliverTx = exports.ResponseDeliverTx.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.endBlock = exports.ResponseEndBlock.decode(reader, reader.uint32());\n          break;\n        case 12:\n          message.commit = exports.ResponseCommit.decode(reader, reader.uint32());\n          break;\n        case 13:\n          message.listSnapshots = exports.ResponseListSnapshots.decode(reader, reader.uint32());\n          break;\n        case 14:\n          message.offerSnapshot = exports.ResponseOfferSnapshot.decode(reader, reader.uint32());\n          break;\n        case 15:\n          message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.decode(reader, reader.uint32());\n          break;\n        case 16:\n          message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponse);\n    if (object.exception !== undefined && object.exception !== null) {\n      message.exception = exports.ResponseException.fromJSON(object.exception);\n    } else {\n      message.exception = undefined;\n    }\n    if (object.echo !== undefined && object.echo !== null) {\n      message.echo = exports.ResponseEcho.fromJSON(object.echo);\n    } else {\n      message.echo = undefined;\n    }\n    if (object.flush !== undefined && object.flush !== null) {\n      message.flush = exports.ResponseFlush.fromJSON(object.flush);\n    } else {\n      message.flush = undefined;\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = exports.ResponseInfo.fromJSON(object.info);\n    } else {\n      message.info = undefined;\n    }\n    if (object.setOption !== undefined && object.setOption !== null) {\n      message.setOption = exports.ResponseSetOption.fromJSON(object.setOption);\n    } else {\n      message.setOption = undefined;\n    }\n    if (object.initChain !== undefined && object.initChain !== null) {\n      message.initChain = exports.ResponseInitChain.fromJSON(object.initChain);\n    } else {\n      message.initChain = undefined;\n    }\n    if (object.query !== undefined && object.query !== null) {\n      message.query = exports.ResponseQuery.fromJSON(object.query);\n    } else {\n      message.query = undefined;\n    }\n    if (object.beginBlock !== undefined && object.beginBlock !== null) {\n      message.beginBlock = exports.ResponseBeginBlock.fromJSON(object.beginBlock);\n    } else {\n      message.beginBlock = undefined;\n    }\n    if (object.checkTx !== undefined && object.checkTx !== null) {\n      message.checkTx = exports.ResponseCheckTx.fromJSON(object.checkTx);\n    } else {\n      message.checkTx = undefined;\n    }\n    if (object.deliverTx !== undefined && object.deliverTx !== null) {\n      message.deliverTx = exports.ResponseDeliverTx.fromJSON(object.deliverTx);\n    } else {\n      message.deliverTx = undefined;\n    }\n    if (object.endBlock !== undefined && object.endBlock !== null) {\n      message.endBlock = exports.ResponseEndBlock.fromJSON(object.endBlock);\n    } else {\n      message.endBlock = undefined;\n    }\n    if (object.commit !== undefined && object.commit !== null) {\n      message.commit = exports.ResponseCommit.fromJSON(object.commit);\n    } else {\n      message.commit = undefined;\n    }\n    if (object.listSnapshots !== undefined && object.listSnapshots !== null) {\n      message.listSnapshots = exports.ResponseListSnapshots.fromJSON(object.listSnapshots);\n    } else {\n      message.listSnapshots = undefined;\n    }\n    if (object.offerSnapshot !== undefined && object.offerSnapshot !== null) {\n      message.offerSnapshot = exports.ResponseOfferSnapshot.fromJSON(object.offerSnapshot);\n    } else {\n      message.offerSnapshot = undefined;\n    }\n    if (object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null) {\n      message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.fromJSON(object.loadSnapshotChunk);\n    } else {\n      message.loadSnapshotChunk = undefined;\n    }\n    if (object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null) {\n      message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.fromJSON(object.applySnapshotChunk);\n    } else {\n      message.applySnapshotChunk = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.exception !== undefined && (obj.exception = message.exception ? exports.ResponseException.toJSON(message.exception) : undefined);\n    message.echo !== undefined && (obj.echo = message.echo ? exports.ResponseEcho.toJSON(message.echo) : undefined);\n    message.flush !== undefined && (obj.flush = message.flush ? exports.ResponseFlush.toJSON(message.flush) : undefined);\n    message.info !== undefined && (obj.info = message.info ? exports.ResponseInfo.toJSON(message.info) : undefined);\n    message.setOption !== undefined && (obj.setOption = message.setOption ? exports.ResponseSetOption.toJSON(message.setOption) : undefined);\n    message.initChain !== undefined && (obj.initChain = message.initChain ? exports.ResponseInitChain.toJSON(message.initChain) : undefined);\n    message.query !== undefined && (obj.query = message.query ? exports.ResponseQuery.toJSON(message.query) : undefined);\n    message.beginBlock !== undefined && (obj.beginBlock = message.beginBlock ? exports.ResponseBeginBlock.toJSON(message.beginBlock) : undefined);\n    message.checkTx !== undefined && (obj.checkTx = message.checkTx ? exports.ResponseCheckTx.toJSON(message.checkTx) : undefined);\n    message.deliverTx !== undefined && (obj.deliverTx = message.deliverTx ? exports.ResponseDeliverTx.toJSON(message.deliverTx) : undefined);\n    message.endBlock !== undefined && (obj.endBlock = message.endBlock ? exports.ResponseEndBlock.toJSON(message.endBlock) : undefined);\n    message.commit !== undefined && (obj.commit = message.commit ? exports.ResponseCommit.toJSON(message.commit) : undefined);\n    message.listSnapshots !== undefined && (obj.listSnapshots = message.listSnapshots ? exports.ResponseListSnapshots.toJSON(message.listSnapshots) : undefined);\n    message.offerSnapshot !== undefined && (obj.offerSnapshot = message.offerSnapshot ? exports.ResponseOfferSnapshot.toJSON(message.offerSnapshot) : undefined);\n    message.loadSnapshotChunk !== undefined && (obj.loadSnapshotChunk = message.loadSnapshotChunk ? exports.ResponseLoadSnapshotChunk.toJSON(message.loadSnapshotChunk) : undefined);\n    message.applySnapshotChunk !== undefined && (obj.applySnapshotChunk = message.applySnapshotChunk ? exports.ResponseApplySnapshotChunk.toJSON(message.applySnapshotChunk) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponse);\n    if (object.exception !== undefined && object.exception !== null) {\n      message.exception = exports.ResponseException.fromPartial(object.exception);\n    } else {\n      message.exception = undefined;\n    }\n    if (object.echo !== undefined && object.echo !== null) {\n      message.echo = exports.ResponseEcho.fromPartial(object.echo);\n    } else {\n      message.echo = undefined;\n    }\n    if (object.flush !== undefined && object.flush !== null) {\n      message.flush = exports.ResponseFlush.fromPartial(object.flush);\n    } else {\n      message.flush = undefined;\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = exports.ResponseInfo.fromPartial(object.info);\n    } else {\n      message.info = undefined;\n    }\n    if (object.setOption !== undefined && object.setOption !== null) {\n      message.setOption = exports.ResponseSetOption.fromPartial(object.setOption);\n    } else {\n      message.setOption = undefined;\n    }\n    if (object.initChain !== undefined && object.initChain !== null) {\n      message.initChain = exports.ResponseInitChain.fromPartial(object.initChain);\n    } else {\n      message.initChain = undefined;\n    }\n    if (object.query !== undefined && object.query !== null) {\n      message.query = exports.ResponseQuery.fromPartial(object.query);\n    } else {\n      message.query = undefined;\n    }\n    if (object.beginBlock !== undefined && object.beginBlock !== null) {\n      message.beginBlock = exports.ResponseBeginBlock.fromPartial(object.beginBlock);\n    } else {\n      message.beginBlock = undefined;\n    }\n    if (object.checkTx !== undefined && object.checkTx !== null) {\n      message.checkTx = exports.ResponseCheckTx.fromPartial(object.checkTx);\n    } else {\n      message.checkTx = undefined;\n    }\n    if (object.deliverTx !== undefined && object.deliverTx !== null) {\n      message.deliverTx = exports.ResponseDeliverTx.fromPartial(object.deliverTx);\n    } else {\n      message.deliverTx = undefined;\n    }\n    if (object.endBlock !== undefined && object.endBlock !== null) {\n      message.endBlock = exports.ResponseEndBlock.fromPartial(object.endBlock);\n    } else {\n      message.endBlock = undefined;\n    }\n    if (object.commit !== undefined && object.commit !== null) {\n      message.commit = exports.ResponseCommit.fromPartial(object.commit);\n    } else {\n      message.commit = undefined;\n    }\n    if (object.listSnapshots !== undefined && object.listSnapshots !== null) {\n      message.listSnapshots = exports.ResponseListSnapshots.fromPartial(object.listSnapshots);\n    } else {\n      message.listSnapshots = undefined;\n    }\n    if (object.offerSnapshot !== undefined && object.offerSnapshot !== null) {\n      message.offerSnapshot = exports.ResponseOfferSnapshot.fromPartial(object.offerSnapshot);\n    } else {\n      message.offerSnapshot = undefined;\n    }\n    if (object.loadSnapshotChunk !== undefined && object.loadSnapshotChunk !== null) {\n      message.loadSnapshotChunk = exports.ResponseLoadSnapshotChunk.fromPartial(object.loadSnapshotChunk);\n    } else {\n      message.loadSnapshotChunk = undefined;\n    }\n    if (object.applySnapshotChunk !== undefined && object.applySnapshotChunk !== null) {\n      message.applySnapshotChunk = exports.ResponseApplySnapshotChunk.fromPartial(object.applySnapshotChunk);\n    } else {\n      message.applySnapshotChunk = undefined;\n    }\n    return message;\n  }\n};\nconst baseResponseException = {\n  error: \"\"\n};\nexports.ResponseException = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.error !== \"\") {\n      writer.uint32(10).string(message.error);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseException);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.error = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseException);\n    if (object.error !== undefined && object.error !== null) {\n      message.error = String(object.error);\n    } else {\n      message.error = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.error !== undefined && (obj.error = message.error);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseException);\n    if (object.error !== undefined && object.error !== null) {\n      message.error = object.error;\n    } else {\n      message.error = \"\";\n    }\n    return message;\n  }\n};\nconst baseResponseEcho = {\n  message: \"\"\n};\nexports.ResponseEcho = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.message !== \"\") {\n      writer.uint32(10).string(message.message);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseEcho);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.message = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseEcho);\n    if (object.message !== undefined && object.message !== null) {\n      message.message = String(object.message);\n    } else {\n      message.message = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.message !== undefined && (obj.message = message.message);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseEcho);\n    if (object.message !== undefined && object.message !== null) {\n      message.message = object.message;\n    } else {\n      message.message = \"\";\n    }\n    return message;\n  }\n};\nconst baseResponseFlush = {};\nexports.ResponseFlush = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseFlush);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseResponseFlush);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseResponseFlush);\n    return message;\n  }\n};\nconst baseResponseInfo = {\n  data: \"\",\n  version: \"\",\n  appVersion: long_1.default.UZERO,\n  lastBlockHeight: long_1.default.ZERO\n};\nexports.ResponseInfo = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.data !== \"\") {\n      writer.uint32(10).string(message.data);\n    }\n    if (message.version !== \"\") {\n      writer.uint32(18).string(message.version);\n    }\n    if (!message.appVersion.isZero()) {\n      writer.uint32(24).uint64(message.appVersion);\n    }\n    if (!message.lastBlockHeight.isZero()) {\n      writer.uint32(32).int64(message.lastBlockHeight);\n    }\n    if (message.lastBlockAppHash.length !== 0) {\n      writer.uint32(42).bytes(message.lastBlockAppHash);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseInfo);\n    message.lastBlockAppHash = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.string();\n          break;\n        case 2:\n          message.version = reader.string();\n          break;\n        case 3:\n          message.appVersion = reader.uint64();\n          break;\n        case 4:\n          message.lastBlockHeight = reader.int64();\n          break;\n        case 5:\n          message.lastBlockAppHash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseInfo);\n    message.lastBlockAppHash = new Uint8Array();\n    if (object.data !== undefined && object.data !== null) {\n      message.data = String(object.data);\n    } else {\n      message.data = \"\";\n    }\n    if (object.version !== undefined && object.version !== null) {\n      message.version = String(object.version);\n    } else {\n      message.version = \"\";\n    }\n    if (object.appVersion !== undefined && object.appVersion !== null) {\n      message.appVersion = long_1.default.fromString(object.appVersion);\n    } else {\n      message.appVersion = long_1.default.UZERO;\n    }\n    if (object.lastBlockHeight !== undefined && object.lastBlockHeight !== null) {\n      message.lastBlockHeight = long_1.default.fromString(object.lastBlockHeight);\n    } else {\n      message.lastBlockHeight = long_1.default.ZERO;\n    }\n    if (object.lastBlockAppHash !== undefined && object.lastBlockAppHash !== null) {\n      message.lastBlockAppHash = bytesFromBase64(object.lastBlockAppHash);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.data !== undefined && (obj.data = message.data);\n    message.version !== undefined && (obj.version = message.version);\n    message.appVersion !== undefined && (obj.appVersion = (message.appVersion || long_1.default.UZERO).toString());\n    message.lastBlockHeight !== undefined && (obj.lastBlockHeight = (message.lastBlockHeight || long_1.default.ZERO).toString());\n    message.lastBlockAppHash !== undefined && (obj.lastBlockAppHash = base64FromBytes(message.lastBlockAppHash !== undefined ? message.lastBlockAppHash : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseInfo);\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = \"\";\n    }\n    if (object.version !== undefined && object.version !== null) {\n      message.version = object.version;\n    } else {\n      message.version = \"\";\n    }\n    if (object.appVersion !== undefined && object.appVersion !== null) {\n      message.appVersion = object.appVersion;\n    } else {\n      message.appVersion = long_1.default.UZERO;\n    }\n    if (object.lastBlockHeight !== undefined && object.lastBlockHeight !== null) {\n      message.lastBlockHeight = object.lastBlockHeight;\n    } else {\n      message.lastBlockHeight = long_1.default.ZERO;\n    }\n    if (object.lastBlockAppHash !== undefined && object.lastBlockAppHash !== null) {\n      message.lastBlockAppHash = object.lastBlockAppHash;\n    } else {\n      message.lastBlockAppHash = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseResponseSetOption = {\n  code: 0,\n  log: \"\",\n  info: \"\"\n};\nexports.ResponseSetOption = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.code !== 0) {\n      writer.uint32(8).uint32(message.code);\n    }\n    if (message.log !== \"\") {\n      writer.uint32(26).string(message.log);\n    }\n    if (message.info !== \"\") {\n      writer.uint32(34).string(message.info);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseSetOption);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.uint32();\n          break;\n        case 3:\n          message.log = reader.string();\n          break;\n        case 4:\n          message.info = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseSetOption);\n    if (object.code !== undefined && object.code !== null) {\n      message.code = Number(object.code);\n    } else {\n      message.code = 0;\n    }\n    if (object.log !== undefined && object.log !== null) {\n      message.log = String(object.log);\n    } else {\n      message.log = \"\";\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = String(object.info);\n    } else {\n      message.info = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.code !== undefined && (obj.code = message.code);\n    message.log !== undefined && (obj.log = message.log);\n    message.info !== undefined && (obj.info = message.info);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseSetOption);\n    if (object.code !== undefined && object.code !== null) {\n      message.code = object.code;\n    } else {\n      message.code = 0;\n    }\n    if (object.log !== undefined && object.log !== null) {\n      message.log = object.log;\n    } else {\n      message.log = \"\";\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = object.info;\n    } else {\n      message.info = \"\";\n    }\n    return message;\n  }\n};\nconst baseResponseInitChain = {};\nexports.ResponseInitChain = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.consensusParams !== undefined) {\n      exports.ConsensusParams.encode(message.consensusParams, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.validators) {\n      exports.ValidatorUpdate.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.appHash.length !== 0) {\n      writer.uint32(26).bytes(message.appHash);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseInitChain);\n    message.validators = [];\n    message.appHash = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.consensusParams = exports.ConsensusParams.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.validators.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.appHash = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseInitChain);\n    message.validators = [];\n    message.appHash = new Uint8Array();\n    if (object.consensusParams !== undefined && object.consensusParams !== null) {\n      message.consensusParams = exports.ConsensusParams.fromJSON(object.consensusParams);\n    } else {\n      message.consensusParams = undefined;\n    }\n    if (object.validators !== undefined && object.validators !== null) {\n      for (const e of object.validators) {\n        message.validators.push(exports.ValidatorUpdate.fromJSON(e));\n      }\n    }\n    if (object.appHash !== undefined && object.appHash !== null) {\n      message.appHash = bytesFromBase64(object.appHash);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.consensusParams !== undefined && (obj.consensusParams = message.consensusParams ? exports.ConsensusParams.toJSON(message.consensusParams) : undefined);\n    if (message.validators) {\n      obj.validators = message.validators.map(e => e ? exports.ValidatorUpdate.toJSON(e) : undefined);\n    } else {\n      obj.validators = [];\n    }\n    message.appHash !== undefined && (obj.appHash = base64FromBytes(message.appHash !== undefined ? message.appHash : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseInitChain);\n    message.validators = [];\n    if (object.consensusParams !== undefined && object.consensusParams !== null) {\n      message.consensusParams = exports.ConsensusParams.fromPartial(object.consensusParams);\n    } else {\n      message.consensusParams = undefined;\n    }\n    if (object.validators !== undefined && object.validators !== null) {\n      for (const e of object.validators) {\n        message.validators.push(exports.ValidatorUpdate.fromPartial(e));\n      }\n    }\n    if (object.appHash !== undefined && object.appHash !== null) {\n      message.appHash = object.appHash;\n    } else {\n      message.appHash = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseResponseQuery = {\n  code: 0,\n  log: \"\",\n  info: \"\",\n  index: long_1.default.ZERO,\n  height: long_1.default.ZERO,\n  codespace: \"\"\n};\nexports.ResponseQuery = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.code !== 0) {\n      writer.uint32(8).uint32(message.code);\n    }\n    if (message.log !== \"\") {\n      writer.uint32(26).string(message.log);\n    }\n    if (message.info !== \"\") {\n      writer.uint32(34).string(message.info);\n    }\n    if (!message.index.isZero()) {\n      writer.uint32(40).int64(message.index);\n    }\n    if (message.key.length !== 0) {\n      writer.uint32(50).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(58).bytes(message.value);\n    }\n    if (message.proofOps !== undefined) {\n      proof_1.ProofOps.encode(message.proofOps, writer.uint32(66).fork()).ldelim();\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(72).int64(message.height);\n    }\n    if (message.codespace !== \"\") {\n      writer.uint32(82).string(message.codespace);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseQuery);\n    message.key = new Uint8Array();\n    message.value = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.uint32();\n          break;\n        case 3:\n          message.log = reader.string();\n          break;\n        case 4:\n          message.info = reader.string();\n          break;\n        case 5:\n          message.index = reader.int64();\n          break;\n        case 6:\n          message.key = reader.bytes();\n          break;\n        case 7:\n          message.value = reader.bytes();\n          break;\n        case 8:\n          message.proofOps = proof_1.ProofOps.decode(reader, reader.uint32());\n          break;\n        case 9:\n          message.height = reader.int64();\n          break;\n        case 10:\n          message.codespace = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseQuery);\n    message.key = new Uint8Array();\n    message.value = new Uint8Array();\n    if (object.code !== undefined && object.code !== null) {\n      message.code = Number(object.code);\n    } else {\n      message.code = 0;\n    }\n    if (object.log !== undefined && object.log !== null) {\n      message.log = String(object.log);\n    } else {\n      message.log = \"\";\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = String(object.info);\n    } else {\n      message.info = \"\";\n    }\n    if (object.index !== undefined && object.index !== null) {\n      message.index = long_1.default.fromString(object.index);\n    } else {\n      message.index = long_1.default.ZERO;\n    }\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = bytesFromBase64(object.value);\n    }\n    if (object.proofOps !== undefined && object.proofOps !== null) {\n      message.proofOps = proof_1.ProofOps.fromJSON(object.proofOps);\n    } else {\n      message.proofOps = undefined;\n    }\n    if (object.height !== undefined && object.height !== null) {\n      message.height = long_1.default.fromString(object.height);\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    if (object.codespace !== undefined && object.codespace !== null) {\n      message.codespace = String(object.codespace);\n    } else {\n      message.codespace = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.code !== undefined && (obj.code = message.code);\n    message.log !== undefined && (obj.log = message.log);\n    message.info !== undefined && (obj.info = message.info);\n    message.index !== undefined && (obj.index = (message.index || long_1.default.ZERO).toString());\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n    message.proofOps !== undefined && (obj.proofOps = message.proofOps ? proof_1.ProofOps.toJSON(message.proofOps) : undefined);\n    message.height !== undefined && (obj.height = (message.height || long_1.default.ZERO).toString());\n    message.codespace !== undefined && (obj.codespace = message.codespace);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseQuery);\n    if (object.code !== undefined && object.code !== null) {\n      message.code = object.code;\n    } else {\n      message.code = 0;\n    }\n    if (object.log !== undefined && object.log !== null) {\n      message.log = object.log;\n    } else {\n      message.log = \"\";\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = object.info;\n    } else {\n      message.info = \"\";\n    }\n    if (object.index !== undefined && object.index !== null) {\n      message.index = object.index;\n    } else {\n      message.index = long_1.default.ZERO;\n    }\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = object.value;\n    } else {\n      message.value = new Uint8Array();\n    }\n    if (object.proofOps !== undefined && object.proofOps !== null) {\n      message.proofOps = proof_1.ProofOps.fromPartial(object.proofOps);\n    } else {\n      message.proofOps = undefined;\n    }\n    if (object.height !== undefined && object.height !== null) {\n      message.height = object.height;\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    if (object.codespace !== undefined && object.codespace !== null) {\n      message.codespace = object.codespace;\n    } else {\n      message.codespace = \"\";\n    }\n    return message;\n  }\n};\nconst baseResponseBeginBlock = {};\nexports.ResponseBeginBlock = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.events) {\n      exports.Event.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseBeginBlock);\n    message.events = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.events.push(exports.Event.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseBeginBlock);\n    message.events = [];\n    if (object.events !== undefined && object.events !== null) {\n      for (const e of object.events) {\n        message.events.push(exports.Event.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.events) {\n      obj.events = message.events.map(e => e ? exports.Event.toJSON(e) : undefined);\n    } else {\n      obj.events = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseBeginBlock);\n    message.events = [];\n    if (object.events !== undefined && object.events !== null) {\n      for (const e of object.events) {\n        message.events.push(exports.Event.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseResponseCheckTx = {\n  code: 0,\n  log: \"\",\n  info: \"\",\n  gasWanted: long_1.default.ZERO,\n  gasUsed: long_1.default.ZERO,\n  codespace: \"\"\n};\nexports.ResponseCheckTx = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.code !== 0) {\n      writer.uint32(8).uint32(message.code);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (message.log !== \"\") {\n      writer.uint32(26).string(message.log);\n    }\n    if (message.info !== \"\") {\n      writer.uint32(34).string(message.info);\n    }\n    if (!message.gasWanted.isZero()) {\n      writer.uint32(40).int64(message.gasWanted);\n    }\n    if (!message.gasUsed.isZero()) {\n      writer.uint32(48).int64(message.gasUsed);\n    }\n    for (const v of message.events) {\n      exports.Event.encode(v, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.codespace !== \"\") {\n      writer.uint32(66).string(message.codespace);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseCheckTx);\n    message.events = [];\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.uint32();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.log = reader.string();\n          break;\n        case 4:\n          message.info = reader.string();\n          break;\n        case 5:\n          message.gasWanted = reader.int64();\n          break;\n        case 6:\n          message.gasUsed = reader.int64();\n          break;\n        case 7:\n          message.events.push(exports.Event.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.codespace = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseCheckTx);\n    message.events = [];\n    message.data = new Uint8Array();\n    if (object.code !== undefined && object.code !== null) {\n      message.code = Number(object.code);\n    } else {\n      message.code = 0;\n    }\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    if (object.log !== undefined && object.log !== null) {\n      message.log = String(object.log);\n    } else {\n      message.log = \"\";\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = String(object.info);\n    } else {\n      message.info = \"\";\n    }\n    if (object.gasWanted !== undefined && object.gasWanted !== null) {\n      message.gasWanted = long_1.default.fromString(object.gasWanted);\n    } else {\n      message.gasWanted = long_1.default.ZERO;\n    }\n    if (object.gasUsed !== undefined && object.gasUsed !== null) {\n      message.gasUsed = long_1.default.fromString(object.gasUsed);\n    } else {\n      message.gasUsed = long_1.default.ZERO;\n    }\n    if (object.events !== undefined && object.events !== null) {\n      for (const e of object.events) {\n        message.events.push(exports.Event.fromJSON(e));\n      }\n    }\n    if (object.codespace !== undefined && object.codespace !== null) {\n      message.codespace = String(object.codespace);\n    } else {\n      message.codespace = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.code !== undefined && (obj.code = message.code);\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    message.log !== undefined && (obj.log = message.log);\n    message.info !== undefined && (obj.info = message.info);\n    message.gasWanted !== undefined && (obj.gasWanted = (message.gasWanted || long_1.default.ZERO).toString());\n    message.gasUsed !== undefined && (obj.gasUsed = (message.gasUsed || long_1.default.ZERO).toString());\n    if (message.events) {\n      obj.events = message.events.map(e => e ? exports.Event.toJSON(e) : undefined);\n    } else {\n      obj.events = [];\n    }\n    message.codespace !== undefined && (obj.codespace = message.codespace);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseCheckTx);\n    message.events = [];\n    if (object.code !== undefined && object.code !== null) {\n      message.code = object.code;\n    } else {\n      message.code = 0;\n    }\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    if (object.log !== undefined && object.log !== null) {\n      message.log = object.log;\n    } else {\n      message.log = \"\";\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = object.info;\n    } else {\n      message.info = \"\";\n    }\n    if (object.gasWanted !== undefined && object.gasWanted !== null) {\n      message.gasWanted = object.gasWanted;\n    } else {\n      message.gasWanted = long_1.default.ZERO;\n    }\n    if (object.gasUsed !== undefined && object.gasUsed !== null) {\n      message.gasUsed = object.gasUsed;\n    } else {\n      message.gasUsed = long_1.default.ZERO;\n    }\n    if (object.events !== undefined && object.events !== null) {\n      for (const e of object.events) {\n        message.events.push(exports.Event.fromPartial(e));\n      }\n    }\n    if (object.codespace !== undefined && object.codespace !== null) {\n      message.codespace = object.codespace;\n    } else {\n      message.codespace = \"\";\n    }\n    return message;\n  }\n};\nconst baseResponseDeliverTx = {\n  code: 0,\n  log: \"\",\n  info: \"\",\n  gasWanted: long_1.default.ZERO,\n  gasUsed: long_1.default.ZERO,\n  codespace: \"\"\n};\nexports.ResponseDeliverTx = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.code !== 0) {\n      writer.uint32(8).uint32(message.code);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (message.log !== \"\") {\n      writer.uint32(26).string(message.log);\n    }\n    if (message.info !== \"\") {\n      writer.uint32(34).string(message.info);\n    }\n    if (!message.gasWanted.isZero()) {\n      writer.uint32(40).int64(message.gasWanted);\n    }\n    if (!message.gasUsed.isZero()) {\n      writer.uint32(48).int64(message.gasUsed);\n    }\n    for (const v of message.events) {\n      exports.Event.encode(v, writer.uint32(58).fork()).ldelim();\n    }\n    if (message.codespace !== \"\") {\n      writer.uint32(66).string(message.codespace);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseDeliverTx);\n    message.events = [];\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.code = reader.uint32();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.log = reader.string();\n          break;\n        case 4:\n          message.info = reader.string();\n          break;\n        case 5:\n          message.gasWanted = reader.int64();\n          break;\n        case 6:\n          message.gasUsed = reader.int64();\n          break;\n        case 7:\n          message.events.push(exports.Event.decode(reader, reader.uint32()));\n          break;\n        case 8:\n          message.codespace = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseDeliverTx);\n    message.events = [];\n    message.data = new Uint8Array();\n    if (object.code !== undefined && object.code !== null) {\n      message.code = Number(object.code);\n    } else {\n      message.code = 0;\n    }\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    if (object.log !== undefined && object.log !== null) {\n      message.log = String(object.log);\n    } else {\n      message.log = \"\";\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = String(object.info);\n    } else {\n      message.info = \"\";\n    }\n    if (object.gasWanted !== undefined && object.gasWanted !== null) {\n      message.gasWanted = long_1.default.fromString(object.gasWanted);\n    } else {\n      message.gasWanted = long_1.default.ZERO;\n    }\n    if (object.gasUsed !== undefined && object.gasUsed !== null) {\n      message.gasUsed = long_1.default.fromString(object.gasUsed);\n    } else {\n      message.gasUsed = long_1.default.ZERO;\n    }\n    if (object.events !== undefined && object.events !== null) {\n      for (const e of object.events) {\n        message.events.push(exports.Event.fromJSON(e));\n      }\n    }\n    if (object.codespace !== undefined && object.codespace !== null) {\n      message.codespace = String(object.codespace);\n    } else {\n      message.codespace = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.code !== undefined && (obj.code = message.code);\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    message.log !== undefined && (obj.log = message.log);\n    message.info !== undefined && (obj.info = message.info);\n    message.gasWanted !== undefined && (obj.gasWanted = (message.gasWanted || long_1.default.ZERO).toString());\n    message.gasUsed !== undefined && (obj.gasUsed = (message.gasUsed || long_1.default.ZERO).toString());\n    if (message.events) {\n      obj.events = message.events.map(e => e ? exports.Event.toJSON(e) : undefined);\n    } else {\n      obj.events = [];\n    }\n    message.codespace !== undefined && (obj.codespace = message.codespace);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseDeliverTx);\n    message.events = [];\n    if (object.code !== undefined && object.code !== null) {\n      message.code = object.code;\n    } else {\n      message.code = 0;\n    }\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    if (object.log !== undefined && object.log !== null) {\n      message.log = object.log;\n    } else {\n      message.log = \"\";\n    }\n    if (object.info !== undefined && object.info !== null) {\n      message.info = object.info;\n    } else {\n      message.info = \"\";\n    }\n    if (object.gasWanted !== undefined && object.gasWanted !== null) {\n      message.gasWanted = object.gasWanted;\n    } else {\n      message.gasWanted = long_1.default.ZERO;\n    }\n    if (object.gasUsed !== undefined && object.gasUsed !== null) {\n      message.gasUsed = object.gasUsed;\n    } else {\n      message.gasUsed = long_1.default.ZERO;\n    }\n    if (object.events !== undefined && object.events !== null) {\n      for (const e of object.events) {\n        message.events.push(exports.Event.fromPartial(e));\n      }\n    }\n    if (object.codespace !== undefined && object.codespace !== null) {\n      message.codespace = object.codespace;\n    } else {\n      message.codespace = \"\";\n    }\n    return message;\n  }\n};\nconst baseResponseEndBlock = {};\nexports.ResponseEndBlock = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.validatorUpdates) {\n      exports.ValidatorUpdate.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.consensusParamUpdates !== undefined) {\n      exports.ConsensusParams.encode(message.consensusParamUpdates, writer.uint32(18).fork()).ldelim();\n    }\n    for (const v of message.events) {\n      exports.Event.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseEndBlock);\n    message.validatorUpdates = [];\n    message.events = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.validatorUpdates.push(exports.ValidatorUpdate.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.consensusParamUpdates = exports.ConsensusParams.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.events.push(exports.Event.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseEndBlock);\n    message.validatorUpdates = [];\n    message.events = [];\n    if (object.validatorUpdates !== undefined && object.validatorUpdates !== null) {\n      for (const e of object.validatorUpdates) {\n        message.validatorUpdates.push(exports.ValidatorUpdate.fromJSON(e));\n      }\n    }\n    if (object.consensusParamUpdates !== undefined && object.consensusParamUpdates !== null) {\n      message.consensusParamUpdates = exports.ConsensusParams.fromJSON(object.consensusParamUpdates);\n    } else {\n      message.consensusParamUpdates = undefined;\n    }\n    if (object.events !== undefined && object.events !== null) {\n      for (const e of object.events) {\n        message.events.push(exports.Event.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.validatorUpdates) {\n      obj.validatorUpdates = message.validatorUpdates.map(e => e ? exports.ValidatorUpdate.toJSON(e) : undefined);\n    } else {\n      obj.validatorUpdates = [];\n    }\n    message.consensusParamUpdates !== undefined && (obj.consensusParamUpdates = message.consensusParamUpdates ? exports.ConsensusParams.toJSON(message.consensusParamUpdates) : undefined);\n    if (message.events) {\n      obj.events = message.events.map(e => e ? exports.Event.toJSON(e) : undefined);\n    } else {\n      obj.events = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseEndBlock);\n    message.validatorUpdates = [];\n    message.events = [];\n    if (object.validatorUpdates !== undefined && object.validatorUpdates !== null) {\n      for (const e of object.validatorUpdates) {\n        message.validatorUpdates.push(exports.ValidatorUpdate.fromPartial(e));\n      }\n    }\n    if (object.consensusParamUpdates !== undefined && object.consensusParamUpdates !== null) {\n      message.consensusParamUpdates = exports.ConsensusParams.fromPartial(object.consensusParamUpdates);\n    } else {\n      message.consensusParamUpdates = undefined;\n    }\n    if (object.events !== undefined && object.events !== null) {\n      for (const e of object.events) {\n        message.events.push(exports.Event.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseResponseCommit = {\n  retainHeight: long_1.default.ZERO\n};\nexports.ResponseCommit = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    if (!message.retainHeight.isZero()) {\n      writer.uint32(24).int64(message.retainHeight);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseCommit);\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 2:\n          message.data = reader.bytes();\n          break;\n        case 3:\n          message.retainHeight = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseCommit);\n    message.data = new Uint8Array();\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    if (object.retainHeight !== undefined && object.retainHeight !== null) {\n      message.retainHeight = long_1.default.fromString(object.retainHeight);\n    } else {\n      message.retainHeight = long_1.default.ZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    message.retainHeight !== undefined && (obj.retainHeight = (message.retainHeight || long_1.default.ZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseCommit);\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    if (object.retainHeight !== undefined && object.retainHeight !== null) {\n      message.retainHeight = object.retainHeight;\n    } else {\n      message.retainHeight = long_1.default.ZERO;\n    }\n    return message;\n  }\n};\nconst baseResponseListSnapshots = {};\nexports.ResponseListSnapshots = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.snapshots) {\n      exports.Snapshot.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseListSnapshots);\n    message.snapshots = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.snapshots.push(exports.Snapshot.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseListSnapshots);\n    message.snapshots = [];\n    if (object.snapshots !== undefined && object.snapshots !== null) {\n      for (const e of object.snapshots) {\n        message.snapshots.push(exports.Snapshot.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.snapshots) {\n      obj.snapshots = message.snapshots.map(e => e ? exports.Snapshot.toJSON(e) : undefined);\n    } else {\n      obj.snapshots = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseListSnapshots);\n    message.snapshots = [];\n    if (object.snapshots !== undefined && object.snapshots !== null) {\n      for (const e of object.snapshots) {\n        message.snapshots.push(exports.Snapshot.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseResponseOfferSnapshot = {\n  result: 0\n};\nexports.ResponseOfferSnapshot = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseOfferSnapshot);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseOfferSnapshot);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = responseOfferSnapshot_ResultFromJSON(object.result);\n    } else {\n      message.result = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.result !== undefined && (obj.result = responseOfferSnapshot_ResultToJSON(message.result));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseOfferSnapshot);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = object.result;\n    } else {\n      message.result = 0;\n    }\n    return message;\n  }\n};\nconst baseResponseLoadSnapshotChunk = {};\nexports.ResponseLoadSnapshotChunk = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.chunk.length !== 0) {\n      writer.uint32(10).bytes(message.chunk);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseLoadSnapshotChunk);\n    message.chunk = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.chunk = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseLoadSnapshotChunk);\n    message.chunk = new Uint8Array();\n    if (object.chunk !== undefined && object.chunk !== null) {\n      message.chunk = bytesFromBase64(object.chunk);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.chunk !== undefined && (obj.chunk = base64FromBytes(message.chunk !== undefined ? message.chunk : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseLoadSnapshotChunk);\n    if (object.chunk !== undefined && object.chunk !== null) {\n      message.chunk = object.chunk;\n    } else {\n      message.chunk = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseResponseApplySnapshotChunk = {\n  result: 0,\n  refetchChunks: 0,\n  rejectSenders: \"\"\n};\nexports.ResponseApplySnapshotChunk = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    writer.uint32(18).fork();\n    for (const v of message.refetchChunks) {\n      writer.uint32(v);\n    }\n    writer.ldelim();\n    for (const v of message.rejectSenders) {\n      writer.uint32(26).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseResponseApplySnapshotChunk);\n    message.refetchChunks = [];\n    message.rejectSenders = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        case 2:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.refetchChunks.push(reader.uint32());\n            }\n          } else {\n            message.refetchChunks.push(reader.uint32());\n          }\n          break;\n        case 3:\n          message.rejectSenders.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseResponseApplySnapshotChunk);\n    message.refetchChunks = [];\n    message.rejectSenders = [];\n    if (object.result !== undefined && object.result !== null) {\n      message.result = responseApplySnapshotChunk_ResultFromJSON(object.result);\n    } else {\n      message.result = 0;\n    }\n    if (object.refetchChunks !== undefined && object.refetchChunks !== null) {\n      for (const e of object.refetchChunks) {\n        message.refetchChunks.push(Number(e));\n      }\n    }\n    if (object.rejectSenders !== undefined && object.rejectSenders !== null) {\n      for (const e of object.rejectSenders) {\n        message.rejectSenders.push(String(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.result !== undefined && (obj.result = responseApplySnapshotChunk_ResultToJSON(message.result));\n    if (message.refetchChunks) {\n      obj.refetchChunks = message.refetchChunks.map(e => e);\n    } else {\n      obj.refetchChunks = [];\n    }\n    if (message.rejectSenders) {\n      obj.rejectSenders = message.rejectSenders.map(e => e);\n    } else {\n      obj.rejectSenders = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseResponseApplySnapshotChunk);\n    message.refetchChunks = [];\n    message.rejectSenders = [];\n    if (object.result !== undefined && object.result !== null) {\n      message.result = object.result;\n    } else {\n      message.result = 0;\n    }\n    if (object.refetchChunks !== undefined && object.refetchChunks !== null) {\n      for (const e of object.refetchChunks) {\n        message.refetchChunks.push(e);\n      }\n    }\n    if (object.rejectSenders !== undefined && object.rejectSenders !== null) {\n      for (const e of object.rejectSenders) {\n        message.rejectSenders.push(e);\n      }\n    }\n    return message;\n  }\n};\nconst baseConsensusParams = {};\nexports.ConsensusParams = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.block !== undefined) {\n      exports.BlockParams.encode(message.block, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.evidence !== undefined) {\n      params_1.EvidenceParams.encode(message.evidence, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.validator !== undefined) {\n      params_1.ValidatorParams.encode(message.validator, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.version !== undefined) {\n      params_1.VersionParams.encode(message.version, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseConsensusParams);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.block = exports.BlockParams.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.evidence = params_1.EvidenceParams.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.validator = params_1.ValidatorParams.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.version = params_1.VersionParams.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseConsensusParams);\n    if (object.block !== undefined && object.block !== null) {\n      message.block = exports.BlockParams.fromJSON(object.block);\n    } else {\n      message.block = undefined;\n    }\n    if (object.evidence !== undefined && object.evidence !== null) {\n      message.evidence = params_1.EvidenceParams.fromJSON(object.evidence);\n    } else {\n      message.evidence = undefined;\n    }\n    if (object.validator !== undefined && object.validator !== null) {\n      message.validator = params_1.ValidatorParams.fromJSON(object.validator);\n    } else {\n      message.validator = undefined;\n    }\n    if (object.version !== undefined && object.version !== null) {\n      message.version = params_1.VersionParams.fromJSON(object.version);\n    } else {\n      message.version = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.block !== undefined && (obj.block = message.block ? exports.BlockParams.toJSON(message.block) : undefined);\n    message.evidence !== undefined && (obj.evidence = message.evidence ? params_1.EvidenceParams.toJSON(message.evidence) : undefined);\n    message.validator !== undefined && (obj.validator = message.validator ? params_1.ValidatorParams.toJSON(message.validator) : undefined);\n    message.version !== undefined && (obj.version = message.version ? params_1.VersionParams.toJSON(message.version) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseConsensusParams);\n    if (object.block !== undefined && object.block !== null) {\n      message.block = exports.BlockParams.fromPartial(object.block);\n    } else {\n      message.block = undefined;\n    }\n    if (object.evidence !== undefined && object.evidence !== null) {\n      message.evidence = params_1.EvidenceParams.fromPartial(object.evidence);\n    } else {\n      message.evidence = undefined;\n    }\n    if (object.validator !== undefined && object.validator !== null) {\n      message.validator = params_1.ValidatorParams.fromPartial(object.validator);\n    } else {\n      message.validator = undefined;\n    }\n    if (object.version !== undefined && object.version !== null) {\n      message.version = params_1.VersionParams.fromPartial(object.version);\n    } else {\n      message.version = undefined;\n    }\n    return message;\n  }\n};\nconst baseBlockParams = {\n  maxBytes: long_1.default.ZERO,\n  maxGas: long_1.default.ZERO\n};\nexports.BlockParams = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.maxBytes.isZero()) {\n      writer.uint32(8).int64(message.maxBytes);\n    }\n    if (!message.maxGas.isZero()) {\n      writer.uint32(16).int64(message.maxGas);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseBlockParams);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.maxBytes = reader.int64();\n          break;\n        case 2:\n          message.maxGas = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseBlockParams);\n    if (object.maxBytes !== undefined && object.maxBytes !== null) {\n      message.maxBytes = long_1.default.fromString(object.maxBytes);\n    } else {\n      message.maxBytes = long_1.default.ZERO;\n    }\n    if (object.maxGas !== undefined && object.maxGas !== null) {\n      message.maxGas = long_1.default.fromString(object.maxGas);\n    } else {\n      message.maxGas = long_1.default.ZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.maxBytes !== undefined && (obj.maxBytes = (message.maxBytes || long_1.default.ZERO).toString());\n    message.maxGas !== undefined && (obj.maxGas = (message.maxGas || long_1.default.ZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseBlockParams);\n    if (object.maxBytes !== undefined && object.maxBytes !== null) {\n      message.maxBytes = object.maxBytes;\n    } else {\n      message.maxBytes = long_1.default.ZERO;\n    }\n    if (object.maxGas !== undefined && object.maxGas !== null) {\n      message.maxGas = object.maxGas;\n    } else {\n      message.maxGas = long_1.default.ZERO;\n    }\n    return message;\n  }\n};\nconst baseLastCommitInfo = {\n  round: 0\n};\nexports.LastCommitInfo = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.round !== 0) {\n      writer.uint32(8).int32(message.round);\n    }\n    for (const v of message.votes) {\n      exports.VoteInfo.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseLastCommitInfo);\n    message.votes = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.round = reader.int32();\n          break;\n        case 2:\n          message.votes.push(exports.VoteInfo.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseLastCommitInfo);\n    message.votes = [];\n    if (object.round !== undefined && object.round !== null) {\n      message.round = Number(object.round);\n    } else {\n      message.round = 0;\n    }\n    if (object.votes !== undefined && object.votes !== null) {\n      for (const e of object.votes) {\n        message.votes.push(exports.VoteInfo.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.round !== undefined && (obj.round = message.round);\n    if (message.votes) {\n      obj.votes = message.votes.map(e => e ? exports.VoteInfo.toJSON(e) : undefined);\n    } else {\n      obj.votes = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseLastCommitInfo);\n    message.votes = [];\n    if (object.round !== undefined && object.round !== null) {\n      message.round = object.round;\n    } else {\n      message.round = 0;\n    }\n    if (object.votes !== undefined && object.votes !== null) {\n      for (const e of object.votes) {\n        message.votes.push(exports.VoteInfo.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseEvent = {\n  type: \"\"\n};\nexports.Event = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.type !== \"\") {\n      writer.uint32(10).string(message.type);\n    }\n    for (const v of message.attributes) {\n      exports.EventAttribute.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseEvent);\n    message.attributes = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.string();\n          break;\n        case 2:\n          message.attributes.push(exports.EventAttribute.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseEvent);\n    message.attributes = [];\n    if (object.type !== undefined && object.type !== null) {\n      message.type = String(object.type);\n    } else {\n      message.type = \"\";\n    }\n    if (object.attributes !== undefined && object.attributes !== null) {\n      for (const e of object.attributes) {\n        message.attributes.push(exports.EventAttribute.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.type !== undefined && (obj.type = message.type);\n    if (message.attributes) {\n      obj.attributes = message.attributes.map(e => e ? exports.EventAttribute.toJSON(e) : undefined);\n    } else {\n      obj.attributes = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseEvent);\n    message.attributes = [];\n    if (object.type !== undefined && object.type !== null) {\n      message.type = object.type;\n    } else {\n      message.type = \"\";\n    }\n    if (object.attributes !== undefined && object.attributes !== null) {\n      for (const e of object.attributes) {\n        message.attributes.push(exports.EventAttribute.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseEventAttribute = {\n  index: false\n};\nexports.EventAttribute = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.index === true) {\n      writer.uint32(24).bool(message.index);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseEventAttribute);\n    message.key = new Uint8Array();\n    message.value = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.index = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseEventAttribute);\n    message.key = new Uint8Array();\n    message.value = new Uint8Array();\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = bytesFromBase64(object.value);\n    }\n    if (object.index !== undefined && object.index !== null) {\n      message.index = Boolean(object.index);\n    } else {\n      message.index = false;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n    message.index !== undefined && (obj.index = message.index);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseEventAttribute);\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = object.value;\n    } else {\n      message.value = new Uint8Array();\n    }\n    if (object.index !== undefined && object.index !== null) {\n      message.index = object.index;\n    } else {\n      message.index = false;\n    }\n    return message;\n  }\n};\nconst baseTxResult = {\n  height: long_1.default.ZERO,\n  index: 0\n};\nexports.TxResult = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.height.isZero()) {\n      writer.uint32(8).int64(message.height);\n    }\n    if (message.index !== 0) {\n      writer.uint32(16).uint32(message.index);\n    }\n    if (message.tx.length !== 0) {\n      writer.uint32(26).bytes(message.tx);\n    }\n    if (message.result !== undefined) {\n      exports.ResponseDeliverTx.encode(message.result, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseTxResult);\n    message.tx = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.int64();\n          break;\n        case 2:\n          message.index = reader.uint32();\n          break;\n        case 3:\n          message.tx = reader.bytes();\n          break;\n        case 4:\n          message.result = exports.ResponseDeliverTx.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseTxResult);\n    message.tx = new Uint8Array();\n    if (object.height !== undefined && object.height !== null) {\n      message.height = long_1.default.fromString(object.height);\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    if (object.index !== undefined && object.index !== null) {\n      message.index = Number(object.index);\n    } else {\n      message.index = 0;\n    }\n    if (object.tx !== undefined && object.tx !== null) {\n      message.tx = bytesFromBase64(object.tx);\n    }\n    if (object.result !== undefined && object.result !== null) {\n      message.result = exports.ResponseDeliverTx.fromJSON(object.result);\n    } else {\n      message.result = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.height !== undefined && (obj.height = (message.height || long_1.default.ZERO).toString());\n    message.index !== undefined && (obj.index = message.index);\n    message.tx !== undefined && (obj.tx = base64FromBytes(message.tx !== undefined ? message.tx : new Uint8Array()));\n    message.result !== undefined && (obj.result = message.result ? exports.ResponseDeliverTx.toJSON(message.result) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseTxResult);\n    if (object.height !== undefined && object.height !== null) {\n      message.height = object.height;\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    if (object.index !== undefined && object.index !== null) {\n      message.index = object.index;\n    } else {\n      message.index = 0;\n    }\n    if (object.tx !== undefined && object.tx !== null) {\n      message.tx = object.tx;\n    } else {\n      message.tx = new Uint8Array();\n    }\n    if (object.result !== undefined && object.result !== null) {\n      message.result = exports.ResponseDeliverTx.fromPartial(object.result);\n    } else {\n      message.result = undefined;\n    }\n    return message;\n  }\n};\nconst baseValidator = {\n  power: long_1.default.ZERO\n};\nexports.Validator = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.address.length !== 0) {\n      writer.uint32(10).bytes(message.address);\n    }\n    if (!message.power.isZero()) {\n      writer.uint32(24).int64(message.power);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseValidator);\n    message.address = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.bytes();\n          break;\n        case 3:\n          message.power = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseValidator);\n    message.address = new Uint8Array();\n    if (object.address !== undefined && object.address !== null) {\n      message.address = bytesFromBase64(object.address);\n    }\n    if (object.power !== undefined && object.power !== null) {\n      message.power = long_1.default.fromString(object.power);\n    } else {\n      message.power = long_1.default.ZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.address !== undefined && (obj.address = base64FromBytes(message.address !== undefined ? message.address : new Uint8Array()));\n    message.power !== undefined && (obj.power = (message.power || long_1.default.ZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseValidator);\n    if (object.address !== undefined && object.address !== null) {\n      message.address = object.address;\n    } else {\n      message.address = new Uint8Array();\n    }\n    if (object.power !== undefined && object.power !== null) {\n      message.power = object.power;\n    } else {\n      message.power = long_1.default.ZERO;\n    }\n    return message;\n  }\n};\nconst baseValidatorUpdate = {\n  power: long_1.default.ZERO\n};\nexports.ValidatorUpdate = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.pubKey !== undefined) {\n      keys_1.PublicKey.encode(message.pubKey, writer.uint32(10).fork()).ldelim();\n    }\n    if (!message.power.isZero()) {\n      writer.uint32(16).int64(message.power);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseValidatorUpdate);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pubKey = keys_1.PublicKey.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.power = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseValidatorUpdate);\n    if (object.pubKey !== undefined && object.pubKey !== null) {\n      message.pubKey = keys_1.PublicKey.fromJSON(object.pubKey);\n    } else {\n      message.pubKey = undefined;\n    }\n    if (object.power !== undefined && object.power !== null) {\n      message.power = long_1.default.fromString(object.power);\n    } else {\n      message.power = long_1.default.ZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.pubKey !== undefined && (obj.pubKey = message.pubKey ? keys_1.PublicKey.toJSON(message.pubKey) : undefined);\n    message.power !== undefined && (obj.power = (message.power || long_1.default.ZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseValidatorUpdate);\n    if (object.pubKey !== undefined && object.pubKey !== null) {\n      message.pubKey = keys_1.PublicKey.fromPartial(object.pubKey);\n    } else {\n      message.pubKey = undefined;\n    }\n    if (object.power !== undefined && object.power !== null) {\n      message.power = object.power;\n    } else {\n      message.power = long_1.default.ZERO;\n    }\n    return message;\n  }\n};\nconst baseVoteInfo = {\n  signedLastBlock: false\n};\nexports.VoteInfo = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.validator !== undefined) {\n      exports.Validator.encode(message.validator, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.signedLastBlock === true) {\n      writer.uint32(16).bool(message.signedLastBlock);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseVoteInfo);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.validator = exports.Validator.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.signedLastBlock = reader.bool();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseVoteInfo);\n    if (object.validator !== undefined && object.validator !== null) {\n      message.validator = exports.Validator.fromJSON(object.validator);\n    } else {\n      message.validator = undefined;\n    }\n    if (object.signedLastBlock !== undefined && object.signedLastBlock !== null) {\n      message.signedLastBlock = Boolean(object.signedLastBlock);\n    } else {\n      message.signedLastBlock = false;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : undefined);\n    message.signedLastBlock !== undefined && (obj.signedLastBlock = message.signedLastBlock);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseVoteInfo);\n    if (object.validator !== undefined && object.validator !== null) {\n      message.validator = exports.Validator.fromPartial(object.validator);\n    } else {\n      message.validator = undefined;\n    }\n    if (object.signedLastBlock !== undefined && object.signedLastBlock !== null) {\n      message.signedLastBlock = object.signedLastBlock;\n    } else {\n      message.signedLastBlock = false;\n    }\n    return message;\n  }\n};\nconst baseEvidence = {\n  type: 0,\n  height: long_1.default.ZERO,\n  totalVotingPower: long_1.default.ZERO\n};\nexports.Evidence = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.type !== 0) {\n      writer.uint32(8).int32(message.type);\n    }\n    if (message.validator !== undefined) {\n      exports.Validator.encode(message.validator, writer.uint32(18).fork()).ldelim();\n    }\n    if (!message.height.isZero()) {\n      writer.uint32(24).int64(message.height);\n    }\n    if (message.time !== undefined) {\n      timestamp_1.Timestamp.encode(toTimestamp(message.time), writer.uint32(34).fork()).ldelim();\n    }\n    if (!message.totalVotingPower.isZero()) {\n      writer.uint32(40).int64(message.totalVotingPower);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseEvidence);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.type = reader.int32();\n          break;\n        case 2:\n          message.validator = exports.Validator.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.height = reader.int64();\n          break;\n        case 4:\n          message.time = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 5:\n          message.totalVotingPower = reader.int64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseEvidence);\n    if (object.type !== undefined && object.type !== null) {\n      message.type = evidenceTypeFromJSON(object.type);\n    } else {\n      message.type = 0;\n    }\n    if (object.validator !== undefined && object.validator !== null) {\n      message.validator = exports.Validator.fromJSON(object.validator);\n    } else {\n      message.validator = undefined;\n    }\n    if (object.height !== undefined && object.height !== null) {\n      message.height = long_1.default.fromString(object.height);\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    if (object.time !== undefined && object.time !== null) {\n      message.time = fromJsonTimestamp(object.time);\n    } else {\n      message.time = undefined;\n    }\n    if (object.totalVotingPower !== undefined && object.totalVotingPower !== null) {\n      message.totalVotingPower = long_1.default.fromString(object.totalVotingPower);\n    } else {\n      message.totalVotingPower = long_1.default.ZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.type !== undefined && (obj.type = evidenceTypeToJSON(message.type));\n    message.validator !== undefined && (obj.validator = message.validator ? exports.Validator.toJSON(message.validator) : undefined);\n    message.height !== undefined && (obj.height = (message.height || long_1.default.ZERO).toString());\n    message.time !== undefined && (obj.time = message.time.toISOString());\n    message.totalVotingPower !== undefined && (obj.totalVotingPower = (message.totalVotingPower || long_1.default.ZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseEvidence);\n    if (object.type !== undefined && object.type !== null) {\n      message.type = object.type;\n    } else {\n      message.type = 0;\n    }\n    if (object.validator !== undefined && object.validator !== null) {\n      message.validator = exports.Validator.fromPartial(object.validator);\n    } else {\n      message.validator = undefined;\n    }\n    if (object.height !== undefined && object.height !== null) {\n      message.height = object.height;\n    } else {\n      message.height = long_1.default.ZERO;\n    }\n    if (object.time !== undefined && object.time !== null) {\n      message.time = object.time;\n    } else {\n      message.time = undefined;\n    }\n    if (object.totalVotingPower !== undefined && object.totalVotingPower !== null) {\n      message.totalVotingPower = object.totalVotingPower;\n    } else {\n      message.totalVotingPower = long_1.default.ZERO;\n    }\n    return message;\n  }\n};\nconst baseSnapshot = {\n  height: long_1.default.UZERO,\n  format: 0,\n  chunks: 0\n};\nexports.Snapshot = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.height.isZero()) {\n      writer.uint32(8).uint64(message.height);\n    }\n    if (message.format !== 0) {\n      writer.uint32(16).uint32(message.format);\n    }\n    if (message.chunks !== 0) {\n      writer.uint32(24).uint32(message.chunks);\n    }\n    if (message.hash.length !== 0) {\n      writer.uint32(34).bytes(message.hash);\n    }\n    if (message.metadata.length !== 0) {\n      writer.uint32(42).bytes(message.metadata);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseSnapshot);\n    message.hash = new Uint8Array();\n    message.metadata = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = reader.uint64();\n          break;\n        case 2:\n          message.format = reader.uint32();\n          break;\n        case 3:\n          message.chunks = reader.uint32();\n          break;\n        case 4:\n          message.hash = reader.bytes();\n          break;\n        case 5:\n          message.metadata = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseSnapshot);\n    message.hash = new Uint8Array();\n    message.metadata = new Uint8Array();\n    if (object.height !== undefined && object.height !== null) {\n      message.height = long_1.default.fromString(object.height);\n    } else {\n      message.height = long_1.default.UZERO;\n    }\n    if (object.format !== undefined && object.format !== null) {\n      message.format = Number(object.format);\n    } else {\n      message.format = 0;\n    }\n    if (object.chunks !== undefined && object.chunks !== null) {\n      message.chunks = Number(object.chunks);\n    } else {\n      message.chunks = 0;\n    }\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = bytesFromBase64(object.hash);\n    }\n    if (object.metadata !== undefined && object.metadata !== null) {\n      message.metadata = bytesFromBase64(object.metadata);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.height !== undefined && (obj.height = (message.height || long_1.default.UZERO).toString());\n    message.format !== undefined && (obj.format = message.format);\n    message.chunks !== undefined && (obj.chunks = message.chunks);\n    message.hash !== undefined && (obj.hash = base64FromBytes(message.hash !== undefined ? message.hash : new Uint8Array()));\n    message.metadata !== undefined && (obj.metadata = base64FromBytes(message.metadata !== undefined ? message.metadata : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseSnapshot);\n    if (object.height !== undefined && object.height !== null) {\n      message.height = object.height;\n    } else {\n      message.height = long_1.default.UZERO;\n    }\n    if (object.format !== undefined && object.format !== null) {\n      message.format = object.format;\n    } else {\n      message.format = 0;\n    }\n    if (object.chunks !== undefined && object.chunks !== null) {\n      message.chunks = object.chunks;\n    } else {\n      message.chunks = 0;\n    }\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = new Uint8Array();\n    }\n    if (object.metadata !== undefined && object.metadata !== null) {\n      message.metadata = object.metadata;\n    } else {\n      message.metadata = new Uint8Array();\n    }\n    return message;\n  }\n};\nclass ABCIApplicationClientImpl {\n  constructor(rpc) {\n    this.rpc = rpc;\n    this.Echo = this.Echo.bind(this);\n    this.Flush = this.Flush.bind(this);\n    this.Info = this.Info.bind(this);\n    this.SetOption = this.SetOption.bind(this);\n    this.DeliverTx = this.DeliverTx.bind(this);\n    this.CheckTx = this.CheckTx.bind(this);\n    this.Query = this.Query.bind(this);\n    this.Commit = this.Commit.bind(this);\n    this.InitChain = this.InitChain.bind(this);\n    this.BeginBlock = this.BeginBlock.bind(this);\n    this.EndBlock = this.EndBlock.bind(this);\n    this.ListSnapshots = this.ListSnapshots.bind(this);\n    this.OfferSnapshot = this.OfferSnapshot.bind(this);\n    this.LoadSnapshotChunk = this.LoadSnapshotChunk.bind(this);\n    this.ApplySnapshotChunk = this.ApplySnapshotChunk.bind(this);\n  }\n  Echo(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationEchoDesc, exports.RequestEcho.fromPartial(request), metadata);\n  }\n  Flush(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationFlushDesc, exports.RequestFlush.fromPartial(request), metadata);\n  }\n  Info(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationInfoDesc, exports.RequestInfo.fromPartial(request), metadata);\n  }\n  SetOption(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationSetOptionDesc, exports.RequestSetOption.fromPartial(request), metadata);\n  }\n  DeliverTx(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationDeliverTxDesc, exports.RequestDeliverTx.fromPartial(request), metadata);\n  }\n  CheckTx(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationCheckTxDesc, exports.RequestCheckTx.fromPartial(request), metadata);\n  }\n  Query(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationQueryDesc, exports.RequestQuery.fromPartial(request), metadata);\n  }\n  Commit(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationCommitDesc, exports.RequestCommit.fromPartial(request), metadata);\n  }\n  InitChain(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationInitChainDesc, exports.RequestInitChain.fromPartial(request), metadata);\n  }\n  BeginBlock(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationBeginBlockDesc, exports.RequestBeginBlock.fromPartial(request), metadata);\n  }\n  EndBlock(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationEndBlockDesc, exports.RequestEndBlock.fromPartial(request), metadata);\n  }\n  ListSnapshots(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationListSnapshotsDesc, exports.RequestListSnapshots.fromPartial(request), metadata);\n  }\n  OfferSnapshot(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationOfferSnapshotDesc, exports.RequestOfferSnapshot.fromPartial(request), metadata);\n  }\n  LoadSnapshotChunk(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationLoadSnapshotChunkDesc, exports.RequestLoadSnapshotChunk.fromPartial(request), metadata);\n  }\n  ApplySnapshotChunk(request, metadata) {\n    return this.rpc.unary(exports.ABCIApplicationApplySnapshotChunkDesc, exports.RequestApplySnapshotChunk.fromPartial(request), metadata);\n  }\n}\nexports.ABCIApplicationClientImpl = ABCIApplicationClientImpl;\nexports.ABCIApplicationDesc = {\n  serviceName: \"tendermint.abci.ABCIApplication\"\n};\nexports.ABCIApplicationEchoDesc = {\n  methodName: \"Echo\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestEcho.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseEcho.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationFlushDesc = {\n  methodName: \"Flush\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestFlush.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseFlush.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationInfoDesc = {\n  methodName: \"Info\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestInfo.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseInfo.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationSetOptionDesc = {\n  methodName: \"SetOption\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestSetOption.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseSetOption.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationDeliverTxDesc = {\n  methodName: \"DeliverTx\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestDeliverTx.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseDeliverTx.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationCheckTxDesc = {\n  methodName: \"CheckTx\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestCheckTx.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseCheckTx.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationQueryDesc = {\n  methodName: \"Query\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestQuery.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseQuery.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationCommitDesc = {\n  methodName: \"Commit\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestCommit.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseCommit.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationInitChainDesc = {\n  methodName: \"InitChain\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestInitChain.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseInitChain.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationBeginBlockDesc = {\n  methodName: \"BeginBlock\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestBeginBlock.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseBeginBlock.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationEndBlockDesc = {\n  methodName: \"EndBlock\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestEndBlock.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseEndBlock.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationListSnapshotsDesc = {\n  methodName: \"ListSnapshots\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestListSnapshots.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseListSnapshots.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationOfferSnapshotDesc = {\n  methodName: \"OfferSnapshot\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestOfferSnapshot.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseOfferSnapshot.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationLoadSnapshotChunkDesc = {\n  methodName: \"LoadSnapshotChunk\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestLoadSnapshotChunk.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseLoadSnapshotChunk.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.ABCIApplicationApplySnapshotChunkDesc = {\n  methodName: \"ApplySnapshotChunk\",\n  service: exports.ABCIApplicationDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.RequestApplySnapshotChunk.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.ResponseApplySnapshotChunk.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nclass GrpcWebImpl {\n  constructor(host, options) {\n    this.host = host;\n    this.options = options;\n  }\n  unary(methodDesc, _request, metadata) {\n    var _a;\n    const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);\n    const maybeCombinedMetadata = metadata && this.options.metadata ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap)) : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc_web_1.grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc_web_1.grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage);\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        }\n      });\n    });\n  }\n}\nexports.GrpcWebImpl = GrpcWebImpl;\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nfunction toTimestamp(date) {\n  const seconds = numberToLong(date.getTime() / 1000);\n  const nanos = date.getTime() % 1000 * 1000000;\n  return {\n    seconds,\n    nanos\n  };\n}\nfunction fromTimestamp(t) {\n  let millis = t.seconds.toNumber() * 1000;\n  millis += t.nanos / 1000000;\n  return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));\n  }\n}\nfunction numberToLong(number) {\n  return long_1.default.fromNumber(number);\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=types.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}