{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.MsgClientImpl = exports.MsgClearContractAdminResponse = exports.MsgClearContractAdmin = exports.MsgUpdateContractAdminResponse = exports.MsgUpdateContractAdmin = exports.MsgMigrateContractResponse = exports.MsgMigrateContract = exports.MsgExecuteContractResponse = exports.MsgExecuteContract = exports.MsgInstantiateContractResponse = exports.MsgInstantiateContract = exports.MsgMigrateCodeResponse = exports.MsgMigrateCode = exports.MsgStoreCodeResponse = exports.MsgStoreCode = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst coin_1 = require(\"../../../cosmos/base/v1beta1/coin\");\nexports.protobufPackage = \"terra.wasm.v1beta1\";\nconst baseMsgStoreCode = {\n  sender: \"\"\n};\nexports.MsgStoreCode = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.wasmByteCode.length !== 0) {\n      writer.uint32(18).bytes(message.wasmByteCode);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgStoreCode);\n    message.wasmByteCode = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.wasmByteCode = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgStoreCode);\n    message.wasmByteCode = new Uint8Array();\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.wasmByteCode !== undefined && object.wasmByteCode !== null) {\n      message.wasmByteCode = bytesFromBase64(object.wasmByteCode);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.wasmByteCode !== undefined && (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== undefined ? message.wasmByteCode : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgStoreCode);\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.wasmByteCode !== undefined && object.wasmByteCode !== null) {\n      message.wasmByteCode = object.wasmByteCode;\n    } else {\n      message.wasmByteCode = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgStoreCodeResponse = {\n  codeId: long_1.default.UZERO\n};\nexports.MsgStoreCodeResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.codeId.isZero()) {\n      writer.uint32(8).uint64(message.codeId);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgStoreCodeResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.codeId = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgStoreCodeResponse);\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgStoreCodeResponse);\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nconst baseMsgMigrateCode = {\n  codeId: long_1.default.UZERO,\n  sender: \"\"\n};\nexports.MsgMigrateCode = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.codeId.isZero()) {\n      writer.uint32(8).uint64(message.codeId);\n    }\n    if (message.sender !== \"\") {\n      writer.uint32(18).string(message.sender);\n    }\n    if (message.wasmByteCode.length !== 0) {\n      writer.uint32(26).bytes(message.wasmByteCode);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgMigrateCode);\n    message.wasmByteCode = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.codeId = reader.uint64();\n          break;\n        case 2:\n          message.sender = reader.string();\n          break;\n        case 3:\n          message.wasmByteCode = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgMigrateCode);\n    message.wasmByteCode = new Uint8Array();\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.wasmByteCode !== undefined && object.wasmByteCode !== null) {\n      message.wasmByteCode = bytesFromBase64(object.wasmByteCode);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.wasmByteCode !== undefined && (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== undefined ? message.wasmByteCode : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgMigrateCode);\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.wasmByteCode !== undefined && object.wasmByteCode !== null) {\n      message.wasmByteCode = object.wasmByteCode;\n    } else {\n      message.wasmByteCode = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgMigrateCodeResponse = {};\nexports.MsgMigrateCodeResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgMigrateCodeResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgMigrateCodeResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgMigrateCodeResponse);\n    return message;\n  }\n};\nconst baseMsgInstantiateContract = {\n  sender: \"\",\n  admin: \"\",\n  codeId: long_1.default.UZERO\n};\nexports.MsgInstantiateContract = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.admin !== \"\") {\n      writer.uint32(18).string(message.admin);\n    }\n    if (!message.codeId.isZero()) {\n      writer.uint32(24).uint64(message.codeId);\n    }\n    if (message.initMsg.length !== 0) {\n      writer.uint32(34).bytes(message.initMsg);\n    }\n    for (const v of message.initCoins) {\n      coin_1.Coin.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgInstantiateContract);\n    message.initCoins = [];\n    message.initMsg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.admin = reader.string();\n          break;\n        case 3:\n          message.codeId = reader.uint64();\n          break;\n        case 4:\n          message.initMsg = reader.bytes();\n          break;\n        case 5:\n          message.initCoins.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgInstantiateContract);\n    message.initCoins = [];\n    message.initMsg = new Uint8Array();\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = String(object.admin);\n    } else {\n      message.admin = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.initMsg !== undefined && object.initMsg !== null) {\n      message.initMsg = bytesFromBase64(object.initMsg);\n    }\n    if (object.initCoins !== undefined && object.initCoins !== null) {\n      for (const e of object.initCoins) {\n        message.initCoins.push(coin_1.Coin.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.admin !== undefined && (obj.admin = message.admin);\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    message.initMsg !== undefined && (obj.initMsg = base64FromBytes(message.initMsg !== undefined ? message.initMsg : new Uint8Array()));\n    if (message.initCoins) {\n      obj.initCoins = message.initCoins.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.initCoins = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgInstantiateContract);\n    message.initCoins = [];\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = object.admin;\n    } else {\n      message.admin = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.initMsg !== undefined && object.initMsg !== null) {\n      message.initMsg = object.initMsg;\n    } else {\n      message.initMsg = new Uint8Array();\n    }\n    if (object.initCoins !== undefined && object.initCoins !== null) {\n      for (const e of object.initCoins) {\n        message.initCoins.push(coin_1.Coin.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseMsgInstantiateContractResponse = {\n  contractAddress: \"\"\n};\nexports.MsgInstantiateContractResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.contractAddress !== \"\") {\n      writer.uint32(10).string(message.contractAddress);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgInstantiateContractResponse);\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.contractAddress = reader.string();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgInstantiateContractResponse);\n    message.data = new Uint8Array();\n    if (object.contractAddress !== undefined && object.contractAddress !== null) {\n      message.contractAddress = String(object.contractAddress);\n    } else {\n      message.contractAddress = \"\";\n    }\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.contractAddress !== undefined && (obj.contractAddress = message.contractAddress);\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgInstantiateContractResponse);\n    if (object.contractAddress !== undefined && object.contractAddress !== null) {\n      message.contractAddress = object.contractAddress;\n    } else {\n      message.contractAddress = \"\";\n    }\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgExecuteContract = {\n  sender: \"\",\n  contract: \"\"\n};\nexports.MsgExecuteContract = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(18).string(message.contract);\n    }\n    if (message.executeMsg.length !== 0) {\n      writer.uint32(26).bytes(message.executeMsg);\n    }\n    for (const v of message.coins) {\n      coin_1.Coin.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgExecuteContract);\n    message.coins = [];\n    message.executeMsg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.contract = reader.string();\n          break;\n        case 3:\n          message.executeMsg = reader.bytes();\n          break;\n        case 5:\n          message.coins.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgExecuteContract);\n    message.coins = [];\n    message.executeMsg = new Uint8Array();\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    if (object.executeMsg !== undefined && object.executeMsg !== null) {\n      message.executeMsg = bytesFromBase64(object.executeMsg);\n    }\n    if (object.coins !== undefined && object.coins !== null) {\n      for (const e of object.coins) {\n        message.coins.push(coin_1.Coin.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.executeMsg !== undefined && (obj.executeMsg = base64FromBytes(message.executeMsg !== undefined ? message.executeMsg : new Uint8Array()));\n    if (message.coins) {\n      obj.coins = message.coins.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.coins = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgExecuteContract);\n    message.coins = [];\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    if (object.executeMsg !== undefined && object.executeMsg !== null) {\n      message.executeMsg = object.executeMsg;\n    } else {\n      message.executeMsg = new Uint8Array();\n    }\n    if (object.coins !== undefined && object.coins !== null) {\n      for (const e of object.coins) {\n        message.coins.push(coin_1.Coin.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseMsgExecuteContractResponse = {};\nexports.MsgExecuteContractResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.data.length !== 0) {\n      writer.uint32(10).bytes(message.data);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgExecuteContractResponse);\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgExecuteContractResponse);\n    message.data = new Uint8Array();\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgExecuteContractResponse);\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgMigrateContract = {\n  admin: \"\",\n  contract: \"\",\n  newCodeId: long_1.default.UZERO\n};\nexports.MsgMigrateContract = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.admin !== \"\") {\n      writer.uint32(10).string(message.admin);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(18).string(message.contract);\n    }\n    if (!message.newCodeId.isZero()) {\n      writer.uint32(24).uint64(message.newCodeId);\n    }\n    if (message.migrateMsg.length !== 0) {\n      writer.uint32(34).bytes(message.migrateMsg);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgMigrateContract);\n    message.migrateMsg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.admin = reader.string();\n          break;\n        case 2:\n          message.contract = reader.string();\n          break;\n        case 3:\n          message.newCodeId = reader.uint64();\n          break;\n        case 4:\n          message.migrateMsg = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgMigrateContract);\n    message.migrateMsg = new Uint8Array();\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = String(object.admin);\n    } else {\n      message.admin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    if (object.newCodeId !== undefined && object.newCodeId !== null) {\n      message.newCodeId = long_1.default.fromString(object.newCodeId);\n    } else {\n      message.newCodeId = long_1.default.UZERO;\n    }\n    if (object.migrateMsg !== undefined && object.migrateMsg !== null) {\n      message.migrateMsg = bytesFromBase64(object.migrateMsg);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.admin !== undefined && (obj.admin = message.admin);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.newCodeId !== undefined && (obj.newCodeId = (message.newCodeId || long_1.default.UZERO).toString());\n    message.migrateMsg !== undefined && (obj.migrateMsg = base64FromBytes(message.migrateMsg !== undefined ? message.migrateMsg : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgMigrateContract);\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = object.admin;\n    } else {\n      message.admin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    if (object.newCodeId !== undefined && object.newCodeId !== null) {\n      message.newCodeId = object.newCodeId;\n    } else {\n      message.newCodeId = long_1.default.UZERO;\n    }\n    if (object.migrateMsg !== undefined && object.migrateMsg !== null) {\n      message.migrateMsg = object.migrateMsg;\n    } else {\n      message.migrateMsg = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgMigrateContractResponse = {};\nexports.MsgMigrateContractResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.data.length !== 0) {\n      writer.uint32(10).bytes(message.data);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgMigrateContractResponse);\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgMigrateContractResponse);\n    message.data = new Uint8Array();\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgMigrateContractResponse);\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgUpdateContractAdmin = {\n  admin: \"\",\n  newAdmin: \"\",\n  contract: \"\"\n};\nexports.MsgUpdateContractAdmin = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.admin !== \"\") {\n      writer.uint32(10).string(message.admin);\n    }\n    if (message.newAdmin !== \"\") {\n      writer.uint32(18).string(message.newAdmin);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(26).string(message.contract);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgUpdateContractAdmin);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.admin = reader.string();\n          break;\n        case 2:\n          message.newAdmin = reader.string();\n          break;\n        case 3:\n          message.contract = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgUpdateContractAdmin);\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = String(object.admin);\n    } else {\n      message.admin = \"\";\n    }\n    if (object.newAdmin !== undefined && object.newAdmin !== null) {\n      message.newAdmin = String(object.newAdmin);\n    } else {\n      message.newAdmin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.admin !== undefined && (obj.admin = message.admin);\n    message.newAdmin !== undefined && (obj.newAdmin = message.newAdmin);\n    message.contract !== undefined && (obj.contract = message.contract);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgUpdateContractAdmin);\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = object.admin;\n    } else {\n      message.admin = \"\";\n    }\n    if (object.newAdmin !== undefined && object.newAdmin !== null) {\n      message.newAdmin = object.newAdmin;\n    } else {\n      message.newAdmin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgUpdateContractAdminResponse = {};\nexports.MsgUpdateContractAdminResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgUpdateContractAdminResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgUpdateContractAdminResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgUpdateContractAdminResponse);\n    return message;\n  }\n};\nconst baseMsgClearContractAdmin = {\n  admin: \"\",\n  contract: \"\"\n};\nexports.MsgClearContractAdmin = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.admin !== \"\") {\n      writer.uint32(10).string(message.admin);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(18).string(message.contract);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgClearContractAdmin);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.admin = reader.string();\n          break;\n        case 2:\n          message.contract = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgClearContractAdmin);\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = String(object.admin);\n    } else {\n      message.admin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.admin !== undefined && (obj.admin = message.admin);\n    message.contract !== undefined && (obj.contract = message.contract);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgClearContractAdmin);\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = object.admin;\n    } else {\n      message.admin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgClearContractAdminResponse = {};\nexports.MsgClearContractAdminResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgClearContractAdminResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgClearContractAdminResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgClearContractAdminResponse);\n    return message;\n  }\n};\nclass MsgClientImpl {\n  constructor(rpc) {\n    this.rpc = rpc;\n    this.StoreCode = this.StoreCode.bind(this);\n    this.MigrateCode = this.MigrateCode.bind(this);\n    this.InstantiateContract = this.InstantiateContract.bind(this);\n    this.ExecuteContract = this.ExecuteContract.bind(this);\n    this.MigrateContract = this.MigrateContract.bind(this);\n    this.UpdateContractAdmin = this.UpdateContractAdmin.bind(this);\n    this.ClearContractAdmin = this.ClearContractAdmin.bind(this);\n  }\n  StoreCode(request) {\n    const data = exports.MsgStoreCode.encode(request).finish();\n    const promise = this.rpc.request(\"terra.wasm.v1beta1.Msg\", \"StoreCode\", data);\n    return promise.then(data => exports.MsgStoreCodeResponse.decode(new minimal_1.default.Reader(data)));\n  }\n  MigrateCode(request) {\n    const data = exports.MsgMigrateCode.encode(request).finish();\n    const promise = this.rpc.request(\"terra.wasm.v1beta1.Msg\", \"MigrateCode\", data);\n    return promise.then(data => exports.MsgMigrateCodeResponse.decode(new minimal_1.default.Reader(data)));\n  }\n  InstantiateContract(request) {\n    const data = exports.MsgInstantiateContract.encode(request).finish();\n    const promise = this.rpc.request(\"terra.wasm.v1beta1.Msg\", \"InstantiateContract\", data);\n    return promise.then(data => exports.MsgInstantiateContractResponse.decode(new minimal_1.default.Reader(data)));\n  }\n  ExecuteContract(request) {\n    const data = exports.MsgExecuteContract.encode(request).finish();\n    const promise = this.rpc.request(\"terra.wasm.v1beta1.Msg\", \"ExecuteContract\", data);\n    return promise.then(data => exports.MsgExecuteContractResponse.decode(new minimal_1.default.Reader(data)));\n  }\n  MigrateContract(request) {\n    const data = exports.MsgMigrateContract.encode(request).finish();\n    const promise = this.rpc.request(\"terra.wasm.v1beta1.Msg\", \"MigrateContract\", data);\n    return promise.then(data => exports.MsgMigrateContractResponse.decode(new minimal_1.default.Reader(data)));\n  }\n  UpdateContractAdmin(request) {\n    const data = exports.MsgUpdateContractAdmin.encode(request).finish();\n    const promise = this.rpc.request(\"terra.wasm.v1beta1.Msg\", \"UpdateContractAdmin\", data);\n    return promise.then(data => exports.MsgUpdateContractAdminResponse.decode(new minimal_1.default.Reader(data)));\n  }\n  ClearContractAdmin(request) {\n    const data = exports.MsgClearContractAdmin.encode(request).finish();\n    const promise = this.rpc.request(\"terra.wasm.v1beta1.Msg\", \"ClearContractAdmin\", data);\n    return promise.then(data => exports.MsgClearContractAdminResponse.decode(new minimal_1.default.Reader(data)));\n  }\n}\nexports.MsgClientImpl = MsgClientImpl;\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=tx.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}