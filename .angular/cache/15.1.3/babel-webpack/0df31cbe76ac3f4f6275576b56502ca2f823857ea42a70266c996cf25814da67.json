{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.EpochInitialIssuance = exports.EpochTaxProceeds = exports.PolicyConstraints = exports.Params = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst coin_1 = require(\"../../../cosmos/base/v1beta1/coin\");\nexports.protobufPackage = \"terra.treasury.v1beta1\";\nconst baseParams = {\n  seigniorageBurdenTarget: \"\",\n  miningIncrement: \"\",\n  windowShort: long_1.default.UZERO,\n  windowLong: long_1.default.UZERO,\n  windowProbation: long_1.default.UZERO\n};\nexports.Params = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.taxPolicy !== undefined) {\n      exports.PolicyConstraints.encode(message.taxPolicy, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.rewardPolicy !== undefined) {\n      exports.PolicyConstraints.encode(message.rewardPolicy, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.seigniorageBurdenTarget !== \"\") {\n      writer.uint32(26).string(message.seigniorageBurdenTarget);\n    }\n    if (message.miningIncrement !== \"\") {\n      writer.uint32(34).string(message.miningIncrement);\n    }\n    if (!message.windowShort.isZero()) {\n      writer.uint32(40).uint64(message.windowShort);\n    }\n    if (!message.windowLong.isZero()) {\n      writer.uint32(48).uint64(message.windowLong);\n    }\n    if (!message.windowProbation.isZero()) {\n      writer.uint32(56).uint64(message.windowProbation);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseParams);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.taxPolicy = exports.PolicyConstraints.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.rewardPolicy = exports.PolicyConstraints.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.seigniorageBurdenTarget = reader.string();\n          break;\n        case 4:\n          message.miningIncrement = reader.string();\n          break;\n        case 5:\n          message.windowShort = reader.uint64();\n          break;\n        case 6:\n          message.windowLong = reader.uint64();\n          break;\n        case 7:\n          message.windowProbation = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseParams);\n    if (object.taxPolicy !== undefined && object.taxPolicy !== null) {\n      message.taxPolicy = exports.PolicyConstraints.fromJSON(object.taxPolicy);\n    } else {\n      message.taxPolicy = undefined;\n    }\n    if (object.rewardPolicy !== undefined && object.rewardPolicy !== null) {\n      message.rewardPolicy = exports.PolicyConstraints.fromJSON(object.rewardPolicy);\n    } else {\n      message.rewardPolicy = undefined;\n    }\n    if (object.seigniorageBurdenTarget !== undefined && object.seigniorageBurdenTarget !== null) {\n      message.seigniorageBurdenTarget = String(object.seigniorageBurdenTarget);\n    } else {\n      message.seigniorageBurdenTarget = \"\";\n    }\n    if (object.miningIncrement !== undefined && object.miningIncrement !== null) {\n      message.miningIncrement = String(object.miningIncrement);\n    } else {\n      message.miningIncrement = \"\";\n    }\n    if (object.windowShort !== undefined && object.windowShort !== null) {\n      message.windowShort = long_1.default.fromString(object.windowShort);\n    } else {\n      message.windowShort = long_1.default.UZERO;\n    }\n    if (object.windowLong !== undefined && object.windowLong !== null) {\n      message.windowLong = long_1.default.fromString(object.windowLong);\n    } else {\n      message.windowLong = long_1.default.UZERO;\n    }\n    if (object.windowProbation !== undefined && object.windowProbation !== null) {\n      message.windowProbation = long_1.default.fromString(object.windowProbation);\n    } else {\n      message.windowProbation = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.taxPolicy !== undefined && (obj.taxPolicy = message.taxPolicy ? exports.PolicyConstraints.toJSON(message.taxPolicy) : undefined);\n    message.rewardPolicy !== undefined && (obj.rewardPolicy = message.rewardPolicy ? exports.PolicyConstraints.toJSON(message.rewardPolicy) : undefined);\n    message.seigniorageBurdenTarget !== undefined && (obj.seigniorageBurdenTarget = message.seigniorageBurdenTarget);\n    message.miningIncrement !== undefined && (obj.miningIncrement = message.miningIncrement);\n    message.windowShort !== undefined && (obj.windowShort = (message.windowShort || long_1.default.UZERO).toString());\n    message.windowLong !== undefined && (obj.windowLong = (message.windowLong || long_1.default.UZERO).toString());\n    message.windowProbation !== undefined && (obj.windowProbation = (message.windowProbation || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseParams);\n    if (object.taxPolicy !== undefined && object.taxPolicy !== null) {\n      message.taxPolicy = exports.PolicyConstraints.fromPartial(object.taxPolicy);\n    } else {\n      message.taxPolicy = undefined;\n    }\n    if (object.rewardPolicy !== undefined && object.rewardPolicy !== null) {\n      message.rewardPolicy = exports.PolicyConstraints.fromPartial(object.rewardPolicy);\n    } else {\n      message.rewardPolicy = undefined;\n    }\n    if (object.seigniorageBurdenTarget !== undefined && object.seigniorageBurdenTarget !== null) {\n      message.seigniorageBurdenTarget = object.seigniorageBurdenTarget;\n    } else {\n      message.seigniorageBurdenTarget = \"\";\n    }\n    if (object.miningIncrement !== undefined && object.miningIncrement !== null) {\n      message.miningIncrement = object.miningIncrement;\n    } else {\n      message.miningIncrement = \"\";\n    }\n    if (object.windowShort !== undefined && object.windowShort !== null) {\n      message.windowShort = object.windowShort;\n    } else {\n      message.windowShort = long_1.default.UZERO;\n    }\n    if (object.windowLong !== undefined && object.windowLong !== null) {\n      message.windowLong = object.windowLong;\n    } else {\n      message.windowLong = long_1.default.UZERO;\n    }\n    if (object.windowProbation !== undefined && object.windowProbation !== null) {\n      message.windowProbation = object.windowProbation;\n    } else {\n      message.windowProbation = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nconst basePolicyConstraints = {\n  rateMin: \"\",\n  rateMax: \"\",\n  changeRateMax: \"\"\n};\nexports.PolicyConstraints = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.rateMin !== \"\") {\n      writer.uint32(10).string(message.rateMin);\n    }\n    if (message.rateMax !== \"\") {\n      writer.uint32(18).string(message.rateMax);\n    }\n    if (message.cap !== undefined) {\n      coin_1.Coin.encode(message.cap, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.changeRateMax !== \"\") {\n      writer.uint32(34).string(message.changeRateMax);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, basePolicyConstraints);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rateMin = reader.string();\n          break;\n        case 2:\n          message.rateMax = reader.string();\n          break;\n        case 3:\n          message.cap = coin_1.Coin.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.changeRateMax = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, basePolicyConstraints);\n    if (object.rateMin !== undefined && object.rateMin !== null) {\n      message.rateMin = String(object.rateMin);\n    } else {\n      message.rateMin = \"\";\n    }\n    if (object.rateMax !== undefined && object.rateMax !== null) {\n      message.rateMax = String(object.rateMax);\n    } else {\n      message.rateMax = \"\";\n    }\n    if (object.cap !== undefined && object.cap !== null) {\n      message.cap = coin_1.Coin.fromJSON(object.cap);\n    } else {\n      message.cap = undefined;\n    }\n    if (object.changeRateMax !== undefined && object.changeRateMax !== null) {\n      message.changeRateMax = String(object.changeRateMax);\n    } else {\n      message.changeRateMax = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.rateMin !== undefined && (obj.rateMin = message.rateMin);\n    message.rateMax !== undefined && (obj.rateMax = message.rateMax);\n    message.cap !== undefined && (obj.cap = message.cap ? coin_1.Coin.toJSON(message.cap) : undefined);\n    message.changeRateMax !== undefined && (obj.changeRateMax = message.changeRateMax);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, basePolicyConstraints);\n    if (object.rateMin !== undefined && object.rateMin !== null) {\n      message.rateMin = object.rateMin;\n    } else {\n      message.rateMin = \"\";\n    }\n    if (object.rateMax !== undefined && object.rateMax !== null) {\n      message.rateMax = object.rateMax;\n    } else {\n      message.rateMax = \"\";\n    }\n    if (object.cap !== undefined && object.cap !== null) {\n      message.cap = coin_1.Coin.fromPartial(object.cap);\n    } else {\n      message.cap = undefined;\n    }\n    if (object.changeRateMax !== undefined && object.changeRateMax !== null) {\n      message.changeRateMax = object.changeRateMax;\n    } else {\n      message.changeRateMax = \"\";\n    }\n    return message;\n  }\n};\nconst baseEpochTaxProceeds = {};\nexports.EpochTaxProceeds = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.taxProceeds) {\n      coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseEpochTaxProceeds);\n    message.taxProceeds = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.taxProceeds.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseEpochTaxProceeds);\n    message.taxProceeds = [];\n    if (object.taxProceeds !== undefined && object.taxProceeds !== null) {\n      for (const e of object.taxProceeds) {\n        message.taxProceeds.push(coin_1.Coin.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.taxProceeds) {\n      obj.taxProceeds = message.taxProceeds.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.taxProceeds = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseEpochTaxProceeds);\n    message.taxProceeds = [];\n    if (object.taxProceeds !== undefined && object.taxProceeds !== null) {\n      for (const e of object.taxProceeds) {\n        message.taxProceeds.push(coin_1.Coin.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseEpochInitialIssuance = {};\nexports.EpochInitialIssuance = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.issuance) {\n      coin_1.Coin.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseEpochInitialIssuance);\n    message.issuance = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.issuance.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseEpochInitialIssuance);\n    message.issuance = [];\n    if (object.issuance !== undefined && object.issuance !== null) {\n      for (const e of object.issuance) {\n        message.issuance.push(coin_1.Coin.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.issuance) {\n      obj.issuance = message.issuance.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.issuance = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseEpochInitialIssuance);\n    message.issuance = [];\n    if (object.issuance !== undefined && object.issuance !== null) {\n      for (const e of object.issuance) {\n        message.issuance.push(coin_1.Coin.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=treasury.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}