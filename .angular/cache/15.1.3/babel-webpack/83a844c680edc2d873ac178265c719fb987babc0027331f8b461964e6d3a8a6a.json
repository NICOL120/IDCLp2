{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.int = exports.dec = exports.Int = exports.Dec = exports.Numeric = exports.DEC_PRECISION = void 0;\nvar decimal_js_1 = __importDefault(require(\"decimal.js\"));\nexports.DEC_PRECISION = 18;\nvar Numeric;\n(function (Numeric) {\n  function parse(value) {\n    if (value instanceof Dec) {\n      return value;\n    } else if (typeof value === 'string') {\n      if (value.includes('.')) {\n        return new Dec(value);\n      } else {\n        return new Int(value);\n      }\n    } else {\n      var _value = new decimal_js_1.default(value);\n      if (_value.isInteger()) {\n        return new Int(_value);\n      } else {\n        return new Dec(_value.toString());\n      }\n    }\n  }\n  Numeric.parse = parse;\n})(Numeric = exports.Numeric || (exports.Numeric = {}));\n/**\n * Represents decimal values serialized with 18 digits of precision. This implementation\n * is based on the `decimal.js` library, and returns Dec values for only [[Dec.add]],\n * [[Dec.sub]], [[Dec.mul]], [[Dec.div]], and [[Dec.mod]]. For other methods inherited\n * from `Decimal`, you will need to convert back to `Dec` to remain compatible for\n * submitting information that requires `Dec` format back to the blockchain.\n *\n * Example:\n *\n * ```ts\n * const dec = new Dec(1.5);\n *\n * const decimal = dec.sqrt();\n * const dec2 = new Dec(decimal);\n */\nvar Dec = /** @class */function (_super) {\n  __extends(Dec, _super);\n  function Dec(arg) {\n    return _super.call(this, (arg !== null && arg !== void 0 ? arg : 0).toString()) || this;\n  }\n  Dec.prototype.toString = function () {\n    return this.toFixed(exports.DEC_PRECISION);\n  };\n  Dec.withPrec = function (value, prec) {\n    return new Dec(new Dec(value).div(Math.pow(10, prec)));\n  };\n  // type conversion\n  Dec.prototype.toInt = function () {\n    return new Int(this);\n  };\n  // arithmetic\n  Dec.prototype.add = function (other) {\n    var val = new Dec(Numeric.parse(other));\n    return new Dec(_super.prototype.add.call(this, val));\n  };\n  Dec.prototype.sub = function (other) {\n    var val = new Dec(Numeric.parse(other));\n    return new Dec(_super.prototype.sub.call(this, val));\n  };\n  Dec.prototype.mul = function (other) {\n    var val = new Dec(Numeric.parse(other));\n    return new Dec(_super.prototype.mul.call(this, val));\n  };\n  Dec.prototype.div = function (other) {\n    var val = new Dec(Numeric.parse(other));\n    return new Dec(_super.prototype.div.call(this, val));\n  };\n  Dec.prototype.mod = function (other) {\n    var val = new Dec(Numeric.parse(other));\n    return new Dec(_super.prototype.mod.call(this, val));\n  };\n  return Dec;\n}(decimal_js_1.default);\nexports.Dec = Dec;\nvar _Int = decimal_js_1.default.clone();\n/**\n * Represents Integer values. Used mainly to store integer values of [[Coin]] and [[Coins]].\n *\n * Note: Do not use to work with values greater than 9999999999999999999. This\n * implementation is based on the `decimal.js` library, and returns Int values for only\n * [[Int.add]], [[Int.sub]], [[Int.mul]], [[Int.div]], and [[Int.mod]]. For other\n * methods inherited from `Decimal`, you will need to convert back to `Int` to remain\n * compatible for submitting information that requires `Int` format back to the\n * blockchain.\n *\n * Example:\n *\n * ```ts\n * const int = new Int(1.5);\n *\n * const decimal = int.pow(3);\n * const int2 = new Int(decimal);\n */\nvar Int = /** @class */function (_super) {\n  __extends(Int, _super);\n  function Int(arg) {\n    var _arg = new decimal_js_1.default((arg !== null && arg !== void 0 ? arg : 0).toString());\n    return _super.call(this, _arg.divToInt(1)) || this;\n  }\n  Int.prototype.toString = function () {\n    return this.toFixed();\n  };\n  // type conversion\n  Int.prototype.toDec = function () {\n    return new Dec(this);\n  };\n  // artihmetic\n  Int.prototype.add = function (other) {\n    var val = Numeric.parse(other);\n    if (val instanceof Dec) {\n      return new Dec(this).add(val);\n    } else {\n      return new Int(this.plus(val));\n    }\n  };\n  Int.prototype.sub = function (other) {\n    var val = Numeric.parse(other);\n    if (val instanceof Dec) {\n      return new Dec(this).sub(val);\n    } else {\n      return new Int(this.minus(val));\n    }\n  };\n  Int.prototype.mul = function (other) {\n    var val = Numeric.parse(other);\n    if (val instanceof Dec) {\n      return new Dec(this).mul(val);\n    } else {\n      return new Int(this.times(val));\n    }\n  };\n  Int.prototype.div = function (other) {\n    var val = Numeric.parse(other);\n    if (val instanceof Dec) {\n      return new Dec(this).div(val);\n    } else {\n      return new Int(_super.prototype.div.call(this, val));\n    }\n  };\n  Int.prototype.mod = function (other) {\n    var val = Numeric.parse(other);\n    if (val instanceof Dec) {\n      return new Dec(this).mod(val);\n    } else {\n      return new Int(_super.prototype.mod.call(this, val));\n    }\n  };\n  return Int;\n}(_Int);\nexports.Int = Int;\n/**\n * Template tagged literal for creating new Dec objects out of literal string.\n * This does not support literal string interpolation  with `${}`.\n *\n * Usage is:\n *\n * ```ts\n * import { dec } from \"@terra-money/terra.js\";\n *\n * const dec1 = dec`234.12312`;\n * const dec2 = new Dec(\"234.12312\");\n *\n * dec1.equals(dec2);\n * ```\n * @param strings\n */\nfunction dec(strings) {\n  return new Dec(strings[0]);\n}\nexports.dec = dec;\n/**\n * Template tagged literal for creating new Int objects out of literal string.\n * This does not support literal string interpolation  with `${}`.\n *\n * Usage is:\n *\n * ```ts\n * import { int } from \"@terra-money/terra.js\";\n *\n * const int1 = int`234`;\n * const int2 = new Int(\"234\");\n *\n * int1.equals(int2);\n * ```\n * @param strings\n */\nfunction int(strings) {\n  return new Int(strings[0]);\n}\nexports.int = int;\n//# sourceMappingURL=numeric.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}