{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\nimport { TaskExec } from '../common/tesk-exec/task-exec';\nimport { SimpleRateLimitCounter } from './simple-rate-limit-counter';\nfunction handleAsyncRateLimit(target, resolvedConfig, key, taskExec, originalMethod, args) {\n  return __awaiter(this, void 0, void 0, function* () {\n    const rateLimitCounter = resolvedConfig.rateLimitAsyncCounter;\n    const currentCount = yield rateLimitCounter.getCount(key);\n    if (currentCount >= resolvedConfig.allowedCalls) {\n      resolvedConfig.exceedHandler();\n    }\n    yield rateLimitCounter.inc(key);\n    taskExec.exec(() => {\n      rateLimitCounter.dec(key);\n    }, resolvedConfig.timeSpanMs);\n    return originalMethod.apply(target, args);\n  });\n}\nfunction handleRateLimit(target, resolvedConfig, key, taskExec, originalMethod, args) {\n  const {\n    rateLimitCounter\n  } = resolvedConfig;\n  const currentCount = rateLimitCounter.getCount(key);\n  if (currentCount >= resolvedConfig.allowedCalls) {\n    resolvedConfig.exceedHandler();\n  }\n  rateLimitCounter.inc(key);\n  taskExec.exec(() => {\n    rateLimitCounter.dec(key);\n  }, resolvedConfig.timeSpanMs);\n  return originalMethod.apply(target, args);\n}\nexport function rateLimitify(originalMethod, config) {\n  if (config.rateLimitAsyncCounter && config.rateLimitCounter) {\n    throw new Error('You cant provide both rateLimitAsyncCounter and rateLimitCounter.');\n  }\n  const taskExec = new TaskExec();\n  const resolvedConfig = Object.assign({\n    rateLimitCounter: new SimpleRateLimitCounter(),\n    exceedHandler: () => {\n      throw new Error('You have acceded the amount of allowed calls');\n    },\n    keyResolver: () => '__rateLimit__'\n  }, config);\n  return function (...args) {\n    const keyResolver = typeof resolvedConfig.keyResolver === 'string' ? this[resolvedConfig.keyResolver] : resolvedConfig.keyResolver.bind(this);\n    const key = keyResolver(...args);\n    if (resolvedConfig.rateLimitAsyncCounter) {\n      return handleAsyncRateLimit(this, resolvedConfig, key, taskExec, originalMethod, args);\n    }\n    return handleRateLimit(this, resolvedConfig, key, taskExec, originalMethod, args);\n  };\n}\n//# sourceMappingURL=rate-limitify.js.map","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}