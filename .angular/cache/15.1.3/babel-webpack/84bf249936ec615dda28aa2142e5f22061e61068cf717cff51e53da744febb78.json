{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Channel = void 0;\nvar channel_1 = require(\"@terra-money/terra.proto/ibc/core/channel/v1/channel\");\nvar json_1 = require(\"../../../../util/json\");\nvar Counterparty_1 = require(\"./Counterparty\");\n/**\n * Channel is a monotonically increasing data type\n * that can be compared against another Channel for the purposes of updating and\n * freezing clients\n *\n * Normally the RevisionChannel is incremented at each height while keeping\n * RevisionNumber the same. However some consensus algorithms may choose to\n * reset the height in certain conditions e.g. hard forks, state-machine\n * breaking changes In these cases, the RevisionNumber is incremented so that\n * height continues to be monitonically increasing even as the RevisionChannel\n * gets reset\n */\nvar Channel = /** @class */function (_super) {\n  __extends(Channel, _super);\n  /**\n   * @param state current state of the channel end\n   * @param ordering  whether the channel is ordered or unordered\n   * @param counterparty counterparty channel end\n   * @param connection_hops list of connection identifiers, in order, along which packets sent on this channel will travel\n   * @param version opaque channel version, which is agreed upon during the handshake\n   */\n  function Channel(state, ordering, counterparty, connection_hops, version) {\n    var _this = _super.call(this) || this;\n    _this.state = state;\n    _this.ordering = ordering;\n    _this.counterparty = counterparty;\n    _this.connection_hops = connection_hops;\n    _this.version = version;\n    return _this;\n  }\n  Channel.fromAmino = function (data) {\n    var state = data.state,\n      ordering = data.ordering,\n      counterparty = data.counterparty,\n      connection_hops = data.connection_hops,\n      version = data.version;\n    return new Channel(state, ordering, counterparty ? Counterparty_1.Counterparty.fromAmino(counterparty) : undefined, connection_hops, version);\n  };\n  Channel.prototype.toAmino = function () {\n    var _a = this,\n      state = _a.state,\n      ordering = _a.ordering,\n      counterparty = _a.counterparty,\n      connection_hops = _a.connection_hops,\n      version = _a.version;\n    var res = {\n      state: state,\n      ordering: ordering,\n      counterparty: counterparty ? counterparty.toAmino() : undefined,\n      connection_hops: connection_hops,\n      version: version\n    };\n    return res;\n  };\n  Channel.fromData = function (data) {\n    var state = data.state,\n      ordering = data.ordering,\n      counterparty = data.counterparty,\n      connection_hops = data.connection_hops,\n      version = data.version;\n    return new Channel(state, ordering, counterparty ? Counterparty_1.Counterparty.fromData(counterparty) : undefined, connection_hops, version);\n  };\n  Channel.prototype.toData = function () {\n    var _a = this,\n      state = _a.state,\n      ordering = _a.ordering,\n      counterparty = _a.counterparty,\n      connection_hops = _a.connection_hops,\n      version = _a.version;\n    var res = {\n      state: state,\n      ordering: ordering,\n      counterparty: counterparty ? counterparty.toData() : undefined,\n      connection_hops: connection_hops,\n      version: version\n    };\n    return res;\n  };\n  Channel.fromProto = function (proto) {\n    return new Channel(proto.state, proto.ordering, proto.counterparty ? Counterparty_1.Counterparty.fromProto(proto.counterparty) : undefined, proto.connectionHops, proto.version);\n  };\n  Channel.prototype.toProto = function () {\n    var _a = this,\n      state = _a.state,\n      ordering = _a.ordering,\n      counterparty = _a.counterparty,\n      connection_hops = _a.connection_hops,\n      version = _a.version;\n    return channel_1.Channel.fromPartial({\n      state: state,\n      ordering: ordering,\n      counterparty: counterparty ? counterparty.toProto() : undefined,\n      connectionHops: connection_hops,\n      version: version\n    });\n  };\n  return Channel;\n}(json_1.JSONSerializable);\nexports.Channel = Channel;\n//# sourceMappingURL=Channel.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}