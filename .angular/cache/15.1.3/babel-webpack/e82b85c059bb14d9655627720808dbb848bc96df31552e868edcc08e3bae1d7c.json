{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompactBitArray = void 0;\nvar multisig_1 = require(\"@terra-money/terra.proto/cosmos/crypto/multisig/v1beta1/multisig\");\nvar CompactBitArray = /** @class */function () {\n  function CompactBitArray(extra_bits_stored, elems) {\n    this.extra_bits_stored = extra_bits_stored;\n    this.elems = elems;\n  }\n  CompactBitArray.fromBits = function (bits) {\n    if (bits <= 0) {\n      throw new Error('CompactBitArray bits must be bigger than 0');\n    }\n    var num_elems = (bits + 7) / 8;\n    if (num_elems <= 0 || num_elems > Math.pow(2, 32) - 1) {\n      // We encountered an overflow here, and shouldn't pass negatives\n      // to make, nor should we allow unreasonable limits > maxint32.\n      // See https://github.com/cosmos/cosmos-sdk/issues/9162\n      throw new Error('CompactBitArray overflow');\n    }\n    return new CompactBitArray(bits % 8, Buffer.alloc(num_elems));\n  };\n  // returns the number of bits in the bitarray\n  CompactBitArray.prototype.count = function () {\n    if (this.extra_bits_stored == 0) {\n      return this.elems.length * 8;\n    }\n    return (this.elems.length - 1) * 8 + this.extra_bits_stored;\n  };\n  // returns true if the bit at index i is set; returns false otherwise.\n  // The behavior is undefined if i >= bA.Count()\n  CompactBitArray.prototype.getIndex = function (i) {\n    if (i < 0 || i >= this.count()) {\n      return false;\n    }\n    return (this.elems.readUInt8(i >> 3) & 1 << 7 - i % 8) > 0;\n  };\n  // sets the bit at index i within the bit array. Returns true if and only if the\n  // operation succeeded. The behavior is undefined if i >= bA.Count()\n  CompactBitArray.prototype.setIndex = function (i, v) {\n    if (i < 0 || i >= this.count()) {\n      return false;\n    }\n    if (v) {\n      this.elems[i >> 3] |= 1 << 7 - i % 8;\n    } else {\n      this.elems[i >> 3] &= ~(1 << 7 - i % 8);\n    }\n    return true;\n  };\n  // returns the number of bits set to true before the\n  // given index. e.g. if bA = _XX__XX, NumOfTrueBitsBefore(4) = 2, since\n  // there are two bits set to true before index 4.\n  CompactBitArray.prototype.numTrueBitsBefore = function (index) {\n    var countOneBits = function (n) {\n      return n.toString(2).split('0').join('').length;\n    };\n    var ones_count = 0;\n    var max = this.count();\n    if (index > max) {\n      index = max;\n    }\n    // below we iterate over the bytes then over bits (in low endian) and count bits set to 1\n    for (var elem = 0;; elem++) {\n      if (elem * 8 + 7 >= index) {\n        ones_count += countOneBits(this.elems[elem] >> 7 - index % 8 + 1);\n        return ones_count;\n      }\n      ones_count += countOneBits(this.elems[elem]);\n    }\n  };\n  CompactBitArray.fromData = function (data) {\n    return new CompactBitArray(data.extra_bits_stored, Buffer.from(data.elems, 'base64'));\n  };\n  CompactBitArray.prototype.toData = function () {\n    return {\n      elems: this.elems.toString('base64'),\n      extra_bits_stored: this.extra_bits_stored\n    };\n  };\n  CompactBitArray.fromProto = function (proto) {\n    return new CompactBitArray(proto.extraBitsStored, Buffer.from(proto.elems));\n  };\n  CompactBitArray.prototype.toProto = function () {\n    return multisig_1.CompactBitArray.fromPartial({\n      elems: this.elems,\n      extraBitsStored: this.extra_bits_stored\n    });\n  };\n  return CompactBitArray;\n}();\nexports.CompactBitArray = CompactBitArray;\n//# sourceMappingURL=CompactBitArray.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}