{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Params = exports.Height = exports.UpgradeProposal = exports.ClientUpdateProposal = exports.ClientConsensusStates = exports.ConsensusStateWithHeight = exports.IdentifiedClientState = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst any_1 = require(\"../../../../google/protobuf/any\");\nconst upgrade_1 = require(\"../../../../cosmos/upgrade/v1beta1/upgrade\");\nexports.protobufPackage = \"ibc.core.client.v1\";\nconst baseIdentifiedClientState = {\n  clientId: \"\"\n};\nexports.IdentifiedClientState = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    if (message.clientState !== undefined) {\n      any_1.Any.encode(message.clientState, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseIdentifiedClientState);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.clientState = any_1.Any.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseIdentifiedClientState);\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromJSON(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    message.clientState !== undefined && (obj.clientState = message.clientState ? any_1.Any.toJSON(message.clientState) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseIdentifiedClientState);\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.clientState !== undefined && object.clientState !== null) {\n      message.clientState = any_1.Any.fromPartial(object.clientState);\n    } else {\n      message.clientState = undefined;\n    }\n    return message;\n  }\n};\nconst baseConsensusStateWithHeight = {};\nexports.ConsensusStateWithHeight = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.height !== undefined) {\n      exports.Height.encode(message.height, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.consensusState !== undefined) {\n      any_1.Any.encode(message.consensusState, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseConsensusStateWithHeight);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.height = exports.Height.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.consensusState = any_1.Any.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseConsensusStateWithHeight);\n    if (object.height !== undefined && object.height !== null) {\n      message.height = exports.Height.fromJSON(object.height);\n    } else {\n      message.height = undefined;\n    }\n    if (object.consensusState !== undefined && object.consensusState !== null) {\n      message.consensusState = any_1.Any.fromJSON(object.consensusState);\n    } else {\n      message.consensusState = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.height !== undefined && (obj.height = message.height ? exports.Height.toJSON(message.height) : undefined);\n    message.consensusState !== undefined && (obj.consensusState = message.consensusState ? any_1.Any.toJSON(message.consensusState) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseConsensusStateWithHeight);\n    if (object.height !== undefined && object.height !== null) {\n      message.height = exports.Height.fromPartial(object.height);\n    } else {\n      message.height = undefined;\n    }\n    if (object.consensusState !== undefined && object.consensusState !== null) {\n      message.consensusState = any_1.Any.fromPartial(object.consensusState);\n    } else {\n      message.consensusState = undefined;\n    }\n    return message;\n  }\n};\nconst baseClientConsensusStates = {\n  clientId: \"\"\n};\nexports.ClientConsensusStates = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    for (const v of message.consensusStates) {\n      exports.ConsensusStateWithHeight.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseClientConsensusStates);\n    message.consensusStates = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.consensusStates.push(exports.ConsensusStateWithHeight.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseClientConsensusStates);\n    message.consensusStates = [];\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.consensusStates !== undefined && object.consensusStates !== null) {\n      for (const e of object.consensusStates) {\n        message.consensusStates.push(exports.ConsensusStateWithHeight.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    if (message.consensusStates) {\n      obj.consensusStates = message.consensusStates.map(e => e ? exports.ConsensusStateWithHeight.toJSON(e) : undefined);\n    } else {\n      obj.consensusStates = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseClientConsensusStates);\n    message.consensusStates = [];\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.consensusStates !== undefined && object.consensusStates !== null) {\n      for (const e of object.consensusStates) {\n        message.consensusStates.push(exports.ConsensusStateWithHeight.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseClientUpdateProposal = {\n  title: \"\",\n  description: \"\",\n  subjectClientId: \"\",\n  substituteClientId: \"\"\n};\nexports.ClientUpdateProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.subjectClientId !== \"\") {\n      writer.uint32(26).string(message.subjectClientId);\n    }\n    if (message.substituteClientId !== \"\") {\n      writer.uint32(34).string(message.substituteClientId);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseClientUpdateProposal);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.subjectClientId = reader.string();\n          break;\n        case 4:\n          message.substituteClientId = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseClientUpdateProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.subjectClientId !== undefined && object.subjectClientId !== null) {\n      message.subjectClientId = String(object.subjectClientId);\n    } else {\n      message.subjectClientId = \"\";\n    }\n    if (object.substituteClientId !== undefined && object.substituteClientId !== null) {\n      message.substituteClientId = String(object.substituteClientId);\n    } else {\n      message.substituteClientId = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.subjectClientId !== undefined && (obj.subjectClientId = message.subjectClientId);\n    message.substituteClientId !== undefined && (obj.substituteClientId = message.substituteClientId);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseClientUpdateProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.subjectClientId !== undefined && object.subjectClientId !== null) {\n      message.subjectClientId = object.subjectClientId;\n    } else {\n      message.subjectClientId = \"\";\n    }\n    if (object.substituteClientId !== undefined && object.substituteClientId !== null) {\n      message.substituteClientId = object.substituteClientId;\n    } else {\n      message.substituteClientId = \"\";\n    }\n    return message;\n  }\n};\nconst baseUpgradeProposal = {\n  title: \"\",\n  description: \"\"\n};\nexports.UpgradeProposal = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.title !== \"\") {\n      writer.uint32(10).string(message.title);\n    }\n    if (message.description !== \"\") {\n      writer.uint32(18).string(message.description);\n    }\n    if (message.plan !== undefined) {\n      upgrade_1.Plan.encode(message.plan, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.upgradedClientState !== undefined) {\n      any_1.Any.encode(message.upgradedClientState, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseUpgradeProposal);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.title = reader.string();\n          break;\n        case 2:\n          message.description = reader.string();\n          break;\n        case 3:\n          message.plan = upgrade_1.Plan.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.upgradedClientState = any_1.Any.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseUpgradeProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = String(object.title);\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = String(object.description);\n    } else {\n      message.description = \"\";\n    }\n    if (object.plan !== undefined && object.plan !== null) {\n      message.plan = upgrade_1.Plan.fromJSON(object.plan);\n    } else {\n      message.plan = undefined;\n    }\n    if (object.upgradedClientState !== undefined && object.upgradedClientState !== null) {\n      message.upgradedClientState = any_1.Any.fromJSON(object.upgradedClientState);\n    } else {\n      message.upgradedClientState = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.title !== undefined && (obj.title = message.title);\n    message.description !== undefined && (obj.description = message.description);\n    message.plan !== undefined && (obj.plan = message.plan ? upgrade_1.Plan.toJSON(message.plan) : undefined);\n    message.upgradedClientState !== undefined && (obj.upgradedClientState = message.upgradedClientState ? any_1.Any.toJSON(message.upgradedClientState) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseUpgradeProposal);\n    if (object.title !== undefined && object.title !== null) {\n      message.title = object.title;\n    } else {\n      message.title = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = object.description;\n    } else {\n      message.description = \"\";\n    }\n    if (object.plan !== undefined && object.plan !== null) {\n      message.plan = upgrade_1.Plan.fromPartial(object.plan);\n    } else {\n      message.plan = undefined;\n    }\n    if (object.upgradedClientState !== undefined && object.upgradedClientState !== null) {\n      message.upgradedClientState = any_1.Any.fromPartial(object.upgradedClientState);\n    } else {\n      message.upgradedClientState = undefined;\n    }\n    return message;\n  }\n};\nconst baseHeight = {\n  revisionNumber: long_1.default.UZERO,\n  revisionHeight: long_1.default.UZERO\n};\nexports.Height = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.revisionNumber.isZero()) {\n      writer.uint32(8).uint64(message.revisionNumber);\n    }\n    if (!message.revisionHeight.isZero()) {\n      writer.uint32(16).uint64(message.revisionHeight);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseHeight);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.revisionNumber = reader.uint64();\n          break;\n        case 2:\n          message.revisionHeight = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseHeight);\n    if (object.revisionNumber !== undefined && object.revisionNumber !== null) {\n      message.revisionNumber = long_1.default.fromString(object.revisionNumber);\n    } else {\n      message.revisionNumber = long_1.default.UZERO;\n    }\n    if (object.revisionHeight !== undefined && object.revisionHeight !== null) {\n      message.revisionHeight = long_1.default.fromString(object.revisionHeight);\n    } else {\n      message.revisionHeight = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.revisionNumber !== undefined && (obj.revisionNumber = (message.revisionNumber || long_1.default.UZERO).toString());\n    message.revisionHeight !== undefined && (obj.revisionHeight = (message.revisionHeight || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseHeight);\n    if (object.revisionNumber !== undefined && object.revisionNumber !== null) {\n      message.revisionNumber = object.revisionNumber;\n    } else {\n      message.revisionNumber = long_1.default.UZERO;\n    }\n    if (object.revisionHeight !== undefined && object.revisionHeight !== null) {\n      message.revisionHeight = object.revisionHeight;\n    } else {\n      message.revisionHeight = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nconst baseParams = {\n  allowedClients: \"\"\n};\nexports.Params = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.allowedClients) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseParams);\n    message.allowedClients = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.allowedClients.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseParams);\n    message.allowedClients = [];\n    if (object.allowedClients !== undefined && object.allowedClients !== null) {\n      for (const e of object.allowedClients) {\n        message.allowedClients.push(String(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.allowedClients) {\n      obj.allowedClients = message.allowedClients.map(e => e);\n    } else {\n      obj.allowedClients = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseParams);\n    message.allowedClients = [];\n    if (object.allowedClients !== undefined && object.allowedClients !== null) {\n      for (const e of object.allowedClients) {\n        message.allowedClients.push(e);\n      }\n    }\n    return message;\n  }\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=client.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}