{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { LCDClient } from '@terra-money/terra.js';\nimport { networks } from '../consts/networks';\nimport { BehaviorSubject, firstValueFrom, interval, Subject } from 'rxjs';\nimport { filter, startWith } from 'rxjs/operators';\nimport { getChainOptions, WalletController, WalletStatus } from '@terra-money/wallet-provider';\nimport { throttleAsync } from 'utils-decorators';\nimport BigNumber from 'bignumber.js';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"@angular/common/http\";\nimport * as i2 from \"./modal.service\";\nimport * as i3 from \"mdb-angular-ui-kit/modal\";\nexport const BLOCK_TIME = 6500; // 6.5s\nexport const DEFAULT_NETWORK = 'mainnet';\nexport class TerrajsService {\n  constructor(httpClient, modal, modalService) {\n    this.httpClient = httpClient;\n    this.modal = modal;\n    this.modalService = modalService;\n    this.connected = new BehaviorSubject(false);\n    this.settings = networks[DEFAULT_NETWORK];\n    this.networkName = DEFAULT_NETWORK;\n    this.heightChanged = interval(BLOCK_TIME).pipe(startWith(0));\n    this.USE_NEW_BASE64_API = true; // useful for development and debug\n    this.transactionComplete = new Subject();\n    this.height = 0;\n    this.posting = false;\n    this.isReadOnly = false;\n    getChainOptions().then(chainOptions => {\n      this.walletController = new WalletController({\n        defaultNetwork: chainOptions.defaultNetwork,\n        walletConnectChainIds: chainOptions.walletConnectChainIds,\n        connectorOpts: {\n          bridge: 'https://walletconnect.terra.dev/'\n        },\n        waitingChromeExtensionInstallCheck: 1000\n      });\n    });\n    this.subscription = this.heightChanged.subscribe(() => this.height++);\n  }\n  get isMainnet() {\n    return this.networkName === 'mainnet';\n  }\n  ngOnDestroy() {\n    this.subscription.unsubscribe();\n  }\n  checkInstalled() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const types = yield firstValueFrom((yield this.getWalletController()).availableInstallTypes());\n      return types.length === 0;\n    });\n  }\n  getConnectTypes() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const types = firstValueFrom((yield this.getWalletController()).availableConnectTypes());\n      return (yield types).filter(t => t !== 'READONLY');\n    });\n  }\n  getHeight(force) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.height <= 1 || force || this.USE_NEW_BASE64_API) {\n        // first time getHeight\n        if (!this.lcdClient) {\n          yield this.initLcdClient();\n        }\n        if (!this.height || !this.latestBlockRefreshTime || this.latestBlockRefreshTime + BLOCK_TIME < Date.now() || force) {\n          const blockInfo = yield this.lcdClient.tendermint.blockInfo();\n          this.height = +blockInfo.block.header.height;\n          this.latestBlockRefreshTime = Date.now();\n        }\n      }\n      return this.height;\n    });\n  }\n  initLcdClient() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const gasPrices = yield firstValueFrom(this.httpClient.get(`${this.settings.fcd}/v1/txs/gas_prices`));\n      this.lcdClient = new LCDClient({\n        URL: this.settings.lcd,\n        chainID: this.settings.chainID,\n        gasPrices\n      });\n    });\n  }\n  connect(auto) {\n    return __awaiter(this, void 0, void 0, function* () {\n      let connectCallbackData;\n      if (this.isConnected) {\n        return;\n      }\n      let terra_extension_router_session;\n      const connectTypes = yield this.getConnectTypes();\n      if (auto) {\n        // AUTO CONNECT AFTER APP INIT\n        const terra_extension_router_session_raw = localStorage.getItem('__terra_extension_router_session__');\n        const connect = localStorage.getItem('connect');\n        if (!connect) {\n          return;\n        }\n        if (connect === 'WALLETCONNECT') {\n          connectCallbackData = {\n            type: connect,\n            identifier: null\n          };\n        } else if (connect === 'READONLY_CUSTOM_IMP') {\n          const viewonly_state_raw = localStorage.getItem('readonly_state');\n          connectCallbackData = {\n            stateReadOnly: JSON.parse(viewonly_state_raw),\n            type: connect\n          };\n          this.isReadOnly = true;\n          yield this.finalConnectStep(connectCallbackData.stateReadOnly, connectCallbackData.type);\n        } else {\n          terra_extension_router_session = JSON.parse(terra_extension_router_session_raw);\n          connectCallbackData = terra_extension_router_session;\n          connectCallbackData.type = connect;\n        }\n      } else {\n        // CLICK CONNECT\n        const installTypes = yield firstValueFrom(this.walletController.availableInstallTypes());\n        const types = connectTypes.concat(installTypes);\n        const modal = yield import('./connect-options/connect-options.component');\n        const ref = this.modalService.open(modal.ConnectOptionsComponent, {\n          data: {\n            types\n          }\n        });\n        connectCallbackData = yield firstValueFrom(ref.onClose);\n        if (!(connectCallbackData === null || connectCallbackData === void 0 ? void 0 : connectCallbackData.type)) {\n          throw new Error('Nothing selected');\n        }\n        if (connectCallbackData.type === 'READONLY_CUSTOM_IMP' && connectCallbackData.stateReadOnly) {\n          this.isReadOnly = true;\n          yield this.finalConnectStep(connectCallbackData.stateReadOnly, connectCallbackData.type);\n          return;\n        }\n      }\n      // STEP 2\n      if (!connectTypes.includes(connectCallbackData.type)) {\n        if (auto) {\n          return;\n        }\n        throw new Error('Cannot connect to wallet');\n      }\n      if (connectCallbackData && !(connectCallbackData.type === 'WALLETCONNECT' && auto)) {\n        yield this.walletController.connect(connectCallbackData.type, connectCallbackData.identifier);\n      }\n      const state = yield firstValueFrom(this.walletController.states().pipe(filter(it => it.status === WalletStatus.WALLET_CONNECTED))); // ONLY EXTENSION AND WALLET CONNECT, NOT CUSTOM READ ONLY\n      yield this.finalConnectStep(state, connectCallbackData.type);\n    });\n  }\n  finalConnectStep(state, connectType) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const networkNameFromWallet = state.network.name === 'classic' ? 'mainnet' : state.network.name;\n      this.settings = networks[networkNameFromWallet];\n      if (!this.lcdClient || this.networkName !== state.network.name) {\n        yield this.initLcdClient();\n      }\n      this.address = state.wallets[0].terraAddress;\n      this.network = state.network;\n      this.extensionCurrentNetworkName = this.network.name;\n      this.networkName = networkNameFromWallet;\n      localStorage.setItem('connect', connectType);\n      if (this.isReadOnly) {\n        localStorage.setItem('readonly_state', JSON.stringify(state));\n      }\n      this.isConnected = true;\n      this.connected.next(true);\n    });\n  }\n  // @throttleAsync(20)\n  // async get(path: string, params?: Record<string, string>, additionalHeaders?: Record<string, string>) {\n  //   // const headers = new HttpHeaders({ 'Cache-Control': 'no-cache', 'Content-Type': 'application/json' });\n  //   const headers = new HttpHeaders({'Content-Type': 'application/json'});\n  //   if (additionalHeaders) {\n  //     const keys = Object.keys(additionalHeaders);\n  //     for (const key of keys) {\n  //       headers.append(key, additionalHeaders[key]);\n  //     }\n  //   }\n  //\n  //   if (this.USE_NEW_BASE64_API) {\n  //     const res = await this.httpClient.get<GetResponse>(`${this.settings.lcd}/${path}`, {\n  //       params,\n  //       headers,\n  //     }).toPromise();\n  //     return res.query_result as any;\n  //   } else {\n  //     const res = await this.httpClient.get<GetResponseOld>(`${this.settings.lcd}/${path}`, {\n  //       params,\n  //       headers,\n  //     }).toPromise();\n  //     this.height = +res.height;\n  //     return res.result as any;\n  //   }\n  // }\n  disconnect() {\n    this.walletController.disconnect();\n    localStorage.removeItem('rewardInfos');\n    localStorage.removeItem('connect');\n    localStorage.removeItem('address');\n    localStorage.removeItem('readonly_state');\n    location.reload();\n  }\n  getFCD(path, params, headers) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const res = yield firstValueFrom(this.httpClient.get(`${this.settings.fcd}/${path}`, {\n        params,\n        headers\n      }));\n      return res;\n    });\n  }\n  post(msgs, confirmMsg) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.posting) {\n        return;\n      }\n      try {\n        this.posting = true;\n        const modal = yield import('./tx-post/tx-post.component');\n        const ref = this.modalService.open(modal.TxPostComponent, {\n          keyboard: false,\n          ignoreBackdropClick: true,\n          data: {\n            msgs: msgs instanceof Array ? msgs : [msgs],\n            confirmMsg\n          }\n        });\n        const result = yield firstValueFrom(ref.onClose);\n        if (!result) {\n          throw new Error('Transaction canceled');\n        }\n        this.transactionComplete.next(null);\n      } finally {\n        this.posting = false;\n      }\n    });\n  }\n  toDate(height) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const now = Date.now();\n      yield this.getHeight();\n      return new Date(now + (height - this.height) * BLOCK_TIME);\n    });\n  }\n  deductTax(denom, amount) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const [taxRate, taxCap] = yield Promise.all([this.lcdClient.treasury.taxRate(), this.lcdClient.treasury.taxCap(denom)]);\n      const num = new BigNumber(amount);\n      let tax = num.minus(num.div(1 + taxRate.toNumber()).integerValue(BigNumber.ROUND_DOWN));\n      if (tax.gt(taxCap.amount.toString())) {\n        tax = new BigNumber(taxCap.amount.toString());\n      }\n      return num.minus(tax).toString();\n    });\n  }\n  getWalletController() {\n    return __awaiter(this, void 0, void 0, function* () {\n      while (!this.walletController) {\n        yield new Promise(ok => setTimeout(() => ok('')));\n      }\n      return this.walletController;\n    });\n  }\n}\nTerrajsService.ɵfac = function TerrajsService_Factory(t) {\n  return new (t || TerrajsService)(i0.ɵɵinject(i1.HttpClient), i0.ɵɵinject(i2.ModalService), i0.ɵɵinject(i3.MdbModalService));\n};\nTerrajsService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: TerrajsService,\n  factory: TerrajsService.ɵfac,\n  providedIn: 'root'\n});\n__decorate([throttleAsync(1) // to prevent first time getHeight from calling API tendermint.blockInfo() simultaneously\n], TerrajsService.prototype, \"getHeight\", null);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}