{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GrpcWebImpl = exports.MsgAcknowledgementDesc = exports.MsgTimeoutOnCloseDesc = exports.MsgTimeoutDesc = exports.MsgRecvPacketDesc = exports.MsgChannelCloseConfirmDesc = exports.MsgChannelCloseInitDesc = exports.MsgChannelOpenConfirmDesc = exports.MsgChannelOpenAckDesc = exports.MsgChannelOpenTryDesc = exports.MsgChannelOpenInitDesc = exports.MsgDesc = exports.MsgClientImpl = exports.MsgAcknowledgementResponse = exports.MsgAcknowledgement = exports.MsgTimeoutOnCloseResponse = exports.MsgTimeoutOnClose = exports.MsgTimeoutResponse = exports.MsgTimeout = exports.MsgRecvPacketResponse = exports.MsgRecvPacket = exports.MsgChannelCloseConfirmResponse = exports.MsgChannelCloseConfirm = exports.MsgChannelCloseInitResponse = exports.MsgChannelCloseInit = exports.MsgChannelOpenConfirmResponse = exports.MsgChannelOpenConfirm = exports.MsgChannelOpenAckResponse = exports.MsgChannelOpenAck = exports.MsgChannelOpenTryResponse = exports.MsgChannelOpenTry = exports.MsgChannelOpenInitResponse = exports.MsgChannelOpenInit = exports.responseResultTypeToJSON = exports.responseResultTypeFromJSON = exports.ResponseResultType = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst grpc_web_1 = require(\"@improbable-eng/grpc-web\");\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst channel_1 = require(\"../../../../ibc/core/channel/v1/channel\");\nconst client_1 = require(\"../../../../ibc/core/client/v1/client\");\nconst browser_headers_1 = require(\"browser-headers\");\nexports.protobufPackage = \"ibc.core.channel.v1\";\n/** ResponseResultType defines the possible outcomes of the execution of a message */\nvar ResponseResultType;\n(function (ResponseResultType) {\n  /** RESPONSE_RESULT_TYPE_UNSPECIFIED - Default zero value enumeration */\n  ResponseResultType[ResponseResultType[\"RESPONSE_RESULT_TYPE_UNSPECIFIED\"] = 0] = \"RESPONSE_RESULT_TYPE_UNSPECIFIED\";\n  /** RESPONSE_RESULT_TYPE_NOOP - The message did not call the IBC application callbacks (because, for example, the packet had already been relayed) */\n  ResponseResultType[ResponseResultType[\"RESPONSE_RESULT_TYPE_NOOP\"] = 1] = \"RESPONSE_RESULT_TYPE_NOOP\";\n  /** RESPONSE_RESULT_TYPE_SUCCESS - The message was executed successfully */\n  ResponseResultType[ResponseResultType[\"RESPONSE_RESULT_TYPE_SUCCESS\"] = 2] = \"RESPONSE_RESULT_TYPE_SUCCESS\";\n  ResponseResultType[ResponseResultType[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(ResponseResultType = exports.ResponseResultType || (exports.ResponseResultType = {}));\nfunction responseResultTypeFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"RESPONSE_RESULT_TYPE_UNSPECIFIED\":\n      return ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED;\n    case 1:\n    case \"RESPONSE_RESULT_TYPE_NOOP\":\n      return ResponseResultType.RESPONSE_RESULT_TYPE_NOOP;\n    case 2:\n    case \"RESPONSE_RESULT_TYPE_SUCCESS\":\n      return ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return ResponseResultType.UNRECOGNIZED;\n  }\n}\nexports.responseResultTypeFromJSON = responseResultTypeFromJSON;\nfunction responseResultTypeToJSON(object) {\n  switch (object) {\n    case ResponseResultType.RESPONSE_RESULT_TYPE_UNSPECIFIED:\n      return \"RESPONSE_RESULT_TYPE_UNSPECIFIED\";\n    case ResponseResultType.RESPONSE_RESULT_TYPE_NOOP:\n      return \"RESPONSE_RESULT_TYPE_NOOP\";\n    case ResponseResultType.RESPONSE_RESULT_TYPE_SUCCESS:\n      return \"RESPONSE_RESULT_TYPE_SUCCESS\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.responseResultTypeToJSON = responseResultTypeToJSON;\nconst baseMsgChannelOpenInit = {\n  portId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenInit = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channel !== undefined) {\n      channel_1.Channel.encode(message.channel, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(26).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenInit);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channel = channel_1.Channel.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenInit);\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromJSON(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenInit);\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromPartial(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgChannelOpenInitResponse = {\n  channelId: \"\"\n};\nexports.MsgChannelOpenInitResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.channelId !== \"\") {\n      writer.uint32(10).string(message.channelId);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.channelId = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenInitResponse);\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgChannelOpenTry = {\n  portId: \"\",\n  previousChannelId: \"\",\n  counterpartyVersion: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenTry = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.previousChannelId !== \"\") {\n      writer.uint32(18).string(message.previousChannelId);\n    }\n    if (message.channel !== undefined) {\n      channel_1.Channel.encode(message.channel, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.counterpartyVersion !== \"\") {\n      writer.uint32(34).string(message.counterpartyVersion);\n    }\n    if (message.proofInit.length !== 0) {\n      writer.uint32(42).bytes(message.proofInit);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(58).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenTry);\n    message.proofInit = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.previousChannelId = reader.string();\n          break;\n        case 3:\n          message.channel = channel_1.Channel.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.counterpartyVersion = reader.string();\n          break;\n        case 5:\n          message.proofInit = reader.bytes();\n          break;\n        case 6:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenTry);\n    message.proofInit = new Uint8Array();\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n    if (object.previousChannelId !== undefined && object.previousChannelId !== null) {\n      message.previousChannelId = String(object.previousChannelId);\n    } else {\n      message.previousChannelId = \"\";\n    }\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromJSON(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = String(object.counterpartyVersion);\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = bytesFromBase64(object.proofInit);\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.previousChannelId !== undefined && (obj.previousChannelId = message.previousChannelId);\n    message.channel !== undefined && (obj.channel = message.channel ? channel_1.Channel.toJSON(message.channel) : undefined);\n    message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenTry);\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n    if (object.previousChannelId !== undefined && object.previousChannelId !== null) {\n      message.previousChannelId = object.previousChannelId;\n    } else {\n      message.previousChannelId = \"\";\n    }\n    if (object.channel !== undefined && object.channel !== null) {\n      message.channel = channel_1.Channel.fromPartial(object.channel);\n    } else {\n      message.channel = undefined;\n    }\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = object.counterpartyVersion;\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = object.proofInit;\n    } else {\n      message.proofInit = new Uint8Array();\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgChannelOpenTryResponse = {};\nexports.MsgChannelOpenTryResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelOpenTryResponse);\n    return message;\n  }\n};\nconst baseMsgChannelOpenAck = {\n  portId: \"\",\n  channelId: \"\",\n  counterpartyChannelId: \"\",\n  counterpartyVersion: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenAck = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n    if (message.counterpartyChannelId !== \"\") {\n      writer.uint32(26).string(message.counterpartyChannelId);\n    }\n    if (message.counterpartyVersion !== \"\") {\n      writer.uint32(34).string(message.counterpartyVersion);\n    }\n    if (message.proofTry.length !== 0) {\n      writer.uint32(42).bytes(message.proofTry);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(50).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(58).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenAck);\n    message.proofTry = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channelId = reader.string();\n          break;\n        case 3:\n          message.counterpartyChannelId = reader.string();\n          break;\n        case 4:\n          message.counterpartyVersion = reader.string();\n          break;\n        case 5:\n          message.proofTry = reader.bytes();\n          break;\n        case 6:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 7:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenAck);\n    message.proofTry = new Uint8Array();\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n    if (object.counterpartyChannelId !== undefined && object.counterpartyChannelId !== null) {\n      message.counterpartyChannelId = String(object.counterpartyChannelId);\n    } else {\n      message.counterpartyChannelId = \"\";\n    }\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = String(object.counterpartyVersion);\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = bytesFromBase64(object.proofTry);\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.counterpartyChannelId !== undefined && (obj.counterpartyChannelId = message.counterpartyChannelId);\n    message.counterpartyVersion !== undefined && (obj.counterpartyVersion = message.counterpartyVersion);\n    message.proofTry !== undefined && (obj.proofTry = base64FromBytes(message.proofTry !== undefined ? message.proofTry : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenAck);\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n    if (object.counterpartyChannelId !== undefined && object.counterpartyChannelId !== null) {\n      message.counterpartyChannelId = object.counterpartyChannelId;\n    } else {\n      message.counterpartyChannelId = \"\";\n    }\n    if (object.counterpartyVersion !== undefined && object.counterpartyVersion !== null) {\n      message.counterpartyVersion = object.counterpartyVersion;\n    } else {\n      message.counterpartyVersion = \"\";\n    }\n    if (object.proofTry !== undefined && object.proofTry !== null) {\n      message.proofTry = object.proofTry;\n    } else {\n      message.proofTry = new Uint8Array();\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgChannelOpenAckResponse = {};\nexports.MsgChannelOpenAckResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelOpenAckResponse);\n    return message;\n  }\n};\nconst baseMsgChannelOpenConfirm = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelOpenConfirm = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n    if (message.proofAck.length !== 0) {\n      writer.uint32(26).bytes(message.proofAck);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenConfirm);\n    message.proofAck = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channelId = reader.string();\n          break;\n        case 3:\n          message.proofAck = reader.bytes();\n          break;\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelOpenConfirm);\n    message.proofAck = new Uint8Array();\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = bytesFromBase64(object.proofAck);\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.proofAck !== undefined && (obj.proofAck = base64FromBytes(message.proofAck !== undefined ? message.proofAck : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelOpenConfirm);\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n    if (object.proofAck !== undefined && object.proofAck !== null) {\n      message.proofAck = object.proofAck;\n    } else {\n      message.proofAck = new Uint8Array();\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgChannelOpenConfirmResponse = {};\nexports.MsgChannelOpenConfirmResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelOpenConfirmResponse);\n    return message;\n  }\n};\nconst baseMsgChannelCloseInit = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelCloseInit = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(26).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelCloseInit);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channelId = reader.string();\n          break;\n        case 3:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelCloseInit);\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelCloseInit);\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgChannelCloseInitResponse = {};\nexports.MsgChannelCloseInitResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelCloseInitResponse);\n    return message;\n  }\n};\nconst baseMsgChannelCloseConfirm = {\n  portId: \"\",\n  channelId: \"\",\n  signer: \"\"\n};\nexports.MsgChannelCloseConfirm = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.portId !== \"\") {\n      writer.uint32(10).string(message.portId);\n    }\n    if (message.channelId !== \"\") {\n      writer.uint32(18).string(message.channelId);\n    }\n    if (message.proofInit.length !== 0) {\n      writer.uint32(26).bytes(message.proofInit);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelCloseConfirm);\n    message.proofInit = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.portId = reader.string();\n          break;\n        case 2:\n          message.channelId = reader.string();\n          break;\n        case 3:\n          message.proofInit = reader.bytes();\n          break;\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgChannelCloseConfirm);\n    message.proofInit = new Uint8Array();\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = String(object.portId);\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = String(object.channelId);\n    } else {\n      message.channelId = \"\";\n    }\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = bytesFromBase64(object.proofInit);\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.portId !== undefined && (obj.portId = message.portId);\n    message.channelId !== undefined && (obj.channelId = message.channelId);\n    message.proofInit !== undefined && (obj.proofInit = base64FromBytes(message.proofInit !== undefined ? message.proofInit : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgChannelCloseConfirm);\n    if (object.portId !== undefined && object.portId !== null) {\n      message.portId = object.portId;\n    } else {\n      message.portId = \"\";\n    }\n    if (object.channelId !== undefined && object.channelId !== null) {\n      message.channelId = object.channelId;\n    } else {\n      message.channelId = \"\";\n    }\n    if (object.proofInit !== undefined && object.proofInit !== null) {\n      message.proofInit = object.proofInit;\n    } else {\n      message.proofInit = new Uint8Array();\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgChannelCloseConfirmResponse = {};\nexports.MsgChannelCloseConfirmResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgChannelCloseConfirmResponse);\n    return message;\n  }\n};\nconst baseMsgRecvPacket = {\n  signer: \"\"\n};\nexports.MsgRecvPacket = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proofCommitment.length !== 0) {\n      writer.uint32(18).bytes(message.proofCommitment);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(34).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgRecvPacket);\n    message.proofCommitment = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.proofCommitment = reader.bytes();\n          break;\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgRecvPacket);\n    message.proofCommitment = new Uint8Array();\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n    if (object.proofCommitment !== undefined && object.proofCommitment !== null) {\n      message.proofCommitment = bytesFromBase64(object.proofCommitment);\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofCommitment !== undefined && (obj.proofCommitment = base64FromBytes(message.proofCommitment !== undefined ? message.proofCommitment : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgRecvPacket);\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n    if (object.proofCommitment !== undefined && object.proofCommitment !== null) {\n      message.proofCommitment = object.proofCommitment;\n    } else {\n      message.proofCommitment = new Uint8Array();\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgRecvPacketResponse = {\n  result: 0\n};\nexports.MsgRecvPacketResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgRecvPacketResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgRecvPacketResponse);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = responseResultTypeFromJSON(object.result);\n    } else {\n      message.result = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgRecvPacketResponse);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = object.result;\n    } else {\n      message.result = 0;\n    }\n    return message;\n  }\n};\nconst baseMsgTimeout = {\n  nextSequenceRecv: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgTimeout = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proofUnreceived.length !== 0) {\n      writer.uint32(18).bytes(message.proofUnreceived);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(26).fork()).ldelim();\n    }\n    if (!message.nextSequenceRecv.isZero()) {\n      writer.uint32(32).uint64(message.nextSequenceRecv);\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgTimeout);\n    message.proofUnreceived = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.proofUnreceived = reader.bytes();\n          break;\n        case 3:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.nextSequenceRecv = reader.uint64();\n          break;\n        case 5:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgTimeout);\n    message.proofUnreceived = new Uint8Array();\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = bytesFromBase64(object.proofUnreceived);\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = long_1.default.fromString(object.nextSequenceRecv);\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofUnreceived !== undefined && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgTimeout);\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = object.proofUnreceived;\n    } else {\n      message.proofUnreceived = new Uint8Array();\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = object.nextSequenceRecv;\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgTimeoutResponse = {\n  result: 0\n};\nexports.MsgTimeoutResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgTimeoutResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgTimeoutResponse);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = responseResultTypeFromJSON(object.result);\n    } else {\n      message.result = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgTimeoutResponse);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = object.result;\n    } else {\n      message.result = 0;\n    }\n    return message;\n  }\n};\nconst baseMsgTimeoutOnClose = {\n  nextSequenceRecv: long_1.default.UZERO,\n  signer: \"\"\n};\nexports.MsgTimeoutOnClose = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.proofUnreceived.length !== 0) {\n      writer.uint32(18).bytes(message.proofUnreceived);\n    }\n    if (message.proofClose.length !== 0) {\n      writer.uint32(26).bytes(message.proofClose);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n    if (!message.nextSequenceRecv.isZero()) {\n      writer.uint32(40).uint64(message.nextSequenceRecv);\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(50).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgTimeoutOnClose);\n    message.proofUnreceived = new Uint8Array();\n    message.proofClose = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.proofUnreceived = reader.bytes();\n          break;\n        case 3:\n          message.proofClose = reader.bytes();\n          break;\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.nextSequenceRecv = reader.uint64();\n          break;\n        case 6:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgTimeoutOnClose);\n    message.proofUnreceived = new Uint8Array();\n    message.proofClose = new Uint8Array();\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = bytesFromBase64(object.proofUnreceived);\n    }\n    if (object.proofClose !== undefined && object.proofClose !== null) {\n      message.proofClose = bytesFromBase64(object.proofClose);\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = long_1.default.fromString(object.nextSequenceRecv);\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.proofUnreceived !== undefined && (obj.proofUnreceived = base64FromBytes(message.proofUnreceived !== undefined ? message.proofUnreceived : new Uint8Array()));\n    message.proofClose !== undefined && (obj.proofClose = base64FromBytes(message.proofClose !== undefined ? message.proofClose : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.nextSequenceRecv !== undefined && (obj.nextSequenceRecv = (message.nextSequenceRecv || long_1.default.UZERO).toString());\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgTimeoutOnClose);\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n    if (object.proofUnreceived !== undefined && object.proofUnreceived !== null) {\n      message.proofUnreceived = object.proofUnreceived;\n    } else {\n      message.proofUnreceived = new Uint8Array();\n    }\n    if (object.proofClose !== undefined && object.proofClose !== null) {\n      message.proofClose = object.proofClose;\n    } else {\n      message.proofClose = new Uint8Array();\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.nextSequenceRecv !== undefined && object.nextSequenceRecv !== null) {\n      message.nextSequenceRecv = object.nextSequenceRecv;\n    } else {\n      message.nextSequenceRecv = long_1.default.UZERO;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgTimeoutOnCloseResponse = {\n  result: 0\n};\nexports.MsgTimeoutOnCloseResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = responseResultTypeFromJSON(object.result);\n    } else {\n      message.result = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgTimeoutOnCloseResponse);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = object.result;\n    } else {\n      message.result = 0;\n    }\n    return message;\n  }\n};\nconst baseMsgAcknowledgement = {\n  signer: \"\"\n};\nexports.MsgAcknowledgement = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.packet !== undefined) {\n      channel_1.Packet.encode(message.packet, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.acknowledgement.length !== 0) {\n      writer.uint32(18).bytes(message.acknowledgement);\n    }\n    if (message.proofAcked.length !== 0) {\n      writer.uint32(26).bytes(message.proofAcked);\n    }\n    if (message.proofHeight !== undefined) {\n      client_1.Height.encode(message.proofHeight, writer.uint32(34).fork()).ldelim();\n    }\n    if (message.signer !== \"\") {\n      writer.uint32(42).string(message.signer);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgAcknowledgement);\n    message.acknowledgement = new Uint8Array();\n    message.proofAcked = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.packet = channel_1.Packet.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.acknowledgement = reader.bytes();\n          break;\n        case 3:\n          message.proofAcked = reader.bytes();\n          break;\n        case 4:\n          message.proofHeight = client_1.Height.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.signer = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgAcknowledgement);\n    message.acknowledgement = new Uint8Array();\n    message.proofAcked = new Uint8Array();\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromJSON(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n    if (object.acknowledgement !== undefined && object.acknowledgement !== null) {\n      message.acknowledgement = bytesFromBase64(object.acknowledgement);\n    }\n    if (object.proofAcked !== undefined && object.proofAcked !== null) {\n      message.proofAcked = bytesFromBase64(object.proofAcked);\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromJSON(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = String(object.signer);\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.packet !== undefined && (obj.packet = message.packet ? channel_1.Packet.toJSON(message.packet) : undefined);\n    message.acknowledgement !== undefined && (obj.acknowledgement = base64FromBytes(message.acknowledgement !== undefined ? message.acknowledgement : new Uint8Array()));\n    message.proofAcked !== undefined && (obj.proofAcked = base64FromBytes(message.proofAcked !== undefined ? message.proofAcked : new Uint8Array()));\n    message.proofHeight !== undefined && (obj.proofHeight = message.proofHeight ? client_1.Height.toJSON(message.proofHeight) : undefined);\n    message.signer !== undefined && (obj.signer = message.signer);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgAcknowledgement);\n    if (object.packet !== undefined && object.packet !== null) {\n      message.packet = channel_1.Packet.fromPartial(object.packet);\n    } else {\n      message.packet = undefined;\n    }\n    if (object.acknowledgement !== undefined && object.acknowledgement !== null) {\n      message.acknowledgement = object.acknowledgement;\n    } else {\n      message.acknowledgement = new Uint8Array();\n    }\n    if (object.proofAcked !== undefined && object.proofAcked !== null) {\n      message.proofAcked = object.proofAcked;\n    } else {\n      message.proofAcked = new Uint8Array();\n    }\n    if (object.proofHeight !== undefined && object.proofHeight !== null) {\n      message.proofHeight = client_1.Height.fromPartial(object.proofHeight);\n    } else {\n      message.proofHeight = undefined;\n    }\n    if (object.signer !== undefined && object.signer !== null) {\n      message.signer = object.signer;\n    } else {\n      message.signer = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgAcknowledgementResponse = {\n  result: 0\n};\nexports.MsgAcknowledgementResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.result !== 0) {\n      writer.uint32(8).int32(message.result);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgAcknowledgementResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.result = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgAcknowledgementResponse);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = responseResultTypeFromJSON(object.result);\n    } else {\n      message.result = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.result !== undefined && (obj.result = responseResultTypeToJSON(message.result));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgAcknowledgementResponse);\n    if (object.result !== undefined && object.result !== null) {\n      message.result = object.result;\n    } else {\n      message.result = 0;\n    }\n    return message;\n  }\n};\nclass MsgClientImpl {\n  constructor(rpc) {\n    this.rpc = rpc;\n    this.ChannelOpenInit = this.ChannelOpenInit.bind(this);\n    this.ChannelOpenTry = this.ChannelOpenTry.bind(this);\n    this.ChannelOpenAck = this.ChannelOpenAck.bind(this);\n    this.ChannelOpenConfirm = this.ChannelOpenConfirm.bind(this);\n    this.ChannelCloseInit = this.ChannelCloseInit.bind(this);\n    this.ChannelCloseConfirm = this.ChannelCloseConfirm.bind(this);\n    this.RecvPacket = this.RecvPacket.bind(this);\n    this.Timeout = this.Timeout.bind(this);\n    this.TimeoutOnClose = this.TimeoutOnClose.bind(this);\n    this.Acknowledgement = this.Acknowledgement.bind(this);\n  }\n  ChannelOpenInit(request, metadata) {\n    return this.rpc.unary(exports.MsgChannelOpenInitDesc, exports.MsgChannelOpenInit.fromPartial(request), metadata);\n  }\n  ChannelOpenTry(request, metadata) {\n    return this.rpc.unary(exports.MsgChannelOpenTryDesc, exports.MsgChannelOpenTry.fromPartial(request), metadata);\n  }\n  ChannelOpenAck(request, metadata) {\n    return this.rpc.unary(exports.MsgChannelOpenAckDesc, exports.MsgChannelOpenAck.fromPartial(request), metadata);\n  }\n  ChannelOpenConfirm(request, metadata) {\n    return this.rpc.unary(exports.MsgChannelOpenConfirmDesc, exports.MsgChannelOpenConfirm.fromPartial(request), metadata);\n  }\n  ChannelCloseInit(request, metadata) {\n    return this.rpc.unary(exports.MsgChannelCloseInitDesc, exports.MsgChannelCloseInit.fromPartial(request), metadata);\n  }\n  ChannelCloseConfirm(request, metadata) {\n    return this.rpc.unary(exports.MsgChannelCloseConfirmDesc, exports.MsgChannelCloseConfirm.fromPartial(request), metadata);\n  }\n  RecvPacket(request, metadata) {\n    return this.rpc.unary(exports.MsgRecvPacketDesc, exports.MsgRecvPacket.fromPartial(request), metadata);\n  }\n  Timeout(request, metadata) {\n    return this.rpc.unary(exports.MsgTimeoutDesc, exports.MsgTimeout.fromPartial(request), metadata);\n  }\n  TimeoutOnClose(request, metadata) {\n    return this.rpc.unary(exports.MsgTimeoutOnCloseDesc, exports.MsgTimeoutOnClose.fromPartial(request), metadata);\n  }\n  Acknowledgement(request, metadata) {\n    return this.rpc.unary(exports.MsgAcknowledgementDesc, exports.MsgAcknowledgement.fromPartial(request), metadata);\n  }\n}\nexports.MsgClientImpl = MsgClientImpl;\nexports.MsgDesc = {\n  serviceName: \"ibc.core.channel.v1.Msg\"\n};\nexports.MsgChannelOpenInitDesc = {\n  methodName: \"ChannelOpenInit\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgChannelOpenInit.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgChannelOpenInitResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgChannelOpenTryDesc = {\n  methodName: \"ChannelOpenTry\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgChannelOpenTry.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgChannelOpenTryResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgChannelOpenAckDesc = {\n  methodName: \"ChannelOpenAck\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgChannelOpenAck.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgChannelOpenAckResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgChannelOpenConfirmDesc = {\n  methodName: \"ChannelOpenConfirm\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgChannelOpenConfirm.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgChannelOpenConfirmResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgChannelCloseInitDesc = {\n  methodName: \"ChannelCloseInit\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgChannelCloseInit.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgChannelCloseInitResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgChannelCloseConfirmDesc = {\n  methodName: \"ChannelCloseConfirm\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgChannelCloseConfirm.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgChannelCloseConfirmResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgRecvPacketDesc = {\n  methodName: \"RecvPacket\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgRecvPacket.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgRecvPacketResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgTimeoutDesc = {\n  methodName: \"Timeout\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgTimeout.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgTimeoutResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgTimeoutOnCloseDesc = {\n  methodName: \"TimeoutOnClose\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgTimeoutOnClose.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgTimeoutOnCloseResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgAcknowledgementDesc = {\n  methodName: \"Acknowledgement\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgAcknowledgement.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgAcknowledgementResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nclass GrpcWebImpl {\n  constructor(host, options) {\n    this.host = host;\n    this.options = options;\n  }\n  unary(methodDesc, _request, metadata) {\n    var _a;\n    const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);\n    const maybeCombinedMetadata = metadata && this.options.metadata ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap)) : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc_web_1.grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc_web_1.grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage);\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        }\n      });\n    });\n  }\n}\nexports.GrpcWebImpl = GrpcWebImpl;\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=tx.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}