{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompressedNonExistenceProof = exports.CompressedExistenceProof = exports.CompressedBatchEntry = exports.CompressedBatchProof = exports.BatchEntry = exports.BatchProof = exports.InnerSpec = exports.ProofSpec = exports.InnerOp = exports.LeafOp = exports.CommitmentProof = exports.NonExistenceProof = exports.ExistenceProof = exports.lengthOpToJSON = exports.lengthOpFromJSON = exports.LengthOp = exports.hashOpToJSON = exports.hashOpFromJSON = exports.HashOp = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nexports.protobufPackage = \"ics23\";\nvar HashOp;\n(function (HashOp) {\n  /** NO_HASH - NO_HASH is the default if no data passed. Note this is an illegal argument some places. */\n  HashOp[HashOp[\"NO_HASH\"] = 0] = \"NO_HASH\";\n  HashOp[HashOp[\"SHA256\"] = 1] = \"SHA256\";\n  HashOp[HashOp[\"SHA512\"] = 2] = \"SHA512\";\n  HashOp[HashOp[\"KECCAK\"] = 3] = \"KECCAK\";\n  HashOp[HashOp[\"RIPEMD160\"] = 4] = \"RIPEMD160\";\n  /** BITCOIN - ripemd160(sha256(x)) */\n  HashOp[HashOp[\"BITCOIN\"] = 5] = \"BITCOIN\";\n  HashOp[HashOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(HashOp = exports.HashOp || (exports.HashOp = {}));\nfunction hashOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NO_HASH\":\n      return HashOp.NO_HASH;\n    case 1:\n    case \"SHA256\":\n      return HashOp.SHA256;\n    case 2:\n    case \"SHA512\":\n      return HashOp.SHA512;\n    case 3:\n    case \"KECCAK\":\n      return HashOp.KECCAK;\n    case 4:\n    case \"RIPEMD160\":\n      return HashOp.RIPEMD160;\n    case 5:\n    case \"BITCOIN\":\n      return HashOp.BITCOIN;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return HashOp.UNRECOGNIZED;\n  }\n}\nexports.hashOpFromJSON = hashOpFromJSON;\nfunction hashOpToJSON(object) {\n  switch (object) {\n    case HashOp.NO_HASH:\n      return \"NO_HASH\";\n    case HashOp.SHA256:\n      return \"SHA256\";\n    case HashOp.SHA512:\n      return \"SHA512\";\n    case HashOp.KECCAK:\n      return \"KECCAK\";\n    case HashOp.RIPEMD160:\n      return \"RIPEMD160\";\n    case HashOp.BITCOIN:\n      return \"BITCOIN\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.hashOpToJSON = hashOpToJSON;\n/**\n * LengthOp defines how to process the key and value of the LeafOp\n * to include length information. After encoding the length with the given\n * algorithm, the length will be prepended to the key and value bytes.\n * (Each one with it's own encoded length)\n */\nvar LengthOp;\n(function (LengthOp) {\n  /** NO_PREFIX - NO_PREFIX don't include any length info */\n  LengthOp[LengthOp[\"NO_PREFIX\"] = 0] = \"NO_PREFIX\";\n  /** VAR_PROTO - VAR_PROTO uses protobuf (and go-amino) varint encoding of the length */\n  LengthOp[LengthOp[\"VAR_PROTO\"] = 1] = \"VAR_PROTO\";\n  /** VAR_RLP - VAR_RLP uses rlp int encoding of the length */\n  LengthOp[LengthOp[\"VAR_RLP\"] = 2] = \"VAR_RLP\";\n  /** FIXED32_BIG - FIXED32_BIG uses big-endian encoding of the length as a 32 bit integer */\n  LengthOp[LengthOp[\"FIXED32_BIG\"] = 3] = \"FIXED32_BIG\";\n  /** FIXED32_LITTLE - FIXED32_LITTLE uses little-endian encoding of the length as a 32 bit integer */\n  LengthOp[LengthOp[\"FIXED32_LITTLE\"] = 4] = \"FIXED32_LITTLE\";\n  /** FIXED64_BIG - FIXED64_BIG uses big-endian encoding of the length as a 64 bit integer */\n  LengthOp[LengthOp[\"FIXED64_BIG\"] = 5] = \"FIXED64_BIG\";\n  /** FIXED64_LITTLE - FIXED64_LITTLE uses little-endian encoding of the length as a 64 bit integer */\n  LengthOp[LengthOp[\"FIXED64_LITTLE\"] = 6] = \"FIXED64_LITTLE\";\n  /** REQUIRE_32_BYTES - REQUIRE_32_BYTES is like NONE, but will fail if the input is not exactly 32 bytes (sha256 output) */\n  LengthOp[LengthOp[\"REQUIRE_32_BYTES\"] = 7] = \"REQUIRE_32_BYTES\";\n  /** REQUIRE_64_BYTES - REQUIRE_64_BYTES is like NONE, but will fail if the input is not exactly 64 bytes (sha512 output) */\n  LengthOp[LengthOp[\"REQUIRE_64_BYTES\"] = 8] = \"REQUIRE_64_BYTES\";\n  LengthOp[LengthOp[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(LengthOp = exports.LengthOp || (exports.LengthOp = {}));\nfunction lengthOpFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"NO_PREFIX\":\n      return LengthOp.NO_PREFIX;\n    case 1:\n    case \"VAR_PROTO\":\n      return LengthOp.VAR_PROTO;\n    case 2:\n    case \"VAR_RLP\":\n      return LengthOp.VAR_RLP;\n    case 3:\n    case \"FIXED32_BIG\":\n      return LengthOp.FIXED32_BIG;\n    case 4:\n    case \"FIXED32_LITTLE\":\n      return LengthOp.FIXED32_LITTLE;\n    case 5:\n    case \"FIXED64_BIG\":\n      return LengthOp.FIXED64_BIG;\n    case 6:\n    case \"FIXED64_LITTLE\":\n      return LengthOp.FIXED64_LITTLE;\n    case 7:\n    case \"REQUIRE_32_BYTES\":\n      return LengthOp.REQUIRE_32_BYTES;\n    case 8:\n    case \"REQUIRE_64_BYTES\":\n      return LengthOp.REQUIRE_64_BYTES;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return LengthOp.UNRECOGNIZED;\n  }\n}\nexports.lengthOpFromJSON = lengthOpFromJSON;\nfunction lengthOpToJSON(object) {\n  switch (object) {\n    case LengthOp.NO_PREFIX:\n      return \"NO_PREFIX\";\n    case LengthOp.VAR_PROTO:\n      return \"VAR_PROTO\";\n    case LengthOp.VAR_RLP:\n      return \"VAR_RLP\";\n    case LengthOp.FIXED32_BIG:\n      return \"FIXED32_BIG\";\n    case LengthOp.FIXED32_LITTLE:\n      return \"FIXED32_LITTLE\";\n    case LengthOp.FIXED64_BIG:\n      return \"FIXED64_BIG\";\n    case LengthOp.FIXED64_LITTLE:\n      return \"FIXED64_LITTLE\";\n    case LengthOp.REQUIRE_32_BYTES:\n      return \"REQUIRE_32_BYTES\";\n    case LengthOp.REQUIRE_64_BYTES:\n      return \"REQUIRE_64_BYTES\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.lengthOpToJSON = lengthOpToJSON;\nconst baseExistenceProof = {};\nexports.ExistenceProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.leaf !== undefined) {\n      exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n    for (const v of message.path) {\n      exports.InnerOp.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseExistenceProof);\n    message.path = [];\n    message.key = new Uint8Array();\n    message.value = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.leaf = exports.LeafOp.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.path.push(exports.InnerOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseExistenceProof);\n    message.path = [];\n    message.key = new Uint8Array();\n    message.value = new Uint8Array();\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = bytesFromBase64(object.value);\n    }\n    if (object.leaf !== undefined && object.leaf !== null) {\n      message.leaf = exports.LeafOp.fromJSON(object.leaf);\n    } else {\n      message.leaf = undefined;\n    }\n    if (object.path !== undefined && object.path !== null) {\n      for (const e of object.path) {\n        message.path.push(exports.InnerOp.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n    message.leaf !== undefined && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : undefined);\n    if (message.path) {\n      obj.path = message.path.map(e => e ? exports.InnerOp.toJSON(e) : undefined);\n    } else {\n      obj.path = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseExistenceProof);\n    message.path = [];\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = object.value;\n    } else {\n      message.value = new Uint8Array();\n    }\n    if (object.leaf !== undefined && object.leaf !== null) {\n      message.leaf = exports.LeafOp.fromPartial(object.leaf);\n    } else {\n      message.leaf = undefined;\n    }\n    if (object.path !== undefined && object.path !== null) {\n      for (const e of object.path) {\n        message.path.push(exports.InnerOp.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseNonExistenceProof = {};\nexports.NonExistenceProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.left !== undefined) {\n      exports.ExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.right !== undefined) {\n      exports.ExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseNonExistenceProof);\n    message.key = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.left = exports.ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.right = exports.ExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseNonExistenceProof);\n    message.key = new Uint8Array();\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n    if (object.left !== undefined && object.left !== null) {\n      message.left = exports.ExistenceProof.fromJSON(object.left);\n    } else {\n      message.left = undefined;\n    }\n    if (object.right !== undefined && object.right !== null) {\n      message.right = exports.ExistenceProof.fromJSON(object.right);\n    } else {\n      message.right = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.left !== undefined && (obj.left = message.left ? exports.ExistenceProof.toJSON(message.left) : undefined);\n    message.right !== undefined && (obj.right = message.right ? exports.ExistenceProof.toJSON(message.right) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseNonExistenceProof);\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n    if (object.left !== undefined && object.left !== null) {\n      message.left = exports.ExistenceProof.fromPartial(object.left);\n    } else {\n      message.left = undefined;\n    }\n    if (object.right !== undefined && object.right !== null) {\n      message.right = exports.ExistenceProof.fromPartial(object.right);\n    } else {\n      message.right = undefined;\n    }\n    return message;\n  }\n};\nconst baseCommitmentProof = {};\nexports.CommitmentProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.exist !== undefined) {\n      exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.batch !== undefined) {\n      exports.BatchProof.encode(message.batch, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.compressed !== undefined) {\n      exports.CompressedBatchProof.encode(message.compressed, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCommitmentProof);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = exports.ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.batch = exports.BatchProof.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.compressed = exports.CompressedBatchProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseCommitmentProof);\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.ExistenceProof.fromJSON(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n    if (object.batch !== undefined && object.batch !== null) {\n      message.batch = exports.BatchProof.fromJSON(object.batch);\n    } else {\n      message.batch = undefined;\n    }\n    if (object.compressed !== undefined && object.compressed !== null) {\n      message.compressed = exports.CompressedBatchProof.fromJSON(object.compressed);\n    } else {\n      message.compressed = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : undefined);\n    message.batch !== undefined && (obj.batch = message.batch ? exports.BatchProof.toJSON(message.batch) : undefined);\n    message.compressed !== undefined && (obj.compressed = message.compressed ? exports.CompressedBatchProof.toJSON(message.compressed) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseCommitmentProof);\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.ExistenceProof.fromPartial(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n    if (object.batch !== undefined && object.batch !== null) {\n      message.batch = exports.BatchProof.fromPartial(object.batch);\n    } else {\n      message.batch = undefined;\n    }\n    if (object.compressed !== undefined && object.compressed !== null) {\n      message.compressed = exports.CompressedBatchProof.fromPartial(object.compressed);\n    } else {\n      message.compressed = undefined;\n    }\n    return message;\n  }\n};\nconst baseLeafOp = {\n  hash: 0,\n  prehashKey: 0,\n  prehashValue: 0,\n  length: 0\n};\nexports.LeafOp = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n    if (message.prehashKey !== 0) {\n      writer.uint32(16).int32(message.prehashKey);\n    }\n    if (message.prehashValue !== 0) {\n      writer.uint32(24).int32(message.prehashValue);\n    }\n    if (message.length !== 0) {\n      writer.uint32(32).int32(message.length);\n    }\n    if (message.prefix.length !== 0) {\n      writer.uint32(42).bytes(message.prefix);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseLeafOp);\n    message.prefix = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n        case 2:\n          message.prehashKey = reader.int32();\n          break;\n        case 3:\n          message.prehashValue = reader.int32();\n          break;\n        case 4:\n          message.length = reader.int32();\n          break;\n        case 5:\n          message.prefix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseLeafOp);\n    message.prefix = new Uint8Array();\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = hashOpFromJSON(object.hash);\n    } else {\n      message.hash = 0;\n    }\n    if (object.prehashKey !== undefined && object.prehashKey !== null) {\n      message.prehashKey = hashOpFromJSON(object.prehashKey);\n    } else {\n      message.prehashKey = 0;\n    }\n    if (object.prehashValue !== undefined && object.prehashValue !== null) {\n      message.prehashValue = hashOpFromJSON(object.prehashValue);\n    } else {\n      message.prehashValue = 0;\n    }\n    if (object.length !== undefined && object.length !== null) {\n      message.length = lengthOpFromJSON(object.length);\n    } else {\n      message.length = 0;\n    }\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = bytesFromBase64(object.prefix);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    message.prehashKey !== undefined && (obj.prehashKey = hashOpToJSON(message.prehashKey));\n    message.prehashValue !== undefined && (obj.prehashValue = hashOpToJSON(message.prehashValue));\n    message.length !== undefined && (obj.length = lengthOpToJSON(message.length));\n    message.prefix !== undefined && (obj.prefix = base64FromBytes(message.prefix !== undefined ? message.prefix : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseLeafOp);\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = 0;\n    }\n    if (object.prehashKey !== undefined && object.prehashKey !== null) {\n      message.prehashKey = object.prehashKey;\n    } else {\n      message.prehashKey = 0;\n    }\n    if (object.prehashValue !== undefined && object.prehashValue !== null) {\n      message.prehashValue = object.prehashValue;\n    } else {\n      message.prehashValue = 0;\n    }\n    if (object.length !== undefined && object.length !== null) {\n      message.length = object.length;\n    } else {\n      message.length = 0;\n    }\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = object.prefix;\n    } else {\n      message.prefix = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseInnerOp = {\n  hash: 0\n};\nexports.InnerOp = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.hash !== 0) {\n      writer.uint32(8).int32(message.hash);\n    }\n    if (message.prefix.length !== 0) {\n      writer.uint32(18).bytes(message.prefix);\n    }\n    if (message.suffix.length !== 0) {\n      writer.uint32(26).bytes(message.suffix);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseInnerOp);\n    message.prefix = new Uint8Array();\n    message.suffix = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.int32();\n          break;\n        case 2:\n          message.prefix = reader.bytes();\n          break;\n        case 3:\n          message.suffix = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseInnerOp);\n    message.prefix = new Uint8Array();\n    message.suffix = new Uint8Array();\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = hashOpFromJSON(object.hash);\n    } else {\n      message.hash = 0;\n    }\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = bytesFromBase64(object.prefix);\n    }\n    if (object.suffix !== undefined && object.suffix !== null) {\n      message.suffix = bytesFromBase64(object.suffix);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    message.prefix !== undefined && (obj.prefix = base64FromBytes(message.prefix !== undefined ? message.prefix : new Uint8Array()));\n    message.suffix !== undefined && (obj.suffix = base64FromBytes(message.suffix !== undefined ? message.suffix : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseInnerOp);\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = 0;\n    }\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = object.prefix;\n    } else {\n      message.prefix = new Uint8Array();\n    }\n    if (object.suffix !== undefined && object.suffix !== null) {\n      message.suffix = object.suffix;\n    } else {\n      message.suffix = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseProofSpec = {\n  maxDepth: 0,\n  minDepth: 0\n};\nexports.ProofSpec = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.leafSpec !== undefined) {\n      exports.LeafOp.encode(message.leafSpec, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.innerSpec !== undefined) {\n      exports.InnerSpec.encode(message.innerSpec, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.maxDepth !== 0) {\n      writer.uint32(24).int32(message.maxDepth);\n    }\n    if (message.minDepth !== 0) {\n      writer.uint32(32).int32(message.minDepth);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseProofSpec);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.leafSpec = exports.LeafOp.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.innerSpec = exports.InnerSpec.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.maxDepth = reader.int32();\n          break;\n        case 4:\n          message.minDepth = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseProofSpec);\n    if (object.leafSpec !== undefined && object.leafSpec !== null) {\n      message.leafSpec = exports.LeafOp.fromJSON(object.leafSpec);\n    } else {\n      message.leafSpec = undefined;\n    }\n    if (object.innerSpec !== undefined && object.innerSpec !== null) {\n      message.innerSpec = exports.InnerSpec.fromJSON(object.innerSpec);\n    } else {\n      message.innerSpec = undefined;\n    }\n    if (object.maxDepth !== undefined && object.maxDepth !== null) {\n      message.maxDepth = Number(object.maxDepth);\n    } else {\n      message.maxDepth = 0;\n    }\n    if (object.minDepth !== undefined && object.minDepth !== null) {\n      message.minDepth = Number(object.minDepth);\n    } else {\n      message.minDepth = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.leafSpec !== undefined && (obj.leafSpec = message.leafSpec ? exports.LeafOp.toJSON(message.leafSpec) : undefined);\n    message.innerSpec !== undefined && (obj.innerSpec = message.innerSpec ? exports.InnerSpec.toJSON(message.innerSpec) : undefined);\n    message.maxDepth !== undefined && (obj.maxDepth = message.maxDepth);\n    message.minDepth !== undefined && (obj.minDepth = message.minDepth);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseProofSpec);\n    if (object.leafSpec !== undefined && object.leafSpec !== null) {\n      message.leafSpec = exports.LeafOp.fromPartial(object.leafSpec);\n    } else {\n      message.leafSpec = undefined;\n    }\n    if (object.innerSpec !== undefined && object.innerSpec !== null) {\n      message.innerSpec = exports.InnerSpec.fromPartial(object.innerSpec);\n    } else {\n      message.innerSpec = undefined;\n    }\n    if (object.maxDepth !== undefined && object.maxDepth !== null) {\n      message.maxDepth = object.maxDepth;\n    } else {\n      message.maxDepth = 0;\n    }\n    if (object.minDepth !== undefined && object.minDepth !== null) {\n      message.minDepth = object.minDepth;\n    } else {\n      message.minDepth = 0;\n    }\n    return message;\n  }\n};\nconst baseInnerSpec = {\n  childOrder: 0,\n  childSize: 0,\n  minPrefixLength: 0,\n  maxPrefixLength: 0,\n  hash: 0\n};\nexports.InnerSpec = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    writer.uint32(10).fork();\n    for (const v of message.childOrder) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    if (message.childSize !== 0) {\n      writer.uint32(16).int32(message.childSize);\n    }\n    if (message.minPrefixLength !== 0) {\n      writer.uint32(24).int32(message.minPrefixLength);\n    }\n    if (message.maxPrefixLength !== 0) {\n      writer.uint32(32).int32(message.maxPrefixLength);\n    }\n    if (message.emptyChild.length !== 0) {\n      writer.uint32(42).bytes(message.emptyChild);\n    }\n    if (message.hash !== 0) {\n      writer.uint32(48).int32(message.hash);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseInnerSpec);\n    message.childOrder = [];\n    message.emptyChild = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.childOrder.push(reader.int32());\n            }\n          } else {\n            message.childOrder.push(reader.int32());\n          }\n          break;\n        case 2:\n          message.childSize = reader.int32();\n          break;\n        case 3:\n          message.minPrefixLength = reader.int32();\n          break;\n        case 4:\n          message.maxPrefixLength = reader.int32();\n          break;\n        case 5:\n          message.emptyChild = reader.bytes();\n          break;\n        case 6:\n          message.hash = reader.int32();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseInnerSpec);\n    message.childOrder = [];\n    message.emptyChild = new Uint8Array();\n    if (object.childOrder !== undefined && object.childOrder !== null) {\n      for (const e of object.childOrder) {\n        message.childOrder.push(Number(e));\n      }\n    }\n    if (object.childSize !== undefined && object.childSize !== null) {\n      message.childSize = Number(object.childSize);\n    } else {\n      message.childSize = 0;\n    }\n    if (object.minPrefixLength !== undefined && object.minPrefixLength !== null) {\n      message.minPrefixLength = Number(object.minPrefixLength);\n    } else {\n      message.minPrefixLength = 0;\n    }\n    if (object.maxPrefixLength !== undefined && object.maxPrefixLength !== null) {\n      message.maxPrefixLength = Number(object.maxPrefixLength);\n    } else {\n      message.maxPrefixLength = 0;\n    }\n    if (object.emptyChild !== undefined && object.emptyChild !== null) {\n      message.emptyChild = bytesFromBase64(object.emptyChild);\n    }\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = hashOpFromJSON(object.hash);\n    } else {\n      message.hash = 0;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.childOrder) {\n      obj.childOrder = message.childOrder.map(e => e);\n    } else {\n      obj.childOrder = [];\n    }\n    message.childSize !== undefined && (obj.childSize = message.childSize);\n    message.minPrefixLength !== undefined && (obj.minPrefixLength = message.minPrefixLength);\n    message.maxPrefixLength !== undefined && (obj.maxPrefixLength = message.maxPrefixLength);\n    message.emptyChild !== undefined && (obj.emptyChild = base64FromBytes(message.emptyChild !== undefined ? message.emptyChild : new Uint8Array()));\n    message.hash !== undefined && (obj.hash = hashOpToJSON(message.hash));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseInnerSpec);\n    message.childOrder = [];\n    if (object.childOrder !== undefined && object.childOrder !== null) {\n      for (const e of object.childOrder) {\n        message.childOrder.push(e);\n      }\n    }\n    if (object.childSize !== undefined && object.childSize !== null) {\n      message.childSize = object.childSize;\n    } else {\n      message.childSize = 0;\n    }\n    if (object.minPrefixLength !== undefined && object.minPrefixLength !== null) {\n      message.minPrefixLength = object.minPrefixLength;\n    } else {\n      message.minPrefixLength = 0;\n    }\n    if (object.maxPrefixLength !== undefined && object.maxPrefixLength !== null) {\n      message.maxPrefixLength = object.maxPrefixLength;\n    } else {\n      message.maxPrefixLength = 0;\n    }\n    if (object.emptyChild !== undefined && object.emptyChild !== null) {\n      message.emptyChild = object.emptyChild;\n    } else {\n      message.emptyChild = new Uint8Array();\n    }\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = 0;\n    }\n    return message;\n  }\n};\nconst baseBatchProof = {};\nexports.BatchProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.entries) {\n      exports.BatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseBatchProof);\n    message.entries = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(exports.BatchEntry.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseBatchProof);\n    message.entries = [];\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.BatchEntry.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? exports.BatchEntry.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseBatchProof);\n    message.entries = [];\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.BatchEntry.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseBatchEntry = {};\nexports.BatchEntry = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.exist !== undefined) {\n      exports.ExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      exports.NonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseBatchEntry);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = exports.ExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = exports.NonExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseBatchEntry);\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.ExistenceProof.fromJSON(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.NonExistenceProof.fromJSON(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? exports.ExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.NonExistenceProof.toJSON(message.nonexist) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseBatchEntry);\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.ExistenceProof.fromPartial(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.NonExistenceProof.fromPartial(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n    return message;\n  }\n};\nconst baseCompressedBatchProof = {};\nexports.CompressedBatchProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.entries) {\n      exports.CompressedBatchEntry.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.lookupInners) {\n      exports.InnerOp.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCompressedBatchProof);\n    message.entries = [];\n    message.lookupInners = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.entries.push(exports.CompressedBatchEntry.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.lookupInners.push(exports.InnerOp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseCompressedBatchProof);\n    message.entries = [];\n    message.lookupInners = [];\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.CompressedBatchEntry.fromJSON(e));\n      }\n    }\n    if (object.lookupInners !== undefined && object.lookupInners !== null) {\n      for (const e of object.lookupInners) {\n        message.lookupInners.push(exports.InnerOp.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? exports.CompressedBatchEntry.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n    if (message.lookupInners) {\n      obj.lookupInners = message.lookupInners.map(e => e ? exports.InnerOp.toJSON(e) : undefined);\n    } else {\n      obj.lookupInners = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseCompressedBatchProof);\n    message.entries = [];\n    message.lookupInners = [];\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.CompressedBatchEntry.fromPartial(e));\n      }\n    }\n    if (object.lookupInners !== undefined && object.lookupInners !== null) {\n      for (const e of object.lookupInners) {\n        message.lookupInners.push(exports.InnerOp.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseCompressedBatchEntry = {};\nexports.CompressedBatchEntry = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.exist !== undefined) {\n      exports.CompressedExistenceProof.encode(message.exist, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.nonexist !== undefined) {\n      exports.CompressedNonExistenceProof.encode(message.nonexist, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCompressedBatchEntry);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exist = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.nonexist = exports.CompressedNonExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseCompressedBatchEntry);\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.CompressedExistenceProof.fromJSON(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.CompressedNonExistenceProof.fromJSON(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.exist !== undefined && (obj.exist = message.exist ? exports.CompressedExistenceProof.toJSON(message.exist) : undefined);\n    message.nonexist !== undefined && (obj.nonexist = message.nonexist ? exports.CompressedNonExistenceProof.toJSON(message.nonexist) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseCompressedBatchEntry);\n    if (object.exist !== undefined && object.exist !== null) {\n      message.exist = exports.CompressedExistenceProof.fromPartial(object.exist);\n    } else {\n      message.exist = undefined;\n    }\n    if (object.nonexist !== undefined && object.nonexist !== null) {\n      message.nonexist = exports.CompressedNonExistenceProof.fromPartial(object.nonexist);\n    } else {\n      message.nonexist = undefined;\n    }\n    return message;\n  }\n};\nconst baseCompressedExistenceProof = {\n  path: 0\n};\nexports.CompressedExistenceProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.value.length !== 0) {\n      writer.uint32(18).bytes(message.value);\n    }\n    if (message.leaf !== undefined) {\n      exports.LeafOp.encode(message.leaf, writer.uint32(26).fork()).ldelim();\n    }\n    writer.uint32(34).fork();\n    for (const v of message.path) {\n      writer.int32(v);\n    }\n    writer.ldelim();\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCompressedExistenceProof);\n    message.path = [];\n    message.key = new Uint8Array();\n    message.value = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.value = reader.bytes();\n          break;\n        case 3:\n          message.leaf = exports.LeafOp.decode(reader, reader.uint32());\n          break;\n        case 4:\n          if ((tag & 7) === 2) {\n            const end2 = reader.uint32() + reader.pos;\n            while (reader.pos < end2) {\n              message.path.push(reader.int32());\n            }\n          } else {\n            message.path.push(reader.int32());\n          }\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseCompressedExistenceProof);\n    message.path = [];\n    message.key = new Uint8Array();\n    message.value = new Uint8Array();\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = bytesFromBase64(object.value);\n    }\n    if (object.leaf !== undefined && object.leaf !== null) {\n      message.leaf = exports.LeafOp.fromJSON(object.leaf);\n    } else {\n      message.leaf = undefined;\n    }\n    if (object.path !== undefined && object.path !== null) {\n      for (const e of object.path) {\n        message.path.push(Number(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.value !== undefined && (obj.value = base64FromBytes(message.value !== undefined ? message.value : new Uint8Array()));\n    message.leaf !== undefined && (obj.leaf = message.leaf ? exports.LeafOp.toJSON(message.leaf) : undefined);\n    if (message.path) {\n      obj.path = message.path.map(e => e);\n    } else {\n      obj.path = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseCompressedExistenceProof);\n    message.path = [];\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n    if (object.value !== undefined && object.value !== null) {\n      message.value = object.value;\n    } else {\n      message.value = new Uint8Array();\n    }\n    if (object.leaf !== undefined && object.leaf !== null) {\n      message.leaf = exports.LeafOp.fromPartial(object.leaf);\n    } else {\n      message.leaf = undefined;\n    }\n    if (object.path !== undefined && object.path !== null) {\n      for (const e of object.path) {\n        message.path.push(e);\n      }\n    }\n    return message;\n  }\n};\nconst baseCompressedNonExistenceProof = {};\nexports.CompressedNonExistenceProof = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.key.length !== 0) {\n      writer.uint32(10).bytes(message.key);\n    }\n    if (message.left !== undefined) {\n      exports.CompressedExistenceProof.encode(message.left, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.right !== undefined) {\n      exports.CompressedExistenceProof.encode(message.right, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCompressedNonExistenceProof);\n    message.key = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.key = reader.bytes();\n          break;\n        case 2:\n          message.left = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.right = exports.CompressedExistenceProof.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseCompressedNonExistenceProof);\n    message.key = new Uint8Array();\n    if (object.key !== undefined && object.key !== null) {\n      message.key = bytesFromBase64(object.key);\n    }\n    if (object.left !== undefined && object.left !== null) {\n      message.left = exports.CompressedExistenceProof.fromJSON(object.left);\n    } else {\n      message.left = undefined;\n    }\n    if (object.right !== undefined && object.right !== null) {\n      message.right = exports.CompressedExistenceProof.fromJSON(object.right);\n    } else {\n      message.right = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.key !== undefined && (obj.key = base64FromBytes(message.key !== undefined ? message.key : new Uint8Array()));\n    message.left !== undefined && (obj.left = message.left ? exports.CompressedExistenceProof.toJSON(message.left) : undefined);\n    message.right !== undefined && (obj.right = message.right ? exports.CompressedExistenceProof.toJSON(message.right) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseCompressedNonExistenceProof);\n    if (object.key !== undefined && object.key !== null) {\n      message.key = object.key;\n    } else {\n      message.key = new Uint8Array();\n    }\n    if (object.left !== undefined && object.left !== null) {\n      message.left = exports.CompressedExistenceProof.fromPartial(object.left);\n    } else {\n      message.left = undefined;\n    }\n    if (object.right !== undefined && object.right !== null) {\n      message.right = exports.CompressedExistenceProof.fromPartial(object.right);\n    } else {\n      message.right = undefined;\n    }\n    return message;\n  }\n};\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=proofs.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}