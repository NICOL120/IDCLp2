{"ast":null,"code":"\"use strict\";\n\nvar __extends = this && this.__extends || function () {\n  var extendStatics = function (d, b) {\n    extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ValConsPublicKey = exports.LegacyAminoMultisigPublicKey = exports.SimplePublicKey = exports.PublicKey = void 0;\nvar json_1 = require(\"../util/json\");\nvar hash_1 = require(\"../util/hash\");\nvar keys_1 = require(\"@terra-money/terra.proto/cosmos/crypto/multisig/keys\");\nvar any_1 = require(\"@terra-money/terra.proto/google/protobuf/any\");\nvar keys_2 = require(\"@terra-money/terra.proto/cosmos/crypto/secp256k1/keys\");\nvar keys_3 = require(\"@terra-money/terra.proto/cosmos/crypto/ed25519/keys\");\nvar bech32_1 = require(\"bech32\");\n// As discussed in https://github.com/binance-chain/javascript-sdk/issues/163\n// Prefixes listed here: https://github.com/tendermint/tendermint/blob/d419fffe18531317c28c29a292ad7d253f6cafdf/docs/spec/blockchain/encoding.md#public-key-cryptography\n// Last bytes is varint-encoded length prefix\nvar pubkeyAminoPrefixSecp256k1 = Buffer.from('eb5ae987' + '21' /* fixed length */, 'hex');\nvar pubkeyAminoPrefixEd25519 = Buffer.from('1624de64' + '20' /* fixed length */, 'hex');\n/** See https://github.com/tendermint/tendermint/commit/38b401657e4ad7a7eeb3c30a3cbf512037df3740 */\nvar pubkeyAminoPrefixMultisigThreshold = Buffer.from('22c1f7e2' /* variable length not included */, 'hex');\nvar encodeUvarint = function (value) {\n  var checked = Number.parseInt(value.toString());\n  if (checked > 127) {\n    throw new Error('Encoding numbers > 127 is not supported here. Please tell those lazy CosmJS maintainers to port the binary.PutUvarint implementation from the Go standard library and write some tests.');\n  }\n  return [checked];\n};\nvar PublicKey;\n(function (PublicKey) {\n  function fromAmino(data) {\n    switch (data.type) {\n      case 'tendermint/PubKeySecp256k1':\n        return SimplePublicKey.fromAmino(data);\n      case 'tendermint/PubKeyMultisigThreshold':\n        return LegacyAminoMultisigPublicKey.fromAmino(data);\n      case 'tendermint/PubKeyEd25519':\n        return ValConsPublicKey.fromAmino(data);\n    }\n  }\n  PublicKey.fromAmino = fromAmino;\n  function fromData(data) {\n    switch (data['@type']) {\n      case '/cosmos.crypto.secp256k1.PubKey':\n        return SimplePublicKey.fromData(data);\n      case '/cosmos.crypto.multisig.LegacyAminoPubKey':\n        return LegacyAminoMultisigPublicKey.fromData(data);\n      case '/cosmos.crypto.ed25519.PubKey':\n        return ValConsPublicKey.fromData(data);\n    }\n  }\n  PublicKey.fromData = fromData;\n  function fromProto(pubkeyAny) {\n    var typeUrl = pubkeyAny.typeUrl;\n    if (typeUrl === '/cosmos.crypto.secp256k1.PubKey') {\n      return SimplePublicKey.unpackAny(pubkeyAny);\n    } else if (typeUrl === '/cosmos.crypto.multisig.LegacyAminoPubKey') {\n      return LegacyAminoMultisigPublicKey.unpackAny(pubkeyAny);\n    } else if (typeUrl === '/cosmos.crypto.ed25519.PubKey') {\n      return ValConsPublicKey.unpackAny(pubkeyAny);\n    }\n    throw new Error(\"Pubkey type \".concat(typeUrl, \" not recognized\"));\n  }\n  PublicKey.fromProto = fromProto;\n})(PublicKey = exports.PublicKey || (exports.PublicKey = {}));\nvar SimplePublicKey = /** @class */function (_super) {\n  __extends(SimplePublicKey, _super);\n  function SimplePublicKey(key) {\n    var _this = _super.call(this) || this;\n    _this.key = key;\n    return _this;\n  }\n  SimplePublicKey.fromAmino = function (data) {\n    return new SimplePublicKey(data.value);\n  };\n  SimplePublicKey.prototype.toAmino = function () {\n    return {\n      type: 'tendermint/PubKeySecp256k1',\n      value: this.key\n    };\n  };\n  SimplePublicKey.fromData = function (data) {\n    return new SimplePublicKey(data.key);\n  };\n  SimplePublicKey.prototype.toData = function () {\n    return {\n      '@type': '/cosmos.crypto.secp256k1.PubKey',\n      key: this.key\n    };\n  };\n  SimplePublicKey.fromProto = function (pubkeyProto) {\n    return new SimplePublicKey(Buffer.from(pubkeyProto.key).toString('base64'));\n  };\n  SimplePublicKey.prototype.toProto = function () {\n    return keys_2.PubKey.fromPartial({\n      key: Buffer.from(this.key, 'base64')\n    });\n  };\n  SimplePublicKey.prototype.packAny = function () {\n    return any_1.Any.fromPartial({\n      typeUrl: '/cosmos.crypto.secp256k1.PubKey',\n      value: keys_2.PubKey.encode(this.toProto()).finish()\n    });\n  };\n  SimplePublicKey.unpackAny = function (pubkeyAny) {\n    return SimplePublicKey.fromProto(keys_2.PubKey.decode(pubkeyAny.value));\n  };\n  SimplePublicKey.prototype.encodeAminoPubkey = function () {\n    return Buffer.concat([pubkeyAminoPrefixSecp256k1, Buffer.from(this.key, 'base64')]);\n  };\n  SimplePublicKey.prototype.rawAddress = function () {\n    var pubkeyData = Buffer.from(this.key, 'base64');\n    return (0, hash_1.ripemd160)((0, hash_1.sha256)(pubkeyData));\n  };\n  SimplePublicKey.prototype.address = function () {\n    return bech32_1.bech32.encode('terra', bech32_1.bech32.toWords(this.rawAddress()));\n  };\n  SimplePublicKey.prototype.pubkeyAddress = function () {\n    return bech32_1.bech32.encode('terrapub', bech32_1.bech32.toWords(this.encodeAminoPubkey()));\n  };\n  return SimplePublicKey;\n}(json_1.JSONSerializable);\nexports.SimplePublicKey = SimplePublicKey;\nvar LegacyAminoMultisigPublicKey = /** @class */function (_super) {\n  __extends(LegacyAminoMultisigPublicKey, _super);\n  function LegacyAminoMultisigPublicKey(threshold, pubkeys) {\n    var _this = _super.call(this) || this;\n    _this.threshold = threshold;\n    _this.pubkeys = pubkeys;\n    return _this;\n  }\n  LegacyAminoMultisigPublicKey.prototype.encodeAminoPubkey = function () {\n    var out = Array.from(pubkeyAminoPrefixMultisigThreshold);\n    out.push(0x08);\n    out.push.apply(out, encodeUvarint(this.threshold));\n    for (var _i = 0, _a = this.pubkeys.map(function (p) {\n        return p.encodeAminoPubkey();\n      }); _i < _a.length; _i++) {\n      var pubkeyData = _a[_i];\n      out.push(0x12);\n      out.push.apply(out, encodeUvarint(pubkeyData.length));\n      out.push.apply(out, Array.from(pubkeyData));\n    }\n    return new Uint8Array(out);\n  };\n  LegacyAminoMultisigPublicKey.prototype.rawAddress = function () {\n    var pubkeyData = this.encodeAminoPubkey();\n    return (0, hash_1.sha256)(pubkeyData).slice(0, 20);\n  };\n  LegacyAminoMultisigPublicKey.prototype.address = function () {\n    return bech32_1.bech32.encode('terra', bech32_1.bech32.toWords(this.rawAddress()));\n  };\n  LegacyAminoMultisigPublicKey.prototype.pubkeyAddress = function () {\n    return bech32_1.bech32.encode('terrapub', bech32_1.bech32.toWords(this.encodeAminoPubkey()));\n  };\n  LegacyAminoMultisigPublicKey.fromAmino = function (data) {\n    return new LegacyAminoMultisigPublicKey(Number.parseInt(data.value.threshold), data.value.pubkeys.map(function (p) {\n      return SimplePublicKey.fromAmino(p);\n    }));\n  };\n  LegacyAminoMultisigPublicKey.prototype.toAmino = function () {\n    return {\n      type: 'tendermint/PubKeyMultisigThreshold',\n      value: {\n        threshold: this.threshold.toFixed(),\n        pubkeys: this.pubkeys.map(function (p) {\n          return p.toAmino();\n        })\n      }\n    };\n  };\n  LegacyAminoMultisigPublicKey.fromData = function (data) {\n    return new LegacyAminoMultisigPublicKey(Number.parseInt(data.threshold), data.public_keys.map(function (v) {\n      return SimplePublicKey.fromData(v);\n    }));\n  };\n  LegacyAminoMultisigPublicKey.prototype.toData = function () {\n    return {\n      '@type': '/cosmos.crypto.multisig.LegacyAminoPubKey',\n      threshold: this.threshold.toFixed(),\n      public_keys: this.pubkeys.map(function (p) {\n        return p.toData();\n      })\n    };\n  };\n  LegacyAminoMultisigPublicKey.fromProto = function (pubkeyProto) {\n    return new LegacyAminoMultisigPublicKey(pubkeyProto.threshold, pubkeyProto.publicKeys.map(function (v) {\n      return SimplePublicKey.unpackAny(v);\n    }));\n  };\n  LegacyAminoMultisigPublicKey.prototype.toProto = function () {\n    return keys_1.LegacyAminoPubKey.fromPartial({\n      threshold: this.threshold,\n      publicKeys: this.pubkeys.map(function (v) {\n        return v.packAny();\n      })\n    });\n  };\n  LegacyAminoMultisigPublicKey.prototype.packAny = function () {\n    return any_1.Any.fromPartial({\n      typeUrl: '/cosmos.crypto.multisig.LegacyAminoPubKey',\n      value: keys_1.LegacyAminoPubKey.encode(this.toProto()).finish()\n    });\n  };\n  LegacyAminoMultisigPublicKey.unpackAny = function (pubkeyAny) {\n    return LegacyAminoMultisigPublicKey.fromProto(keys_1.LegacyAminoPubKey.decode(pubkeyAny.value));\n  };\n  return LegacyAminoMultisigPublicKey;\n}(json_1.JSONSerializable);\nexports.LegacyAminoMultisigPublicKey = LegacyAminoMultisigPublicKey;\nvar ValConsPublicKey = /** @class */function (_super) {\n  __extends(ValConsPublicKey, _super);\n  function ValConsPublicKey(key) {\n    var _this = _super.call(this) || this;\n    _this.key = key;\n    return _this;\n  }\n  ValConsPublicKey.fromAmino = function (data) {\n    return new ValConsPublicKey(data.value);\n  };\n  ValConsPublicKey.prototype.toAmino = function () {\n    return {\n      type: 'tendermint/PubKeyEd25519',\n      value: this.key\n    };\n  };\n  ValConsPublicKey.fromData = function (data) {\n    return new ValConsPublicKey(data.key);\n  };\n  ValConsPublicKey.prototype.toData = function () {\n    return {\n      '@type': '/cosmos.crypto.ed25519.PubKey',\n      key: this.key\n    };\n  };\n  ValConsPublicKey.fromProto = function (pubkeyProto) {\n    return new ValConsPublicKey(Buffer.from(pubkeyProto.key).toString('base64'));\n  };\n  ValConsPublicKey.prototype.toProto = function () {\n    return keys_2.PubKey.fromPartial({\n      key: Buffer.from(this.key, 'base64')\n    });\n  };\n  ValConsPublicKey.prototype.packAny = function () {\n    return any_1.Any.fromPartial({\n      typeUrl: '/cosmos.crypto.ed25519.PubKey',\n      value: keys_3.PubKey.encode(this.toProto()).finish()\n    });\n  };\n  ValConsPublicKey.unpackAny = function (pubkeyAny) {\n    return ValConsPublicKey.fromProto(keys_3.PubKey.decode(pubkeyAny.value));\n  };\n  ValConsPublicKey.prototype.encodeAminoPubkey = function () {\n    return Buffer.concat([pubkeyAminoPrefixEd25519, Buffer.from(this.key, 'base64')]);\n  };\n  ValConsPublicKey.prototype.rawAddress = function () {\n    var pubkeyData = Buffer.from(this.key, 'base64');\n    return (0, hash_1.sha256)(pubkeyData).slice(0, 20);\n  };\n  ValConsPublicKey.prototype.address = function () {\n    return bech32_1.bech32.encode('terravalcons', bech32_1.bech32.toWords(this.rawAddress()));\n  };\n  ValConsPublicKey.prototype.pubkeyAddress = function () {\n    return bech32_1.bech32.encode('terravalconspub', bech32_1.bech32.toWords(this.encodeAminoPubkey()));\n  };\n  return ValConsPublicKey;\n}(json_1.JSONSerializable);\nexports.ValConsPublicKey = ValConsPublicKey;\n//# sourceMappingURL=PublicKey.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}