{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ExchangeRateTuple = exports.AggregateExchangeRateVote = exports.AggregateExchangeRatePrevote = exports.Denom = exports.Params = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nexports.protobufPackage = \"terra.oracle.v1beta1\";\nconst baseParams = {\n  votePeriod: long_1.default.UZERO,\n  voteThreshold: \"\",\n  rewardBand: \"\",\n  rewardDistributionWindow: long_1.default.UZERO,\n  slashFraction: \"\",\n  slashWindow: long_1.default.UZERO,\n  minValidPerWindow: \"\"\n};\nexports.Params = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.votePeriod.isZero()) {\n      writer.uint32(8).uint64(message.votePeriod);\n    }\n    if (message.voteThreshold !== \"\") {\n      writer.uint32(18).string(message.voteThreshold);\n    }\n    if (message.rewardBand !== \"\") {\n      writer.uint32(26).string(message.rewardBand);\n    }\n    if (!message.rewardDistributionWindow.isZero()) {\n      writer.uint32(32).uint64(message.rewardDistributionWindow);\n    }\n    for (const v of message.whitelist) {\n      exports.Denom.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    if (message.slashFraction !== \"\") {\n      writer.uint32(50).string(message.slashFraction);\n    }\n    if (!message.slashWindow.isZero()) {\n      writer.uint32(56).uint64(message.slashWindow);\n    }\n    if (message.minValidPerWindow !== \"\") {\n      writer.uint32(66).string(message.minValidPerWindow);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseParams);\n    message.whitelist = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.votePeriod = reader.uint64();\n          break;\n        case 2:\n          message.voteThreshold = reader.string();\n          break;\n        case 3:\n          message.rewardBand = reader.string();\n          break;\n        case 4:\n          message.rewardDistributionWindow = reader.uint64();\n          break;\n        case 5:\n          message.whitelist.push(exports.Denom.decode(reader, reader.uint32()));\n          break;\n        case 6:\n          message.slashFraction = reader.string();\n          break;\n        case 7:\n          message.slashWindow = reader.uint64();\n          break;\n        case 8:\n          message.minValidPerWindow = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseParams);\n    message.whitelist = [];\n    if (object.votePeriod !== undefined && object.votePeriod !== null) {\n      message.votePeriod = long_1.default.fromString(object.votePeriod);\n    } else {\n      message.votePeriod = long_1.default.UZERO;\n    }\n    if (object.voteThreshold !== undefined && object.voteThreshold !== null) {\n      message.voteThreshold = String(object.voteThreshold);\n    } else {\n      message.voteThreshold = \"\";\n    }\n    if (object.rewardBand !== undefined && object.rewardBand !== null) {\n      message.rewardBand = String(object.rewardBand);\n    } else {\n      message.rewardBand = \"\";\n    }\n    if (object.rewardDistributionWindow !== undefined && object.rewardDistributionWindow !== null) {\n      message.rewardDistributionWindow = long_1.default.fromString(object.rewardDistributionWindow);\n    } else {\n      message.rewardDistributionWindow = long_1.default.UZERO;\n    }\n    if (object.whitelist !== undefined && object.whitelist !== null) {\n      for (const e of object.whitelist) {\n        message.whitelist.push(exports.Denom.fromJSON(e));\n      }\n    }\n    if (object.slashFraction !== undefined && object.slashFraction !== null) {\n      message.slashFraction = String(object.slashFraction);\n    } else {\n      message.slashFraction = \"\";\n    }\n    if (object.slashWindow !== undefined && object.slashWindow !== null) {\n      message.slashWindow = long_1.default.fromString(object.slashWindow);\n    } else {\n      message.slashWindow = long_1.default.UZERO;\n    }\n    if (object.minValidPerWindow !== undefined && object.minValidPerWindow !== null) {\n      message.minValidPerWindow = String(object.minValidPerWindow);\n    } else {\n      message.minValidPerWindow = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.votePeriod !== undefined && (obj.votePeriod = (message.votePeriod || long_1.default.UZERO).toString());\n    message.voteThreshold !== undefined && (obj.voteThreshold = message.voteThreshold);\n    message.rewardBand !== undefined && (obj.rewardBand = message.rewardBand);\n    message.rewardDistributionWindow !== undefined && (obj.rewardDistributionWindow = (message.rewardDistributionWindow || long_1.default.UZERO).toString());\n    if (message.whitelist) {\n      obj.whitelist = message.whitelist.map(e => e ? exports.Denom.toJSON(e) : undefined);\n    } else {\n      obj.whitelist = [];\n    }\n    message.slashFraction !== undefined && (obj.slashFraction = message.slashFraction);\n    message.slashWindow !== undefined && (obj.slashWindow = (message.slashWindow || long_1.default.UZERO).toString());\n    message.minValidPerWindow !== undefined && (obj.minValidPerWindow = message.minValidPerWindow);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseParams);\n    message.whitelist = [];\n    if (object.votePeriod !== undefined && object.votePeriod !== null) {\n      message.votePeriod = object.votePeriod;\n    } else {\n      message.votePeriod = long_1.default.UZERO;\n    }\n    if (object.voteThreshold !== undefined && object.voteThreshold !== null) {\n      message.voteThreshold = object.voteThreshold;\n    } else {\n      message.voteThreshold = \"\";\n    }\n    if (object.rewardBand !== undefined && object.rewardBand !== null) {\n      message.rewardBand = object.rewardBand;\n    } else {\n      message.rewardBand = \"\";\n    }\n    if (object.rewardDistributionWindow !== undefined && object.rewardDistributionWindow !== null) {\n      message.rewardDistributionWindow = object.rewardDistributionWindow;\n    } else {\n      message.rewardDistributionWindow = long_1.default.UZERO;\n    }\n    if (object.whitelist !== undefined && object.whitelist !== null) {\n      for (const e of object.whitelist) {\n        message.whitelist.push(exports.Denom.fromPartial(e));\n      }\n    }\n    if (object.slashFraction !== undefined && object.slashFraction !== null) {\n      message.slashFraction = object.slashFraction;\n    } else {\n      message.slashFraction = \"\";\n    }\n    if (object.slashWindow !== undefined && object.slashWindow !== null) {\n      message.slashWindow = object.slashWindow;\n    } else {\n      message.slashWindow = long_1.default.UZERO;\n    }\n    if (object.minValidPerWindow !== undefined && object.minValidPerWindow !== null) {\n      message.minValidPerWindow = object.minValidPerWindow;\n    } else {\n      message.minValidPerWindow = \"\";\n    }\n    return message;\n  }\n};\nconst baseDenom = {\n  name: \"\",\n  tobinTax: \"\"\n};\nexports.Denom = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.name !== \"\") {\n      writer.uint32(10).string(message.name);\n    }\n    if (message.tobinTax !== \"\") {\n      writer.uint32(18).string(message.tobinTax);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDenom);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.name = reader.string();\n          break;\n        case 2:\n          message.tobinTax = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDenom);\n    if (object.name !== undefined && object.name !== null) {\n      message.name = String(object.name);\n    } else {\n      message.name = \"\";\n    }\n    if (object.tobinTax !== undefined && object.tobinTax !== null) {\n      message.tobinTax = String(object.tobinTax);\n    } else {\n      message.tobinTax = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.name !== undefined && (obj.name = message.name);\n    message.tobinTax !== undefined && (obj.tobinTax = message.tobinTax);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseDenom);\n    if (object.name !== undefined && object.name !== null) {\n      message.name = object.name;\n    } else {\n      message.name = \"\";\n    }\n    if (object.tobinTax !== undefined && object.tobinTax !== null) {\n      message.tobinTax = object.tobinTax;\n    } else {\n      message.tobinTax = \"\";\n    }\n    return message;\n  }\n};\nconst baseAggregateExchangeRatePrevote = {\n  hash: \"\",\n  voter: \"\",\n  submitBlock: long_1.default.UZERO\n};\nexports.AggregateExchangeRatePrevote = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.hash !== \"\") {\n      writer.uint32(10).string(message.hash);\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    if (!message.submitBlock.isZero()) {\n      writer.uint32(24).uint64(message.submitBlock);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseAggregateExchangeRatePrevote);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.hash = reader.string();\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        case 3:\n          message.submitBlock = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseAggregateExchangeRatePrevote);\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = String(object.hash);\n    } else {\n      message.hash = \"\";\n    }\n    if (object.voter !== undefined && object.voter !== null) {\n      message.voter = String(object.voter);\n    } else {\n      message.voter = \"\";\n    }\n    if (object.submitBlock !== undefined && object.submitBlock !== null) {\n      message.submitBlock = long_1.default.fromString(object.submitBlock);\n    } else {\n      message.submitBlock = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.hash !== undefined && (obj.hash = message.hash);\n    message.voter !== undefined && (obj.voter = message.voter);\n    message.submitBlock !== undefined && (obj.submitBlock = (message.submitBlock || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseAggregateExchangeRatePrevote);\n    if (object.hash !== undefined && object.hash !== null) {\n      message.hash = object.hash;\n    } else {\n      message.hash = \"\";\n    }\n    if (object.voter !== undefined && object.voter !== null) {\n      message.voter = object.voter;\n    } else {\n      message.voter = \"\";\n    }\n    if (object.submitBlock !== undefined && object.submitBlock !== null) {\n      message.submitBlock = object.submitBlock;\n    } else {\n      message.submitBlock = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nconst baseAggregateExchangeRateVote = {\n  voter: \"\"\n};\nexports.AggregateExchangeRateVote = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.exchangeRateTuples) {\n      exports.ExchangeRateTuple.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.voter !== \"\") {\n      writer.uint32(18).string(message.voter);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseAggregateExchangeRateVote);\n    message.exchangeRateTuples = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.exchangeRateTuples.push(exports.ExchangeRateTuple.decode(reader, reader.uint32()));\n          break;\n        case 2:\n          message.voter = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseAggregateExchangeRateVote);\n    message.exchangeRateTuples = [];\n    if (object.exchangeRateTuples !== undefined && object.exchangeRateTuples !== null) {\n      for (const e of object.exchangeRateTuples) {\n        message.exchangeRateTuples.push(exports.ExchangeRateTuple.fromJSON(e));\n      }\n    }\n    if (object.voter !== undefined && object.voter !== null) {\n      message.voter = String(object.voter);\n    } else {\n      message.voter = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.exchangeRateTuples) {\n      obj.exchangeRateTuples = message.exchangeRateTuples.map(e => e ? exports.ExchangeRateTuple.toJSON(e) : undefined);\n    } else {\n      obj.exchangeRateTuples = [];\n    }\n    message.voter !== undefined && (obj.voter = message.voter);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseAggregateExchangeRateVote);\n    message.exchangeRateTuples = [];\n    if (object.exchangeRateTuples !== undefined && object.exchangeRateTuples !== null) {\n      for (const e of object.exchangeRateTuples) {\n        message.exchangeRateTuples.push(exports.ExchangeRateTuple.fromPartial(e));\n      }\n    }\n    if (object.voter !== undefined && object.voter !== null) {\n      message.voter = object.voter;\n    } else {\n      message.voter = \"\";\n    }\n    return message;\n  }\n};\nconst baseExchangeRateTuple = {\n  denom: \"\",\n  exchangeRate: \"\"\n};\nexports.ExchangeRateTuple = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.denom !== \"\") {\n      writer.uint32(10).string(message.denom);\n    }\n    if (message.exchangeRate !== \"\") {\n      writer.uint32(18).string(message.exchangeRate);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseExchangeRateTuple);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.denom = reader.string();\n          break;\n        case 2:\n          message.exchangeRate = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseExchangeRateTuple);\n    if (object.denom !== undefined && object.denom !== null) {\n      message.denom = String(object.denom);\n    } else {\n      message.denom = \"\";\n    }\n    if (object.exchangeRate !== undefined && object.exchangeRate !== null) {\n      message.exchangeRate = String(object.exchangeRate);\n    } else {\n      message.exchangeRate = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.denom !== undefined && (obj.denom = message.denom);\n    message.exchangeRate !== undefined && (obj.exchangeRate = message.exchangeRate);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseExchangeRateTuple);\n    if (object.denom !== undefined && object.denom !== null) {\n      message.denom = object.denom;\n    } else {\n      message.denom = \"\";\n    }\n    if (object.exchangeRate !== undefined && object.exchangeRate !== null) {\n      message.exchangeRate = object.exchangeRate;\n    } else {\n      message.exchangeRate = \"\";\n    }\n    return message;\n  }\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=oracle.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}