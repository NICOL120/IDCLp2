{"ast":null,"code":"import { __awaiter, __decorate } from \"tslib\";\nimport { BLOCK_TIME } from './terrajs.service';\nimport { div, plus } from '../libs/math';\nimport { CONFIG } from '../consts/config';\nimport { defaultFarmConfig, FARM_INFO_SERVICE } from './farm_info/farm-info.service';\nimport { fromEntries } from '../libs/core';\nimport { memoize } from 'utils-decorators';\nimport { Denom } from '../consts/denom';\nimport { gql } from 'apollo-angular';\nimport { QueryBundler } from './querier-bundler';\nimport { fromBase64 } from '../libs/base64';\nimport { lp_balance_transform } from './calc/balance_calc';\nimport * as i0 from \"@angular/core\";\nimport * as i1 from \"./api/bank.service\";\nimport * as i2 from \"./api/gov.service\";\nimport * as i3 from \"./terrajs.service\";\nimport * as i4 from \"./api/astroport.service\";\nimport * as i5 from \"./api/astroport-factory.service\";\nimport * as i6 from \"./api/token.service\";\nimport * as i7 from \"../pipes/balance.pipe\";\nimport * as i8 from \"@angular/common/http\";\nimport * as i9 from \"./api/wallet.service\";\nimport * as i10 from \"apollo-angular\";\nimport * as i11 from \"./api/wasm.service\";\nimport * as i12 from \"./config.service\";\nconst HEIGHT_PER_YEAR = 365 * 24 * 60 * 60 * 1000 / BLOCK_TIME;\nconst ASTROPORT_PRICE_GQL = gql`\n        query price($address: String!) {\n          price(tokenAddress: $address) {\n            price_usd\n          }\n        }`;\nconst ASTROPORT_POOLS_GQL = gql`\n        query Query($limit: Int, $sortField: PoolSortFields) {\n          pools(limit: $limit, sortField: $sortField) {\n            lp_address\n            pool_address\n            token_symbol\n            trading_fee\n            pool_liquidity\n            _24hr_volume\n            trading_fees {\n              apy\n              apr\n              day\n            }\n            astro_rewards {\n              apy\n              apr\n              day\n            }\n            protocol_rewards {\n              apy\n              apr\n              day\n            }\n            total_rewards {\n              apy\n              apr\n              day\n            }\n            prices {\n              token1_address\n              token1_price_usd\n              token2_address\n              token2_price_usd\n            }\n            pool_type\n            reward_proxy_address\n          }\n        }`;\nexport const isNativeToken = input => {\n  return input.startsWith('u') || input.startsWith('ibc');\n};\nexport class InfoService {\n  constructor(bankService, farmInfos, gov, terrajs, astroport, astroportFactory, token, balancePipe, httpClient, wallet, apollo, wasm, config) {\n    this.bankService = bankService;\n    this.farmInfos = farmInfos;\n    this.gov = gov;\n    this.terrajs = terrajs;\n    this.astroport = astroport;\n    this.astroportFactory = astroportFactory;\n    this.token = token;\n    this.balancePipe = balancePipe;\n    this.httpClient = httpClient;\n    this.wallet = wallet;\n    this.apollo = apollo;\n    this.wasm = wasm;\n    this.config = config;\n    this.pairInfos = {};\n    this.tokenInfos = {};\n    this.ampStablePairs = {};\n    this.rewardInfos = {};\n    this.tokenBalances = {};\n    this.lpTokenBalances = {};\n    this.poolResponses = {};\n    this.poolDetails = [];\n    this.myTvl = 0;\n    this.allVaults = [];\n    this.compoundStat = {};\n    this.DISABLED_VAULTS = new Set([]);\n    try {\n      const infoSchemaVersion = localStorage.getItem('infoSchemaVersion');\n      if (infoSchemaVersion && +infoSchemaVersion >= 1) {\n        const poolJson = localStorage.getItem('poolInfos');\n        if (poolJson) {\n          this.poolInfos = JSON.parse(poolJson);\n        }\n        const pairJson = localStorage.getItem('pairInfos');\n        if (pairJson) {\n          this.pairInfos = JSON.parse(pairJson);\n        }\n        const statJson = localStorage.getItem('stat');\n        if (statJson) {\n          this.stat = JSON.parse(statJson);\n        }\n        const poolResponseJson = localStorage.getItem('poolResponses');\n        if (poolResponseJson) {\n          this.poolResponses = JSON.parse(poolResponseJson);\n        }\n        if (this.terrajs.isConnected) {\n          const rewardInfoJson = localStorage.getItem('rewardInfos');\n          if (rewardInfoJson) {\n            this.rewardInfos = JSON.parse(rewardInfoJson);\n          }\n        }\n        const tokenInfoJson = localStorage.getItem('tokenInfos');\n        if (tokenInfoJson) {\n          this.tokenInfos = JSON.parse(tokenInfoJson);\n        }\n        const ampStablePairsJson = localStorage.getItem('ampStablePairs');\n        if (ampStablePairsJson) {\n          this.ampStablePairs = JSON.parse(ampStablePairsJson);\n        }\n        const compoundStatJson = localStorage.getItem('compoundStat');\n        if (compoundStatJson) {\n          this.compoundStat = JSON.parse(compoundStatJson);\n        }\n      } else {\n        localStorage.removeItem('poolInfos');\n        localStorage.removeItem('pairInfos');\n        localStorage.removeItem('stat');\n        localStorage.removeItem('poolResponses');\n        localStorage.removeItem('rewardInfos');\n        localStorage.removeItem('tokenInfos');\n        localStorage.removeItem('ampStablePairs');\n        localStorage.removeItem('compoundStat');\n      }\n    } catch (e) {}\n  }\n  get SPEC_KEY() {\n    return `Astroport|${this.terrajs.settings.specToken}|${this.terrajs.settings.axlUsdcToken}`;\n  }\n  get USDC_LUNA_KEY() {\n    return `Astroport|${this.terrajs.settings.axlUsdcToken}|${Denom.LUNA}`;\n  }\n  shouldEnableFarmInfo(farmInfo) {\n    return farmInfo.availableNetworks.has(this.terrajs.networkName);\n    // && (farmInfo.farmContract.length > 0 && farmInfo.baseTokenContract.length > 0 && farmInfo.denomTokenContract.length > 0); // for check farm setup validity\n  }\n\n  refreshBalance(opt) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.terrajs.isConnected) {\n        return;\n      }\n      const tasks = [];\n      // if (opt.spec) {\n      //   const task = this.token.balance(this.terrajs.settings.specToken)\n      //     .then(it => this.userSpecAmount = div(it.balance, CONFIG.UNIT));\n      //   tasks.push(task);\n      // }\n      // if (opt.lp) {\n      //   const task = this.token.balance(this.terrajs.settings.specLpToken)\n      //     .then(it => this.userSpecLpAmount = div(it.balance, CONFIG.UNIT));\n      //   tasks.push(task);\n      // }\n      if (opt.native_token) {\n        tasks.push(this.refreshNativeTokens());\n      }\n      yield Promise.all(tasks);\n    });\n  }\n  refreshNativeTokens() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const it = yield this.bankService.balances();\n      for (const coin of it.toArray()) {\n        this.tokenBalances[coin.denom] = (_a = coin.amount.toString()) !== null && _a !== void 0 ? _a : '0';\n      }\n      if (!this.tokenBalances[Denom.LUNA] || !it.toArray().find(coin => coin.denom === Denom.LUNA)) {\n        this.tokenBalances[Denom.LUNA] = '0';\n      }\n      if (this.terrajs.isMainnet) {\n        if (!this.tokenBalances[this.terrajs.settings.axlUsdcToken] || !it.toArray().find(coin => coin.denom === this.terrajs.settings.axlUsdcToken)) {\n          this.tokenBalances[this.terrajs.settings.axlUsdcToken] = '0';\n        }\n        if (!this.tokenBalances[this.terrajs.settings.axlUsdtToken] || !it.toArray().find(coin => coin.denom === this.terrajs.settings.axlUsdtToken)) {\n          this.tokenBalances[this.terrajs.settings.axlUsdtToken] = '0';\n        }\n      }\n    });\n  }\n  refreshSPECPool() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO until SPEC is live\n      // this.specPoolInfo = await this.astroport.query(this.terrajs.settings.specPool, {pool: {}});\n      // this.specPrice = div(this.specPoolInfo.assets[1].amount, this.specPoolInfo.assets[0].amount);\n    });\n  }\n  ensurePoolInfoLoaded() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (this.poolInfos && this.loadedNetwork === this.terrajs.settings.chainID) {\n        return this.poolInfos;\n      }\n      yield this.refreshPoolInfos();\n      this.loadedNetwork = this.terrajs.settings.chainID;\n    });\n  }\n  getRewardTokenContracts(poolAPRs) {\n    return poolAPRs.map(poolAPR => poolAPR.rewardContract);\n  }\n  refreshPoolInfos() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const poolInfos = {};\n      for (const farmInfo of this.farmInfos) {\n        if (!this.shouldEnableFarmInfo(farmInfo)) {\n          continue;\n        }\n        const key = farmInfo.farmType === 'LP' ? `${farmInfo.dex}|${farmInfo.baseTokenContract}|${farmInfo.denomTokenContract}` : `${farmInfo.baseTokenContract}`;\n        let farmConfig;\n        if (farmInfo.getConfig) {\n          farmConfig = yield farmInfo.getConfig();\n        } else {\n          farmConfig = defaultFarmConfig;\n        }\n        const forceDepositType = farmInfo.farmContract === this.terrajs.settings.specFarm ? 'speclp' : 'compound';\n        poolInfos[key] = {\n          key,\n          farm: farmInfo.farm,\n          farmContract: farmInfo.farmContract,\n          baseTokenContract: farmInfo.baseTokenContract,\n          denomTokenContract: farmInfo.denomTokenContract,\n          rewardTokenContracts: this.poolAprsToRewardTokenContracts(farmInfo.poolAprs),\n          forceDepositType,\n          auditWarning: farmInfo.auditWarning,\n          farmType: (_a = farmInfo.farmType) !== null && _a !== void 0 ? _a : 'LP',\n          score: farmInfo.highlight ? 1000000 : 0,\n          dex: farmInfo.dex,\n          highlight: farmInfo.highlight,\n          notUseAstroportGqlApr: farmInfo.notUseAstroportGqlApr,\n          farmConfig,\n          compoundProxyContract: farmInfo.compoundProxyContract,\n          poolType: farmInfo.poolType,\n          disabled: farmInfo.disabled ? farmInfo.disabled : false\n        };\n      }\n      localStorage.setItem('poolInfos', JSON.stringify(poolInfos));\n      this.poolInfos = poolInfos;\n    });\n  }\n  poolAprsToRewardTokenContracts(poolAprs) {\n    return poolAprs.map(poolApr => poolApr.rewardContract);\n  }\n  ensurePairInfos() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensurePoolInfoLoaded();\n      const bundler = new QueryBundler(this.wasm);\n      const tasks = [];\n      for (const key of Object.keys(this.poolInfos)) {\n        if (this.pairInfos[key]) {\n          continue;\n        }\n        let pairInfoKey;\n        const baseTokenContract = this.poolInfos[key].baseTokenContract;\n        const denomTokenContract = this.poolInfos[key].denomTokenContract;\n        if (this.poolInfos[key].farmType === 'LP') {\n          pairInfoKey = key;\n        } else {\n          continue;\n        }\n        const tokenA = isNativeToken(baseTokenContract) ? {\n          native_token: {\n            denom: baseTokenContract\n          }\n        } : {\n          token: {\n            contract_addr: baseTokenContract\n          }\n        };\n        const tokenB = isNativeToken(denomTokenContract) ? {\n          native_token: {\n            denom: denomTokenContract\n          }\n        } : {\n          token: {\n            contract_addr: denomTokenContract\n          }\n        };\n        let factory;\n        if (this.poolInfos[key].dex === 'Astroport') {\n          factory = this.terrajs.settings.astroportFactory;\n        } else {\n          continue;\n        }\n        const task = bundler.query(factory, {\n          pair: {\n            asset_infos: [tokenA, tokenB]\n          }\n        }).then(value => this.pairInfos[pairInfoKey] = value);\n        tasks.push(task);\n      }\n      if (tasks.length) {\n        bundler.flush();\n        yield Promise.all(tasks);\n        localStorage.setItem('pairInfos', JSON.stringify(this.pairInfos));\n      }\n    });\n  }\n  ensureAmpStablePairs() {\n    var _a;\n    return __awaiter(this, void 0, void 0, function* () {\n      const pairInfoKeys = Object.keys(this.pairInfos);\n      const tasks = [];\n      const bundler = new QueryBundler(this.wasm);\n      for (const pairInfoKey of pairInfoKeys) {\n        const pairInfo = this.pairInfos[pairInfoKey];\n        if ((_a = pairInfo.pair_type) === null || _a === void 0 ? void 0 : _a['stable']) {\n          const task = bundler.query(pairInfo.contract_addr, {\n            config: {}\n          }).then(value => {\n            try {\n              const params = fromBase64(value.params);\n              this.ampStablePairs[pairInfoKey] = params.amp;\n            } catch (e) {\n              console.error('ensureAmpStablePairs', pairInfo, e);\n            }\n          });\n          tasks.push(task);\n        }\n      }\n      if (tasks.length) {\n        bundler.flush();\n        yield Promise.all(tasks);\n        localStorage.setItem('ampStablePairs', JSON.stringify(this.ampStablePairs));\n      }\n    });\n  }\n  ensureTokenInfos() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensurePoolInfoLoaded();\n      const cw20Tokens = new Set();\n      const bundler = new QueryBundler(this.wasm);\n      const tasks = [];\n      for (const key of Object.keys(this.poolInfos)) {\n        const baseTokenContract = this.poolInfos[key].baseTokenContract;\n        const denomTokenContract = this.poolInfos[key].denomTokenContract;\n        const rewardTokenContracts = this.poolInfos[key].rewardTokenContracts;\n        if (baseTokenContract && !isNativeToken(baseTokenContract)) {\n          cw20Tokens.add(baseTokenContract);\n        }\n        if (denomTokenContract && !isNativeToken(denomTokenContract)) {\n          cw20Tokens.add(denomTokenContract);\n        }\n        rewardTokenContracts.forEach(rewardTokenContract => {\n          if (!isNativeToken(rewardTokenContract)) {\n            cw20Tokens.add(rewardTokenContract);\n          }\n        });\n      }\n      for (const key of cw20Tokens) {\n        if (this.tokenInfos[key]) {\n          continue;\n        }\n        const task = bundler.query(key, {\n          token_info: {}\n        }).then(it => this.tokenInfos[key] = {\n          name: it.name,\n          symbol: this.cleanSymbol(it.symbol),\n          decimals: it.decimals,\n          unit: Math.pow(10, it.decimals)\n        });\n        tasks.push(task);\n      }\n      if (tasks.length) {\n        bundler.flush();\n        yield Promise.all(tasks);\n        localStorage.setItem('tokenInfos', JSON.stringify(this.tokenInfos));\n      }\n    });\n  }\n  refreshStat() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const stat = {\n        pairs: {},\n        vaultFee: 0,\n        tvl: '0',\n        govStaked: '0',\n        govTvl: '0',\n        govApr: 0,\n        govPoolCount: 1\n      };\n      // const vaultsTask = this.gov.vaults();\n      yield this.refreshPoolInfos();\n      yield Promise.all([this.refreshPoolResponses(), this.ensureAstroportData().catch(_ => {})]);\n      const vaults = null; // await vaultsTask; TODO\n      const tasks = this.farmInfos.filter(farmInfo => this.shouldEnableFarmInfo(farmInfo)).map(farmInfo => __awaiter(this, void 0, void 0, function* () {\n        var _a, _b, _c, _d;\n        const farmPoolInfos = fromEntries(Object.entries(this.poolInfos).filter(it => it[1].farmContract === farmInfo.farmContract));\n        try {\n          if (farmInfo.contractOnNetwork !== this.terrajs.networkName) {\n            farmInfo.refreshContractOnNetwork();\n          }\n          const pairStats = yield farmInfo.queryPairStats(farmPoolInfos, this.poolResponses, vaults, this.pairInfos, this.tokenInfos, this.ulunaUSDPrice, this.ampStablePairs);\n          const keys = Object.keys(pairStats);\n          for (const key of keys) {\n            const farmConfig = ((_a = this.poolInfos[key]) === null || _a === void 0 ? void 0 : _a.farmConfig) || defaultFarmConfig;\n            const totalFee = +farmConfig.controller_fee + +farmConfig.platform_fee + +farmConfig.community_fee;\n            if (farmInfo.dex === 'Astroport' && farmInfo.farmType === 'LP') {\n              const found = this.astroportPoolsData.pools.find(pool => {\n                var _a;\n                return (pool === null || pool === void 0 ? void 0 : pool.pool_address) === ((_a = this.pairInfos[key]) === null || _a === void 0 ? void 0 : _a.contract_addr);\n              });\n              if (farmInfo.notUseAstroportGqlApr) {\n                const pair = pairStats[key];\n                const poolAprTotal = this.getPoolAprTotal(pair);\n                const proxyAndAstroApy = Math.pow(poolAprTotal * (1 - totalFee) / CONFIG.COMPOUND_TIMES_PER_YEAR + 1, CONFIG.COMPOUND_TIMES_PER_YEAR) - 1;\n                const foundTradingFeeApy = +((_b = found === null || found === void 0 ? void 0 : found.trading_fees) === null || _b === void 0 ? void 0 : _b.apy) || 0;\n                pair.tradeApy = foundTradingFeeApy;\n                pair.poolApy = proxyAndAstroApy > 0 ? (proxyAndAstroApy + 1) * (foundTradingFeeApy + 1) - 1 : 0;\n                pair.dpr = this.getPoolAprTotal(pair) * (1 - totalFee) / 365;\n              } else {\n                // to prevent set pairStat undefined in case of no data available from Astroport api\n                if (found) {\n                  const pair = pairStats[key];\n                  const foundTokenSymbol = found.token_symbol;\n                  const poolAprAstro = pair.poolAprs.find(poolAPR => poolAPR.rewardContract === this.terrajs.settings.astroToken);\n                  if (poolAprAstro && ((_c = found === null || found === void 0 ? void 0 : found.astro_rewards) === null || _c === void 0 ? void 0 : _c.apr)) {\n                    poolAprAstro.apr = +found.astro_rewards.apr;\n                  }\n                  if (foundTokenSymbol) {\n                    this.findPoolAPRBySymbol(pair, foundTokenSymbol).apr = +found.protocol_rewards.apr;\n                  } else if (!foundTokenSymbol && +found.protocol_rewards.apr > 0) {\n                    let symbol = 'UNKNOWN_TOKEN';\n                    this.poolInfos[key].rewardTokenContracts.forEach(rewardTokenContract => {\n                      if (rewardTokenContract !== this.terrajs.settings.astroToken && symbol === 'UNKNOWN_TOKEN') {\n                        symbol = this.tokenInfos[rewardTokenContract].symbol;\n                      }\n                    });\n                    this.findPoolAPRBySymbol(pair, symbol).apr = +found.protocol_rewards.apr;\n                  }\n                  const proxyAndAstroApy = Math.pow((+found.protocol_rewards.apr + +found.astro_rewards.apr) * (1 - totalFee) / CONFIG.COMPOUND_TIMES_PER_YEAR + 1, CONFIG.COMPOUND_TIMES_PER_YEAR) - 1;\n                  pair.poolApy = proxyAndAstroApy > 0 ? (proxyAndAstroApy + 1) * (+found.trading_fees.apy + 1) - 1 : 0;\n                  pair.tradeApy = +((_d = found === null || found === void 0 ? void 0 : found.trading_fees) === null || _d === void 0 ? void 0 : _d.apy) || 0;\n                  const poolAprTotal = this.getPoolAprTotal(pair);\n                  pair.vaultFee = +pair.tvl * poolAprTotal * totalFee;\n                  pair.dpr = poolAprTotal * (1 - totalFee) / 365;\n                }\n              }\n            }\n            if (farmInfo.dex === 'Terraswap' && farmInfo.farmType === 'LP') {\n              // supported only in backend\n            }\n          }\n          Object.assign(stat.pairs, pairStats);\n        } catch (e) {\n          console.error('queryPairStats error >> ', e);\n          if (!this.stat) {\n            throw e;\n          }\n          for (const key of Object.keys(this.stat.pairs)) {\n            if (!stat.pairs[key]) {\n              stat.pairs[key] = this.stat.pairs[key];\n            }\n          }\n        }\n      }));\n      yield Promise.all([this.refreshGovStat(stat), this.refreshMarketCap(), ...tasks]);\n      // TODO once gov is live\n      // const config = await this.gov.config();\n      // const totalWeight = Object.keys(stat.pairs)\n      //   .map(key => stat.pairs[key].multiplier)\n      //   .reduce((a, b) => a + b, 0);\n      // const height = await this.terrajs.getHeight();\n      // const specPerHeight = config.mint_end > height ? config.mint_per_block : '0';\n      // const ustPerYear = +specPerHeight * HEIGHT_PER_YEAR * +this.specPrice\n      //   * (1 - (+config.burnvault_ratio || 0))\n      //   * (1 - +config.warchest_ratio);\n      for (const pair of Object.values(stat.pairs)) {\n        stat.vaultFee += pair.vaultFee;\n        stat.tvl = plus(stat.tvl, pair.tvl);\n      }\n      stat.govApr = 0; // stat.vaultFee / stat.govPoolCount / +stat.govTvl;\n      // TODO USDC in gov\n      // stat.tvl = plus(stat.tvl, austValue);\n      this.stat = stat;\n      localStorage.setItem('stat', JSON.stringify(stat));\n    });\n  }\n  refreshRewardInfos() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const rewardInfos = {};\n      const bundler = new QueryBundler(this.wasm, 8);\n      const tasks = [];\n      const BUNDLER_BLACKLIST = new Set([]);\n      const processRewards = (farmInfo, reward) => {\n        if (farmInfo.farmContract === this.terrajs.settings.specFarm) {\n          reward['stake_bond_amount'] = reward.bond_amount;\n        }\n        if (farmInfo.farmType === 'LP') {\n          rewardInfos[`${farmInfo.dex}|${farmInfo.baseTokenContract}|${farmInfo.denomTokenContract}`] = Object.assign(Object.assign({}, reward), {\n            farm: farmInfo.farm,\n            farmContract: farmInfo.farmContract\n          });\n        }\n      };\n      for (const farmInfo of this.farmInfos) {\n        if (!this.shouldEnableFarmInfo(farmInfo)) {\n          continue;\n        }\n        if (farmInfo.contractOnNetwork !== this.terrajs.networkName) {\n          farmInfo.refreshContractOnNetwork();\n        }\n        if (!farmInfo.farmContract) {\n          continue;\n        }\n        let task;\n        if (BUNDLER_BLACKLIST.has(farmInfo.farmContract)) {\n          task = farmInfo.queryReward().then(reward => processRewards(farmInfo, reward));\n        } else {\n          task = bundler.query(farmInfo.farmContract, {\n            reward_info: {\n              staker_addr: this.terrajs.address\n            }\n          }).then(({\n            reward_info: reward\n          }) => processRewards(farmInfo, reward));\n        }\n        tasks.push(task);\n      }\n      bundler.flush();\n      yield Promise.all(tasks);\n      this.rewardInfos = rewardInfos;\n      localStorage.setItem('rewardInfos', JSON.stringify(rewardInfos));\n    });\n  }\n  refreshTokenBalance(assetToken) {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (isNativeToken(assetToken)) {\n        yield this.refreshNativeTokens();\n      } else {\n        this.tokenBalances[assetToken] = (yield this.token.balance(assetToken)).balance;\n      }\n    });\n  }\n  refreshPoolResponse(key) {\n    return __awaiter(this, void 0, void 0, function* () {\n      const pairInfo = this.pairInfos[key];\n      const [dex, base, denom] = key.split('|');\n      const bundler = new QueryBundler(this.wasm);\n      const tasks = [];\n      const balanceQuery = {\n        balance: {\n          address: this.terrajs.address\n        }\n      };\n      if (!isNativeToken(base)) {\n        tasks.push(bundler.query(base, balanceQuery).then(it => this.tokenBalances[base] = it.balance));\n      } else {\n        tasks.push(this.refreshNativeTokens());\n      }\n      if (!isNativeToken(denom)) {\n        tasks.push(bundler.query(denom, balanceQuery).then(it => this.tokenBalances[denom] = it.balance));\n      } else {\n        tasks.push(this.refreshNativeTokens());\n      }\n      tasks.push(bundler.query(pairInfo.contract_addr, {\n        pool: {}\n      }).then(it => this.poolResponses[key] = it));\n      tasks.push(bundler.query(pairInfo.liquidity_token, balanceQuery).then(it => this.lpTokenBalances[pairInfo.liquidity_token] = it.balance));\n      bundler.flush();\n      yield Promise.all(tasks);\n    });\n  }\n  refreshPoolResponses() {\n    var _a, _b;\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.ensurePairInfos();\n      yield this.ensureAmpStablePairs();\n      const poolResponses = {};\n      const bundler = new QueryBundler(this.wasm);\n      const poolTasks = [];\n      for (const key of Object.keys(this.poolInfos)) {\n        let poolResponseKey;\n        const dex = this.poolInfos[key].dex;\n        if (this.poolInfos[key].farmType === 'LP') {\n          poolResponseKey = key;\n        }\n        const pairInfo = this.pairInfos[poolResponseKey];\n        poolTasks.push(bundler.query(pairInfo.contract_addr, {\n          pool: {}\n        }).then(it => poolResponses[poolResponseKey] = it));\n      }\n      bundler.flush();\n      yield Promise.all(poolTasks).catch(error => console.error('refreshPoolResponses error: ', error));\n      this.poolResponses = poolResponses;\n      localStorage.setItem('poolResponses', JSON.stringify(poolResponses));\n      if (this.terrajs.isMainnet) {\n        const pool = this.poolResponses[this.USDC_LUNA_KEY];\n        if (pool) {\n          const axlUsdcAmount = ((_a = pool.assets.find(asset => {\n            var _a, _b;\n            return ((_b = (_a = asset === null || asset === void 0 ? void 0 : asset.info) === null || _a === void 0 ? void 0 : _a.native_token) === null || _b === void 0 ? void 0 : _b['denom']) === this.terrajs.settings.axlUsdcToken;\n          })) === null || _a === void 0 ? void 0 : _a.amount) || 0;\n          const ulunaAmount = ((_b = pool.assets.find(asset => {\n            var _a, _b;\n            return ((_b = (_a = asset === null || asset === void 0 ? void 0 : asset.info) === null || _a === void 0 ? void 0 : _a.native_token) === null || _b === void 0 ? void 0 : _b['denom']) === Denom.LUNA;\n          })) === null || _b === void 0 ? void 0 : _b.amount) || 0;\n          this.ulunaUSDPrice = +div(axlUsdcAmount, ulunaAmount);\n        }\n      }\n    });\n  }\n  refreshCirculation() {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO once SPEC is live\n      // testnet_only doesn't have burnvault\n      // if (this.terrajs.network?.name === 'testnet') {\n      //   const task1 = this.token.query(this.terrajs.settings.specToken, {token_info: {}});\n      //   const task2 = this.wallet.balance(this.terrajs.settings.wallet, this.terrajs.settings.platform);\n      //   const taskResult = await Promise.all([task1, task2]);\n      //   this.circulation = minus(taskResult[0].total_supply, taskResult[1].locked_amount);\n      //   return;\n      // } else {\n      //   const bundler = new QueryBundler(this.wasm);\n      //   const task1 = bundler.query(this.terrajs.settings.specToken, {token_info: {}});\n      //   const task2 = bundler.query(this.terrajs.settings.wallet, {\n      //     balance: {\n      //       address: this.terrajs.settings.platform\n      //     }\n      //   });\n      //   bundler.flush();\n      //   const taskResult = await Promise.all([task1, task2]);\n      //   this.circulation = minus(taskResult[0].total_supply, taskResult[1].locked_amount);\n      // }\n    });\n  }\n  refreshMarketCap() {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield Promise.all([this.refreshCirculation(), this.refreshSPECPool()]);\n      this.marketCap = +this.circulation / CONFIG.UNIT * +this.specPrice;\n    });\n  }\n  updateMyTvl() {\n    return __awaiter(this, void 0, void 0, function* () {\n      if (!this.terrajs.address) {\n        this.rewardInfos = {};\n      }\n      let tvl = 0;\n      const portfolio = {\n        farms: new Map()\n      };\n      for (const vault of this.allVaults) {\n        const rewardInfo = this.rewardInfos[vault.poolInfo.key];\n        if (!rewardInfo) {\n          continue;\n        }\n        let bond_amount;\n        if (vault.poolInfo.farmType === 'LP') {\n          bond_amount = +lp_balance_transform(rewardInfo.bond_amount, this, this.config, vault.poolInfo.key);\n        }\n        bond_amount = bond_amount / CONFIG.UNIT || 0;\n        if (!portfolio.farms.get(vault.poolInfo.farm)) {\n          portfolio.farms.set(vault.poolInfo.farm, {\n            bond_amount_ust: 0\n          });\n        }\n        portfolio.farms.get(vault.poolInfo.farm).bond_amount_ust += bond_amount;\n        tvl += bond_amount;\n      }\n      this.myTvl = tvl;\n      this.portfolio = portfolio;\n    });\n  }\n  initializeVaultData(connected) {\n    return __awaiter(this, void 0, void 0, function* () {\n      yield this.retrieveCachedStat();\n      if (this.config.contractOnNetwork !== this.terrajs.networkName) {\n        this.config.refreshContractOnNetwork();\n      }\n      if (connected) {\n        this.refreshRewardInfos().then(() => this.updateMyTvl());\n      }\n      this.updateVaults();\n      yield this.fetchGovPoolDetails();\n      if (connected) {\n        yield this.updateMyTvl();\n      }\n    });\n  }\n  retrieveCachedStat(skipPoolResponses = false) {\n    return __awaiter(this, void 0, void 0, function* () {\n      try {\n        const data = yield this.httpClient.get(this.terrajs.settings.specAPI + '/data?type=lpVault').toPromise();\n        if (!data.stat || !data.pairInfos || !data.poolInfos || !data.tokenInfos || !data.poolResponses || !data.infoSchemaVersion || !data.ulunaUSDPrice || !data.ampStablePairs) {\n          throw data;\n        }\n        this.tokenInfos = data.tokenInfos;\n        this.stat = data.stat;\n        this.pairInfos = data.pairInfos;\n        this.poolInfos = data.poolInfos;\n        this.circulation = data.circulation;\n        this.marketCap = data.marketCap;\n        this.ulunaUSDPrice = data.ulunaUSDPrice;\n        this.ampStablePairs = data.ampStablePairs;\n        this.compoundStat = data.compoundStat;\n        localStorage.setItem('tokenInfos', JSON.stringify(this.tokenInfos));\n        localStorage.setItem('stat', JSON.stringify(this.stat));\n        localStorage.setItem('pairInfos', JSON.stringify(this.pairInfos));\n        localStorage.setItem('poolInfos', JSON.stringify(this.poolInfos));\n        localStorage.setItem('infoSchemaVersion', JSON.stringify(data.infoSchemaVersion));\n        localStorage.setItem('ampStablePairs', JSON.stringify(this.ampStablePairs));\n        localStorage.setItem('compoundStat', JSON.stringify(this.compoundStat));\n        if (!skipPoolResponses) {\n          this.poolResponses = data.poolResponses;\n          localStorage.setItem('poolResponses', JSON.stringify(this.poolResponses));\n        }\n        // no more fallback\n      } catch (ex) {\n        // fallback if api die\n        console.error('Error in retrieveCachedStat: fallback local info service data init');\n        console.error(ex);\n        yield Promise.all([this.ensureTokenInfos(), this.refreshStat()]);\n        localStorage.setItem('infoSchemaVersion', '1');\n      } finally {\n        this.loadedNetwork = this.terrajs.settings.chainID;\n      }\n    });\n  }\n  updateVaults() {\n    var _a, _b, _c, _d, _e, _f, _g, _h;\n    if (this.loadedNetwork !== this.terrajs.settings.chainID) {\n      return;\n    }\n    this.allVaults = [];\n    for (const key of Object.keys(this.poolInfos)) {\n      if (!this.poolInfos[key]) {\n        continue;\n      }\n      const baseTokenContract = this.poolInfos[key].baseTokenContract;\n      const denomTokenContract = this.poolInfos[key].denomTokenContract;\n      const rewardTokenContracts = this.poolInfos[key].rewardTokenContracts;\n      const baseSymbol = isNativeToken(baseTokenContract) ? Denom.display[baseTokenContract] : (_a = this.tokenInfos[baseTokenContract]) === null || _a === void 0 ? void 0 : _a.symbol;\n      const denomSymbol = isNativeToken(denomTokenContract) ? Denom.display[denomTokenContract] : (_b = this.tokenInfos[denomTokenContract]) === null || _b === void 0 ? void 0 : _b.symbol;\n      const poolInfo = this.poolInfos[key];\n      const shouldSetAprZero = poolInfo.disabled;\n      const pairStat = (_c = this.stat) === null || _c === void 0 ? void 0 : _c.pairs[key];\n      const poolAprTotal = shouldSetAprZero ? 0 : this.getPoolAprTotal(pairStat);\n      const disabled = poolInfo.disabled;\n      let score;\n      if (poolInfo.farm === 'Spectrum') {\n        score = 2000000;\n      } else if (disabled) {\n        score = -1;\n      } else {\n        score = (poolInfo.highlight ? 1000000 : 0) + ((pairStat === null || pairStat === void 0 ? void 0 : pairStat.multiplier) || 0);\n      }\n      const vault = {\n        baseSymbol,\n        denomSymbol,\n        baseDecimals: isNativeToken(baseTokenContract) ? CONFIG.DIGIT : (_d = this.tokenInfos[baseTokenContract]) === null || _d === void 0 ? void 0 : _d.decimals,\n        baseUnit: isNativeToken(baseTokenContract) ? CONFIG.UNIT : (_e = this.tokenInfos[baseTokenContract]) === null || _e === void 0 ? void 0 : _e.unit,\n        denomDecimals: isNativeToken(denomTokenContract) ? CONFIG.DIGIT : (_f = this.tokenInfos[denomTokenContract]) === null || _f === void 0 ? void 0 : _f.decimals,\n        denomUnit: isNativeToken(denomTokenContract) ? CONFIG.UNIT : (_g = this.tokenInfos[denomTokenContract]) === null || _g === void 0 ? void 0 : _g.unit,\n        baseAssetInfo: isNativeToken(baseTokenContract) ? {\n          native_token: {\n            denom: baseTokenContract\n          }\n        } : {\n          token: {\n            contract_addr: baseTokenContract\n          }\n        },\n        denomAssetInfo: isNativeToken(denomTokenContract) ? {\n          native_token: {\n            denom: denomTokenContract\n          }\n        } : {\n          token: {\n            contract_addr: denomTokenContract\n          }\n        },\n        lpToken: (_h = this.pairInfos[key]) === null || _h === void 0 ? void 0 : _h.liquidity_token,\n        pairStat,\n        poolInfo,\n        pairInfo: this.pairInfos[key],\n        name: `${baseSymbol}-${denomSymbol} LP`,\n        unitDisplay: `${baseSymbol}-${denomSymbol} ${poolInfo.dex} LP`,\n        shortUnitDisplay: `LP`,\n        score,\n        disabled,\n        poolAprTotal\n      };\n      this.allVaults.push(vault);\n    }\n  }\n  fetchGovPoolDetails() {\n    return __awaiter(this, void 0, void 0, function* () {});\n  }\n  getPoolAprTotal(pairStat) {\n    var _a;\n    return ((_a = pairStat === null || pairStat === void 0 ? void 0 : pairStat.poolAprs) === null || _a === void 0 ? void 0 : _a.reduce((accumulator, poolAPR) => accumulator + poolAPR.apr, 0)) || 0;\n  }\n  findPoolAPRBySymbol(pairStat, symbol) {\n    return pairStat.poolAprs.find(poolAPR => poolAPR.rewardSymbol === symbol);\n  }\n  cleanSymbol(symbol) {\n    return symbol;\n  }\n  refreshGovStat(stat) {\n    return __awaiter(this, void 0, void 0, function* () {\n      // TODO until SPEC and GOV are live\n      // const poolTask = this.refreshSPECPool();\n      //\n      // const state = await this.gov.query({state: {}});\n      // stat.govStaked = state.total_staked;\n      // stat.govPoolCount = state.pools.length;\n      //\n      // await poolTask;\n      // stat.govTvl = times(stat.govStaked, this.specPrice);\n      // stat.tvl = plus(stat.tvl, stat.govTvl);\n    });\n  }\n  ensureAstroportData() {\n    return __awaiter(this, void 0, void 0, function* () {\n      const apollo = this.apollo.use(this.terrajs.settings.astroport_gql);\n      const poolsQuery = apollo.query({\n        variables: {\n          limit: 500,\n          sortField: 'TVL'\n        },\n        query: ASTROPORT_POOLS_GQL,\n        errorPolicy: 'all'\n      });\n      const ulunaPriceQuery = apollo.query({\n        variables: {\n          address: Denom.LUNA\n        },\n        query: ASTROPORT_PRICE_GQL,\n        errorPolicy: 'all'\n      });\n      let tasks;\n      if (this.terrajs.isMainnet) {\n        tasks = [poolsQuery.toPromise()];\n      } else {\n        tasks = [poolsQuery.toPromise(), ulunaPriceQuery.toPromise()];\n      }\n      const [poolResponse, ulunaPriceResponse] = yield Promise.all(tasks);\n      this.astroportPoolsData = poolResponse.data;\n      this.ulunaUSDPrice = ulunaPriceResponse.data.price.price_usd;\n    });\n  }\n}\nInfoService.ɵfac = function InfoService_Factory(t) {\n  return new (t || InfoService)(i0.ɵɵinject(i1.BankService), i0.ɵɵinject(FARM_INFO_SERVICE), i0.ɵɵinject(i2.GovService), i0.ɵɵinject(i3.TerrajsService), i0.ɵɵinject(i4.AstroportService), i0.ɵɵinject(i5.AstroportFactoryService), i0.ɵɵinject(i6.TokenService), i0.ɵɵinject(i7.BalancePipe), i0.ɵɵinject(i8.HttpClient), i0.ɵɵinject(i9.WalletService), i0.ɵɵinject(i10.Apollo), i0.ɵɵinject(i11.WasmService), i0.ɵɵinject(i12.ConfigService));\n};\nInfoService.ɵprov = /*@__PURE__*/i0.ɵɵdefineInjectable({\n  token: InfoService,\n  factory: InfoService.ɵfac,\n  providedIn: 'root'\n});\n__decorate([memoize(1000)], InfoService.prototype, \"refreshNativeTokens\", null);\n__decorate([memoize(1000)], InfoService.prototype, \"refreshSPECPool\", null);\n__decorate([memoize(1000)], InfoService.prototype, \"refreshPoolInfos\", null);\n__decorate([memoize(1000)], InfoService.prototype, \"refreshPoolResponses\", null);\n__decorate([memoize(30000)], InfoService.prototype, \"ensureAstroportData\", null);","map":null,"metadata":{},"sourceType":"module","externalDependencies":[]}