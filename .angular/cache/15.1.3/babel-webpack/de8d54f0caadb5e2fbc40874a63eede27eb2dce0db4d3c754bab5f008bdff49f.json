{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pool = exports.RedelegationResponse = exports.RedelegationEntryResponse = exports.DelegationResponse = exports.Params = exports.Redelegation = exports.RedelegationEntry = exports.UnbondingDelegationEntry = exports.UnbondingDelegation = exports.Delegation = exports.DVVTriplets = exports.DVVTriplet = exports.DVPairs = exports.DVPair = exports.ValAddresses = exports.Validator = exports.Description = exports.Commission = exports.CommissionRates = exports.HistoricalInfo = exports.bondStatusToJSON = exports.bondStatusFromJSON = exports.BondStatus = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst types_1 = require(\"../../../tendermint/types/types\");\nconst any_1 = require(\"../../../google/protobuf/any\");\nconst duration_1 = require(\"../../../google/protobuf/duration\");\nconst coin_1 = require(\"../../../cosmos/base/v1beta1/coin\");\nconst timestamp_1 = require(\"../../../google/protobuf/timestamp\");\nexports.protobufPackage = \"cosmos.staking.v1beta1\";\n/** BondStatus is the status of a validator. */\nvar BondStatus;\n(function (BondStatus) {\n  /** BOND_STATUS_UNSPECIFIED - UNSPECIFIED defines an invalid validator status. */\n  BondStatus[BondStatus[\"BOND_STATUS_UNSPECIFIED\"] = 0] = \"BOND_STATUS_UNSPECIFIED\";\n  /** BOND_STATUS_UNBONDED - UNBONDED defines a validator that is not bonded. */\n  BondStatus[BondStatus[\"BOND_STATUS_UNBONDED\"] = 1] = \"BOND_STATUS_UNBONDED\";\n  /** BOND_STATUS_UNBONDING - UNBONDING defines a validator that is unbonding. */\n  BondStatus[BondStatus[\"BOND_STATUS_UNBONDING\"] = 2] = \"BOND_STATUS_UNBONDING\";\n  /** BOND_STATUS_BONDED - BONDED defines a validator that is bonded. */\n  BondStatus[BondStatus[\"BOND_STATUS_BONDED\"] = 3] = \"BOND_STATUS_BONDED\";\n  BondStatus[BondStatus[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(BondStatus = exports.BondStatus || (exports.BondStatus = {}));\nfunction bondStatusFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"BOND_STATUS_UNSPECIFIED\":\n      return BondStatus.BOND_STATUS_UNSPECIFIED;\n    case 1:\n    case \"BOND_STATUS_UNBONDED\":\n      return BondStatus.BOND_STATUS_UNBONDED;\n    case 2:\n    case \"BOND_STATUS_UNBONDING\":\n      return BondStatus.BOND_STATUS_UNBONDING;\n    case 3:\n    case \"BOND_STATUS_BONDED\":\n      return BondStatus.BOND_STATUS_BONDED;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return BondStatus.UNRECOGNIZED;\n  }\n}\nexports.bondStatusFromJSON = bondStatusFromJSON;\nfunction bondStatusToJSON(object) {\n  switch (object) {\n    case BondStatus.BOND_STATUS_UNSPECIFIED:\n      return \"BOND_STATUS_UNSPECIFIED\";\n    case BondStatus.BOND_STATUS_UNBONDED:\n      return \"BOND_STATUS_UNBONDED\";\n    case BondStatus.BOND_STATUS_UNBONDING:\n      return \"BOND_STATUS_UNBONDING\";\n    case BondStatus.BOND_STATUS_BONDED:\n      return \"BOND_STATUS_BONDED\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.bondStatusToJSON = bondStatusToJSON;\nconst baseHistoricalInfo = {};\nexports.HistoricalInfo = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.header !== undefined) {\n      types_1.Header.encode(message.header, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.valset) {\n      exports.Validator.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseHistoricalInfo);\n    message.valset = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.header = types_1.Header.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.valset.push(exports.Validator.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseHistoricalInfo);\n    message.valset = [];\n    if (object.header !== undefined && object.header !== null) {\n      message.header = types_1.Header.fromJSON(object.header);\n    } else {\n      message.header = undefined;\n    }\n    if (object.valset !== undefined && object.valset !== null) {\n      for (const e of object.valset) {\n        message.valset.push(exports.Validator.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.header !== undefined && (obj.header = message.header ? types_1.Header.toJSON(message.header) : undefined);\n    if (message.valset) {\n      obj.valset = message.valset.map(e => e ? exports.Validator.toJSON(e) : undefined);\n    } else {\n      obj.valset = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseHistoricalInfo);\n    message.valset = [];\n    if (object.header !== undefined && object.header !== null) {\n      message.header = types_1.Header.fromPartial(object.header);\n    } else {\n      message.header = undefined;\n    }\n    if (object.valset !== undefined && object.valset !== null) {\n      for (const e of object.valset) {\n        message.valset.push(exports.Validator.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseCommissionRates = {\n  rate: \"\",\n  maxRate: \"\",\n  maxChangeRate: \"\"\n};\nexports.CommissionRates = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.rate !== \"\") {\n      writer.uint32(10).string(message.rate);\n    }\n    if (message.maxRate !== \"\") {\n      writer.uint32(18).string(message.maxRate);\n    }\n    if (message.maxChangeRate !== \"\") {\n      writer.uint32(26).string(message.maxChangeRate);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCommissionRates);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.rate = reader.string();\n          break;\n        case 2:\n          message.maxRate = reader.string();\n          break;\n        case 3:\n          message.maxChangeRate = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseCommissionRates);\n    if (object.rate !== undefined && object.rate !== null) {\n      message.rate = String(object.rate);\n    } else {\n      message.rate = \"\";\n    }\n    if (object.maxRate !== undefined && object.maxRate !== null) {\n      message.maxRate = String(object.maxRate);\n    } else {\n      message.maxRate = \"\";\n    }\n    if (object.maxChangeRate !== undefined && object.maxChangeRate !== null) {\n      message.maxChangeRate = String(object.maxChangeRate);\n    } else {\n      message.maxChangeRate = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.rate !== undefined && (obj.rate = message.rate);\n    message.maxRate !== undefined && (obj.maxRate = message.maxRate);\n    message.maxChangeRate !== undefined && (obj.maxChangeRate = message.maxChangeRate);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseCommissionRates);\n    if (object.rate !== undefined && object.rate !== null) {\n      message.rate = object.rate;\n    } else {\n      message.rate = \"\";\n    }\n    if (object.maxRate !== undefined && object.maxRate !== null) {\n      message.maxRate = object.maxRate;\n    } else {\n      message.maxRate = \"\";\n    }\n    if (object.maxChangeRate !== undefined && object.maxChangeRate !== null) {\n      message.maxChangeRate = object.maxChangeRate;\n    } else {\n      message.maxChangeRate = \"\";\n    }\n    return message;\n  }\n};\nconst baseCommission = {};\nexports.Commission = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.commissionRates !== undefined) {\n      exports.CommissionRates.encode(message.commissionRates, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.updateTime !== undefined) {\n      timestamp_1.Timestamp.encode(toTimestamp(message.updateTime), writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCommission);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.commissionRates = exports.CommissionRates.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.updateTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseCommission);\n    if (object.commissionRates !== undefined && object.commissionRates !== null) {\n      message.commissionRates = exports.CommissionRates.fromJSON(object.commissionRates);\n    } else {\n      message.commissionRates = undefined;\n    }\n    if (object.updateTime !== undefined && object.updateTime !== null) {\n      message.updateTime = fromJsonTimestamp(object.updateTime);\n    } else {\n      message.updateTime = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.commissionRates !== undefined && (obj.commissionRates = message.commissionRates ? exports.CommissionRates.toJSON(message.commissionRates) : undefined);\n    message.updateTime !== undefined && (obj.updateTime = message.updateTime.toISOString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseCommission);\n    if (object.commissionRates !== undefined && object.commissionRates !== null) {\n      message.commissionRates = exports.CommissionRates.fromPartial(object.commissionRates);\n    } else {\n      message.commissionRates = undefined;\n    }\n    if (object.updateTime !== undefined && object.updateTime !== null) {\n      message.updateTime = object.updateTime;\n    } else {\n      message.updateTime = undefined;\n    }\n    return message;\n  }\n};\nconst baseDescription = {\n  moniker: \"\",\n  identity: \"\",\n  website: \"\",\n  securityContact: \"\",\n  details: \"\"\n};\nexports.Description = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.moniker !== \"\") {\n      writer.uint32(10).string(message.moniker);\n    }\n    if (message.identity !== \"\") {\n      writer.uint32(18).string(message.identity);\n    }\n    if (message.website !== \"\") {\n      writer.uint32(26).string(message.website);\n    }\n    if (message.securityContact !== \"\") {\n      writer.uint32(34).string(message.securityContact);\n    }\n    if (message.details !== \"\") {\n      writer.uint32(42).string(message.details);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDescription);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.moniker = reader.string();\n          break;\n        case 2:\n          message.identity = reader.string();\n          break;\n        case 3:\n          message.website = reader.string();\n          break;\n        case 4:\n          message.securityContact = reader.string();\n          break;\n        case 5:\n          message.details = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDescription);\n    if (object.moniker !== undefined && object.moniker !== null) {\n      message.moniker = String(object.moniker);\n    } else {\n      message.moniker = \"\";\n    }\n    if (object.identity !== undefined && object.identity !== null) {\n      message.identity = String(object.identity);\n    } else {\n      message.identity = \"\";\n    }\n    if (object.website !== undefined && object.website !== null) {\n      message.website = String(object.website);\n    } else {\n      message.website = \"\";\n    }\n    if (object.securityContact !== undefined && object.securityContact !== null) {\n      message.securityContact = String(object.securityContact);\n    } else {\n      message.securityContact = \"\";\n    }\n    if (object.details !== undefined && object.details !== null) {\n      message.details = String(object.details);\n    } else {\n      message.details = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.moniker !== undefined && (obj.moniker = message.moniker);\n    message.identity !== undefined && (obj.identity = message.identity);\n    message.website !== undefined && (obj.website = message.website);\n    message.securityContact !== undefined && (obj.securityContact = message.securityContact);\n    message.details !== undefined && (obj.details = message.details);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseDescription);\n    if (object.moniker !== undefined && object.moniker !== null) {\n      message.moniker = object.moniker;\n    } else {\n      message.moniker = \"\";\n    }\n    if (object.identity !== undefined && object.identity !== null) {\n      message.identity = object.identity;\n    } else {\n      message.identity = \"\";\n    }\n    if (object.website !== undefined && object.website !== null) {\n      message.website = object.website;\n    } else {\n      message.website = \"\";\n    }\n    if (object.securityContact !== undefined && object.securityContact !== null) {\n      message.securityContact = object.securityContact;\n    } else {\n      message.securityContact = \"\";\n    }\n    if (object.details !== undefined && object.details !== null) {\n      message.details = object.details;\n    } else {\n      message.details = \"\";\n    }\n    return message;\n  }\n};\nconst baseValidator = {\n  operatorAddress: \"\",\n  jailed: false,\n  status: 0,\n  tokens: \"\",\n  delegatorShares: \"\",\n  unbondingHeight: long_1.default.ZERO,\n  minSelfDelegation: \"\"\n};\nexports.Validator = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.operatorAddress !== \"\") {\n      writer.uint32(10).string(message.operatorAddress);\n    }\n    if (message.consensusPubkey !== undefined) {\n      any_1.Any.encode(message.consensusPubkey, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.jailed === true) {\n      writer.uint32(24).bool(message.jailed);\n    }\n    if (message.status !== 0) {\n      writer.uint32(32).int32(message.status);\n    }\n    if (message.tokens !== \"\") {\n      writer.uint32(42).string(message.tokens);\n    }\n    if (message.delegatorShares !== \"\") {\n      writer.uint32(50).string(message.delegatorShares);\n    }\n    if (message.description !== undefined) {\n      exports.Description.encode(message.description, writer.uint32(58).fork()).ldelim();\n    }\n    if (!message.unbondingHeight.isZero()) {\n      writer.uint32(64).int64(message.unbondingHeight);\n    }\n    if (message.unbondingTime !== undefined) {\n      timestamp_1.Timestamp.encode(toTimestamp(message.unbondingTime), writer.uint32(74).fork()).ldelim();\n    }\n    if (message.commission !== undefined) {\n      exports.Commission.encode(message.commission, writer.uint32(82).fork()).ldelim();\n    }\n    if (message.minSelfDelegation !== \"\") {\n      writer.uint32(90).string(message.minSelfDelegation);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseValidator);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.operatorAddress = reader.string();\n          break;\n        case 2:\n          message.consensusPubkey = any_1.Any.decode(reader, reader.uint32());\n          break;\n        case 3:\n          message.jailed = reader.bool();\n          break;\n        case 4:\n          message.status = reader.int32();\n          break;\n        case 5:\n          message.tokens = reader.string();\n          break;\n        case 6:\n          message.delegatorShares = reader.string();\n          break;\n        case 7:\n          message.description = exports.Description.decode(reader, reader.uint32());\n          break;\n        case 8:\n          message.unbondingHeight = reader.int64();\n          break;\n        case 9:\n          message.unbondingTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 10:\n          message.commission = exports.Commission.decode(reader, reader.uint32());\n          break;\n        case 11:\n          message.minSelfDelegation = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseValidator);\n    if (object.operatorAddress !== undefined && object.operatorAddress !== null) {\n      message.operatorAddress = String(object.operatorAddress);\n    } else {\n      message.operatorAddress = \"\";\n    }\n    if (object.consensusPubkey !== undefined && object.consensusPubkey !== null) {\n      message.consensusPubkey = any_1.Any.fromJSON(object.consensusPubkey);\n    } else {\n      message.consensusPubkey = undefined;\n    }\n    if (object.jailed !== undefined && object.jailed !== null) {\n      message.jailed = Boolean(object.jailed);\n    } else {\n      message.jailed = false;\n    }\n    if (object.status !== undefined && object.status !== null) {\n      message.status = bondStatusFromJSON(object.status);\n    } else {\n      message.status = 0;\n    }\n    if (object.tokens !== undefined && object.tokens !== null) {\n      message.tokens = String(object.tokens);\n    } else {\n      message.tokens = \"\";\n    }\n    if (object.delegatorShares !== undefined && object.delegatorShares !== null) {\n      message.delegatorShares = String(object.delegatorShares);\n    } else {\n      message.delegatorShares = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = exports.Description.fromJSON(object.description);\n    } else {\n      message.description = undefined;\n    }\n    if (object.unbondingHeight !== undefined && object.unbondingHeight !== null) {\n      message.unbondingHeight = long_1.default.fromString(object.unbondingHeight);\n    } else {\n      message.unbondingHeight = long_1.default.ZERO;\n    }\n    if (object.unbondingTime !== undefined && object.unbondingTime !== null) {\n      message.unbondingTime = fromJsonTimestamp(object.unbondingTime);\n    } else {\n      message.unbondingTime = undefined;\n    }\n    if (object.commission !== undefined && object.commission !== null) {\n      message.commission = exports.Commission.fromJSON(object.commission);\n    } else {\n      message.commission = undefined;\n    }\n    if (object.minSelfDelegation !== undefined && object.minSelfDelegation !== null) {\n      message.minSelfDelegation = String(object.minSelfDelegation);\n    } else {\n      message.minSelfDelegation = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.operatorAddress !== undefined && (obj.operatorAddress = message.operatorAddress);\n    message.consensusPubkey !== undefined && (obj.consensusPubkey = message.consensusPubkey ? any_1.Any.toJSON(message.consensusPubkey) : undefined);\n    message.jailed !== undefined && (obj.jailed = message.jailed);\n    message.status !== undefined && (obj.status = bondStatusToJSON(message.status));\n    message.tokens !== undefined && (obj.tokens = message.tokens);\n    message.delegatorShares !== undefined && (obj.delegatorShares = message.delegatorShares);\n    message.description !== undefined && (obj.description = message.description ? exports.Description.toJSON(message.description) : undefined);\n    message.unbondingHeight !== undefined && (obj.unbondingHeight = (message.unbondingHeight || long_1.default.ZERO).toString());\n    message.unbondingTime !== undefined && (obj.unbondingTime = message.unbondingTime.toISOString());\n    message.commission !== undefined && (obj.commission = message.commission ? exports.Commission.toJSON(message.commission) : undefined);\n    message.minSelfDelegation !== undefined && (obj.minSelfDelegation = message.minSelfDelegation);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseValidator);\n    if (object.operatorAddress !== undefined && object.operatorAddress !== null) {\n      message.operatorAddress = object.operatorAddress;\n    } else {\n      message.operatorAddress = \"\";\n    }\n    if (object.consensusPubkey !== undefined && object.consensusPubkey !== null) {\n      message.consensusPubkey = any_1.Any.fromPartial(object.consensusPubkey);\n    } else {\n      message.consensusPubkey = undefined;\n    }\n    if (object.jailed !== undefined && object.jailed !== null) {\n      message.jailed = object.jailed;\n    } else {\n      message.jailed = false;\n    }\n    if (object.status !== undefined && object.status !== null) {\n      message.status = object.status;\n    } else {\n      message.status = 0;\n    }\n    if (object.tokens !== undefined && object.tokens !== null) {\n      message.tokens = object.tokens;\n    } else {\n      message.tokens = \"\";\n    }\n    if (object.delegatorShares !== undefined && object.delegatorShares !== null) {\n      message.delegatorShares = object.delegatorShares;\n    } else {\n      message.delegatorShares = \"\";\n    }\n    if (object.description !== undefined && object.description !== null) {\n      message.description = exports.Description.fromPartial(object.description);\n    } else {\n      message.description = undefined;\n    }\n    if (object.unbondingHeight !== undefined && object.unbondingHeight !== null) {\n      message.unbondingHeight = object.unbondingHeight;\n    } else {\n      message.unbondingHeight = long_1.default.ZERO;\n    }\n    if (object.unbondingTime !== undefined && object.unbondingTime !== null) {\n      message.unbondingTime = object.unbondingTime;\n    } else {\n      message.unbondingTime = undefined;\n    }\n    if (object.commission !== undefined && object.commission !== null) {\n      message.commission = exports.Commission.fromPartial(object.commission);\n    } else {\n      message.commission = undefined;\n    }\n    if (object.minSelfDelegation !== undefined && object.minSelfDelegation !== null) {\n      message.minSelfDelegation = object.minSelfDelegation;\n    } else {\n      message.minSelfDelegation = \"\";\n    }\n    return message;\n  }\n};\nconst baseValAddresses = {\n  addresses: \"\"\n};\nexports.ValAddresses = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.addresses) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseValAddresses);\n    message.addresses = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.addresses.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseValAddresses);\n    message.addresses = [];\n    if (object.addresses !== undefined && object.addresses !== null) {\n      for (const e of object.addresses) {\n        message.addresses.push(String(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.addresses) {\n      obj.addresses = message.addresses.map(e => e);\n    } else {\n      obj.addresses = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseValAddresses);\n    message.addresses = [];\n    if (object.addresses !== undefined && object.addresses !== null) {\n      for (const e of object.addresses) {\n        message.addresses.push(e);\n      }\n    }\n    return message;\n  }\n};\nconst baseDVPair = {\n  delegatorAddress: \"\",\n  validatorAddress: \"\"\n};\nexports.DVPair = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDVPair);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDVPair);\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = String(object.delegatorAddress);\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorAddress !== undefined && object.validatorAddress !== null) {\n      message.validatorAddress = String(object.validatorAddress);\n    } else {\n      message.validatorAddress = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseDVPair);\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = object.delegatorAddress;\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorAddress !== undefined && object.validatorAddress !== null) {\n      message.validatorAddress = object.validatorAddress;\n    } else {\n      message.validatorAddress = \"\";\n    }\n    return message;\n  }\n};\nconst baseDVPairs = {};\nexports.DVPairs = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.pairs) {\n      exports.DVPair.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDVPairs);\n    message.pairs = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.pairs.push(exports.DVPair.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDVPairs);\n    message.pairs = [];\n    if (object.pairs !== undefined && object.pairs !== null) {\n      for (const e of object.pairs) {\n        message.pairs.push(exports.DVPair.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.pairs) {\n      obj.pairs = message.pairs.map(e => e ? exports.DVPair.toJSON(e) : undefined);\n    } else {\n      obj.pairs = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseDVPairs);\n    message.pairs = [];\n    if (object.pairs !== undefined && object.pairs !== null) {\n      for (const e of object.pairs) {\n        message.pairs.push(exports.DVPair.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseDVVTriplet = {\n  delegatorAddress: \"\",\n  validatorSrcAddress: \"\",\n  validatorDstAddress: \"\"\n};\nexports.DVVTriplet = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDVVTriplet);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDVVTriplet);\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = String(object.delegatorAddress);\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorSrcAddress !== undefined && object.validatorSrcAddress !== null) {\n      message.validatorSrcAddress = String(object.validatorSrcAddress);\n    } else {\n      message.validatorSrcAddress = \"\";\n    }\n    if (object.validatorDstAddress !== undefined && object.validatorDstAddress !== null) {\n      message.validatorDstAddress = String(object.validatorDstAddress);\n    } else {\n      message.validatorDstAddress = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined && (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined && (obj.validatorDstAddress = message.validatorDstAddress);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseDVVTriplet);\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = object.delegatorAddress;\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorSrcAddress !== undefined && object.validatorSrcAddress !== null) {\n      message.validatorSrcAddress = object.validatorSrcAddress;\n    } else {\n      message.validatorSrcAddress = \"\";\n    }\n    if (object.validatorDstAddress !== undefined && object.validatorDstAddress !== null) {\n      message.validatorDstAddress = object.validatorDstAddress;\n    } else {\n      message.validatorDstAddress = \"\";\n    }\n    return message;\n  }\n};\nconst baseDVVTriplets = {};\nexports.DVVTriplets = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.triplets) {\n      exports.DVVTriplet.encode(v, writer.uint32(10).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDVVTriplets);\n    message.triplets = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.triplets.push(exports.DVVTriplet.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDVVTriplets);\n    message.triplets = [];\n    if (object.triplets !== undefined && object.triplets !== null) {\n      for (const e of object.triplets) {\n        message.triplets.push(exports.DVVTriplet.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.triplets) {\n      obj.triplets = message.triplets.map(e => e ? exports.DVVTriplet.toJSON(e) : undefined);\n    } else {\n      obj.triplets = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseDVVTriplets);\n    message.triplets = [];\n    if (object.triplets !== undefined && object.triplets !== null) {\n      for (const e of object.triplets) {\n        message.triplets.push(exports.DVVTriplet.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseDelegation = {\n  delegatorAddress: \"\",\n  validatorAddress: \"\",\n  shares: \"\"\n};\nexports.Delegation = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    if (message.shares !== \"\") {\n      writer.uint32(26).string(message.shares);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDelegation);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.shares = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDelegation);\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = String(object.delegatorAddress);\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorAddress !== undefined && object.validatorAddress !== null) {\n      message.validatorAddress = String(object.validatorAddress);\n    } else {\n      message.validatorAddress = \"\";\n    }\n    if (object.shares !== undefined && object.shares !== null) {\n      message.shares = String(object.shares);\n    } else {\n      message.shares = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);\n    message.shares !== undefined && (obj.shares = message.shares);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseDelegation);\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = object.delegatorAddress;\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorAddress !== undefined && object.validatorAddress !== null) {\n      message.validatorAddress = object.validatorAddress;\n    } else {\n      message.validatorAddress = \"\";\n    }\n    if (object.shares !== undefined && object.shares !== null) {\n      message.shares = object.shares;\n    } else {\n      message.shares = \"\";\n    }\n    return message;\n  }\n};\nconst baseUnbondingDelegation = {\n  delegatorAddress: \"\",\n  validatorAddress: \"\"\n};\nexports.UnbondingDelegation = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorAddress !== \"\") {\n      writer.uint32(18).string(message.validatorAddress);\n    }\n    for (const v of message.entries) {\n      exports.UnbondingDelegationEntry.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseUnbondingDelegation);\n    message.entries = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorAddress = reader.string();\n          break;\n        case 3:\n          message.entries.push(exports.UnbondingDelegationEntry.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseUnbondingDelegation);\n    message.entries = [];\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = String(object.delegatorAddress);\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorAddress !== undefined && object.validatorAddress !== null) {\n      message.validatorAddress = String(object.validatorAddress);\n    } else {\n      message.validatorAddress = \"\";\n    }\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.UnbondingDelegationEntry.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorAddress !== undefined && (obj.validatorAddress = message.validatorAddress);\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? exports.UnbondingDelegationEntry.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseUnbondingDelegation);\n    message.entries = [];\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = object.delegatorAddress;\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorAddress !== undefined && object.validatorAddress !== null) {\n      message.validatorAddress = object.validatorAddress;\n    } else {\n      message.validatorAddress = \"\";\n    }\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.UnbondingDelegationEntry.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseUnbondingDelegationEntry = {\n  creationHeight: long_1.default.ZERO,\n  initialBalance: \"\",\n  balance: \"\"\n};\nexports.UnbondingDelegationEntry = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.creationHeight.isZero()) {\n      writer.uint32(8).int64(message.creationHeight);\n    }\n    if (message.completionTime !== undefined) {\n      timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).ldelim();\n    }\n    if (message.initialBalance !== \"\") {\n      writer.uint32(26).string(message.initialBalance);\n    }\n    if (message.balance !== \"\") {\n      writer.uint32(34).string(message.balance);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseUnbondingDelegationEntry);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creationHeight = reader.int64();\n          break;\n        case 2:\n          message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.initialBalance = reader.string();\n          break;\n        case 4:\n          message.balance = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseUnbondingDelegationEntry);\n    if (object.creationHeight !== undefined && object.creationHeight !== null) {\n      message.creationHeight = long_1.default.fromString(object.creationHeight);\n    } else {\n      message.creationHeight = long_1.default.ZERO;\n    }\n    if (object.completionTime !== undefined && object.completionTime !== null) {\n      message.completionTime = fromJsonTimestamp(object.completionTime);\n    } else {\n      message.completionTime = undefined;\n    }\n    if (object.initialBalance !== undefined && object.initialBalance !== null) {\n      message.initialBalance = String(object.initialBalance);\n    } else {\n      message.initialBalance = \"\";\n    }\n    if (object.balance !== undefined && object.balance !== null) {\n      message.balance = String(object.balance);\n    } else {\n      message.balance = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.creationHeight !== undefined && (obj.creationHeight = (message.creationHeight || long_1.default.ZERO).toString());\n    message.completionTime !== undefined && (obj.completionTime = message.completionTime.toISOString());\n    message.initialBalance !== undefined && (obj.initialBalance = message.initialBalance);\n    message.balance !== undefined && (obj.balance = message.balance);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseUnbondingDelegationEntry);\n    if (object.creationHeight !== undefined && object.creationHeight !== null) {\n      message.creationHeight = object.creationHeight;\n    } else {\n      message.creationHeight = long_1.default.ZERO;\n    }\n    if (object.completionTime !== undefined && object.completionTime !== null) {\n      message.completionTime = object.completionTime;\n    } else {\n      message.completionTime = undefined;\n    }\n    if (object.initialBalance !== undefined && object.initialBalance !== null) {\n      message.initialBalance = object.initialBalance;\n    } else {\n      message.initialBalance = \"\";\n    }\n    if (object.balance !== undefined && object.balance !== null) {\n      message.balance = object.balance;\n    } else {\n      message.balance = \"\";\n    }\n    return message;\n  }\n};\nconst baseRedelegationEntry = {\n  creationHeight: long_1.default.ZERO,\n  initialBalance: \"\",\n  sharesDst: \"\"\n};\nexports.RedelegationEntry = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.creationHeight.isZero()) {\n      writer.uint32(8).int64(message.creationHeight);\n    }\n    if (message.completionTime !== undefined) {\n      timestamp_1.Timestamp.encode(toTimestamp(message.completionTime), writer.uint32(18).fork()).ldelim();\n    }\n    if (message.initialBalance !== \"\") {\n      writer.uint32(26).string(message.initialBalance);\n    }\n    if (message.sharesDst !== \"\") {\n      writer.uint32(34).string(message.sharesDst);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRedelegationEntry);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.creationHeight = reader.int64();\n          break;\n        case 2:\n          message.completionTime = fromTimestamp(timestamp_1.Timestamp.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.initialBalance = reader.string();\n          break;\n        case 4:\n          message.sharesDst = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRedelegationEntry);\n    if (object.creationHeight !== undefined && object.creationHeight !== null) {\n      message.creationHeight = long_1.default.fromString(object.creationHeight);\n    } else {\n      message.creationHeight = long_1.default.ZERO;\n    }\n    if (object.completionTime !== undefined && object.completionTime !== null) {\n      message.completionTime = fromJsonTimestamp(object.completionTime);\n    } else {\n      message.completionTime = undefined;\n    }\n    if (object.initialBalance !== undefined && object.initialBalance !== null) {\n      message.initialBalance = String(object.initialBalance);\n    } else {\n      message.initialBalance = \"\";\n    }\n    if (object.sharesDst !== undefined && object.sharesDst !== null) {\n      message.sharesDst = String(object.sharesDst);\n    } else {\n      message.sharesDst = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.creationHeight !== undefined && (obj.creationHeight = (message.creationHeight || long_1.default.ZERO).toString());\n    message.completionTime !== undefined && (obj.completionTime = message.completionTime.toISOString());\n    message.initialBalance !== undefined && (obj.initialBalance = message.initialBalance);\n    message.sharesDst !== undefined && (obj.sharesDst = message.sharesDst);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRedelegationEntry);\n    if (object.creationHeight !== undefined && object.creationHeight !== null) {\n      message.creationHeight = object.creationHeight;\n    } else {\n      message.creationHeight = long_1.default.ZERO;\n    }\n    if (object.completionTime !== undefined && object.completionTime !== null) {\n      message.completionTime = object.completionTime;\n    } else {\n      message.completionTime = undefined;\n    }\n    if (object.initialBalance !== undefined && object.initialBalance !== null) {\n      message.initialBalance = object.initialBalance;\n    } else {\n      message.initialBalance = \"\";\n    }\n    if (object.sharesDst !== undefined && object.sharesDst !== null) {\n      message.sharesDst = object.sharesDst;\n    } else {\n      message.sharesDst = \"\";\n    }\n    return message;\n  }\n};\nconst baseRedelegation = {\n  delegatorAddress: \"\",\n  validatorSrcAddress: \"\",\n  validatorDstAddress: \"\"\n};\nexports.Redelegation = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.delegatorAddress !== \"\") {\n      writer.uint32(10).string(message.delegatorAddress);\n    }\n    if (message.validatorSrcAddress !== \"\") {\n      writer.uint32(18).string(message.validatorSrcAddress);\n    }\n    if (message.validatorDstAddress !== \"\") {\n      writer.uint32(26).string(message.validatorDstAddress);\n    }\n    for (const v of message.entries) {\n      exports.RedelegationEntry.encode(v, writer.uint32(34).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRedelegation);\n    message.entries = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegatorAddress = reader.string();\n          break;\n        case 2:\n          message.validatorSrcAddress = reader.string();\n          break;\n        case 3:\n          message.validatorDstAddress = reader.string();\n          break;\n        case 4:\n          message.entries.push(exports.RedelegationEntry.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRedelegation);\n    message.entries = [];\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = String(object.delegatorAddress);\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorSrcAddress !== undefined && object.validatorSrcAddress !== null) {\n      message.validatorSrcAddress = String(object.validatorSrcAddress);\n    } else {\n      message.validatorSrcAddress = \"\";\n    }\n    if (object.validatorDstAddress !== undefined && object.validatorDstAddress !== null) {\n      message.validatorDstAddress = String(object.validatorDstAddress);\n    } else {\n      message.validatorDstAddress = \"\";\n    }\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.RedelegationEntry.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.delegatorAddress !== undefined && (obj.delegatorAddress = message.delegatorAddress);\n    message.validatorSrcAddress !== undefined && (obj.validatorSrcAddress = message.validatorSrcAddress);\n    message.validatorDstAddress !== undefined && (obj.validatorDstAddress = message.validatorDstAddress);\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? exports.RedelegationEntry.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRedelegation);\n    message.entries = [];\n    if (object.delegatorAddress !== undefined && object.delegatorAddress !== null) {\n      message.delegatorAddress = object.delegatorAddress;\n    } else {\n      message.delegatorAddress = \"\";\n    }\n    if (object.validatorSrcAddress !== undefined && object.validatorSrcAddress !== null) {\n      message.validatorSrcAddress = object.validatorSrcAddress;\n    } else {\n      message.validatorSrcAddress = \"\";\n    }\n    if (object.validatorDstAddress !== undefined && object.validatorDstAddress !== null) {\n      message.validatorDstAddress = object.validatorDstAddress;\n    } else {\n      message.validatorDstAddress = \"\";\n    }\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.RedelegationEntry.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseParams = {\n  maxValidators: 0,\n  maxEntries: 0,\n  historicalEntries: 0,\n  bondDenom: \"\"\n};\nexports.Params = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.unbondingTime !== undefined) {\n      duration_1.Duration.encode(message.unbondingTime, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.maxValidators !== 0) {\n      writer.uint32(16).uint32(message.maxValidators);\n    }\n    if (message.maxEntries !== 0) {\n      writer.uint32(24).uint32(message.maxEntries);\n    }\n    if (message.historicalEntries !== 0) {\n      writer.uint32(32).uint32(message.historicalEntries);\n    }\n    if (message.bondDenom !== \"\") {\n      writer.uint32(42).string(message.bondDenom);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseParams);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.unbondingTime = duration_1.Duration.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.maxValidators = reader.uint32();\n          break;\n        case 3:\n          message.maxEntries = reader.uint32();\n          break;\n        case 4:\n          message.historicalEntries = reader.uint32();\n          break;\n        case 5:\n          message.bondDenom = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseParams);\n    if (object.unbondingTime !== undefined && object.unbondingTime !== null) {\n      message.unbondingTime = duration_1.Duration.fromJSON(object.unbondingTime);\n    } else {\n      message.unbondingTime = undefined;\n    }\n    if (object.maxValidators !== undefined && object.maxValidators !== null) {\n      message.maxValidators = Number(object.maxValidators);\n    } else {\n      message.maxValidators = 0;\n    }\n    if (object.maxEntries !== undefined && object.maxEntries !== null) {\n      message.maxEntries = Number(object.maxEntries);\n    } else {\n      message.maxEntries = 0;\n    }\n    if (object.historicalEntries !== undefined && object.historicalEntries !== null) {\n      message.historicalEntries = Number(object.historicalEntries);\n    } else {\n      message.historicalEntries = 0;\n    }\n    if (object.bondDenom !== undefined && object.bondDenom !== null) {\n      message.bondDenom = String(object.bondDenom);\n    } else {\n      message.bondDenom = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.unbondingTime !== undefined && (obj.unbondingTime = message.unbondingTime ? duration_1.Duration.toJSON(message.unbondingTime) : undefined);\n    message.maxValidators !== undefined && (obj.maxValidators = message.maxValidators);\n    message.maxEntries !== undefined && (obj.maxEntries = message.maxEntries);\n    message.historicalEntries !== undefined && (obj.historicalEntries = message.historicalEntries);\n    message.bondDenom !== undefined && (obj.bondDenom = message.bondDenom);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseParams);\n    if (object.unbondingTime !== undefined && object.unbondingTime !== null) {\n      message.unbondingTime = duration_1.Duration.fromPartial(object.unbondingTime);\n    } else {\n      message.unbondingTime = undefined;\n    }\n    if (object.maxValidators !== undefined && object.maxValidators !== null) {\n      message.maxValidators = object.maxValidators;\n    } else {\n      message.maxValidators = 0;\n    }\n    if (object.maxEntries !== undefined && object.maxEntries !== null) {\n      message.maxEntries = object.maxEntries;\n    } else {\n      message.maxEntries = 0;\n    }\n    if (object.historicalEntries !== undefined && object.historicalEntries !== null) {\n      message.historicalEntries = object.historicalEntries;\n    } else {\n      message.historicalEntries = 0;\n    }\n    if (object.bondDenom !== undefined && object.bondDenom !== null) {\n      message.bondDenom = object.bondDenom;\n    } else {\n      message.bondDenom = \"\";\n    }\n    return message;\n  }\n};\nconst baseDelegationResponse = {};\nexports.DelegationResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.delegation !== undefined) {\n      exports.Delegation.encode(message.delegation, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.balance !== undefined) {\n      coin_1.Coin.encode(message.balance, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseDelegationResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.delegation = exports.Delegation.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.balance = coin_1.Coin.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseDelegationResponse);\n    if (object.delegation !== undefined && object.delegation !== null) {\n      message.delegation = exports.Delegation.fromJSON(object.delegation);\n    } else {\n      message.delegation = undefined;\n    }\n    if (object.balance !== undefined && object.balance !== null) {\n      message.balance = coin_1.Coin.fromJSON(object.balance);\n    } else {\n      message.balance = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.delegation !== undefined && (obj.delegation = message.delegation ? exports.Delegation.toJSON(message.delegation) : undefined);\n    message.balance !== undefined && (obj.balance = message.balance ? coin_1.Coin.toJSON(message.balance) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseDelegationResponse);\n    if (object.delegation !== undefined && object.delegation !== null) {\n      message.delegation = exports.Delegation.fromPartial(object.delegation);\n    } else {\n      message.delegation = undefined;\n    }\n    if (object.balance !== undefined && object.balance !== null) {\n      message.balance = coin_1.Coin.fromPartial(object.balance);\n    } else {\n      message.balance = undefined;\n    }\n    return message;\n  }\n};\nconst baseRedelegationEntryResponse = {\n  balance: \"\"\n};\nexports.RedelegationEntryResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.redelegationEntry !== undefined) {\n      exports.RedelegationEntry.encode(message.redelegationEntry, writer.uint32(10).fork()).ldelim();\n    }\n    if (message.balance !== \"\") {\n      writer.uint32(34).string(message.balance);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRedelegationEntryResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.redelegationEntry = exports.RedelegationEntry.decode(reader, reader.uint32());\n          break;\n        case 4:\n          message.balance = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRedelegationEntryResponse);\n    if (object.redelegationEntry !== undefined && object.redelegationEntry !== null) {\n      message.redelegationEntry = exports.RedelegationEntry.fromJSON(object.redelegationEntry);\n    } else {\n      message.redelegationEntry = undefined;\n    }\n    if (object.balance !== undefined && object.balance !== null) {\n      message.balance = String(object.balance);\n    } else {\n      message.balance = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.redelegationEntry !== undefined && (obj.redelegationEntry = message.redelegationEntry ? exports.RedelegationEntry.toJSON(message.redelegationEntry) : undefined);\n    message.balance !== undefined && (obj.balance = message.balance);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRedelegationEntryResponse);\n    if (object.redelegationEntry !== undefined && object.redelegationEntry !== null) {\n      message.redelegationEntry = exports.RedelegationEntry.fromPartial(object.redelegationEntry);\n    } else {\n      message.redelegationEntry = undefined;\n    }\n    if (object.balance !== undefined && object.balance !== null) {\n      message.balance = object.balance;\n    } else {\n      message.balance = \"\";\n    }\n    return message;\n  }\n};\nconst baseRedelegationResponse = {};\nexports.RedelegationResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.redelegation !== undefined) {\n      exports.Redelegation.encode(message.redelegation, writer.uint32(10).fork()).ldelim();\n    }\n    for (const v of message.entries) {\n      exports.RedelegationEntryResponse.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseRedelegationResponse);\n    message.entries = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.redelegation = exports.Redelegation.decode(reader, reader.uint32());\n          break;\n        case 2:\n          message.entries.push(exports.RedelegationEntryResponse.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseRedelegationResponse);\n    message.entries = [];\n    if (object.redelegation !== undefined && object.redelegation !== null) {\n      message.redelegation = exports.Redelegation.fromJSON(object.redelegation);\n    } else {\n      message.redelegation = undefined;\n    }\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.RedelegationEntryResponse.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.redelegation !== undefined && (obj.redelegation = message.redelegation ? exports.Redelegation.toJSON(message.redelegation) : undefined);\n    if (message.entries) {\n      obj.entries = message.entries.map(e => e ? exports.RedelegationEntryResponse.toJSON(e) : undefined);\n    } else {\n      obj.entries = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseRedelegationResponse);\n    message.entries = [];\n    if (object.redelegation !== undefined && object.redelegation !== null) {\n      message.redelegation = exports.Redelegation.fromPartial(object.redelegation);\n    } else {\n      message.redelegation = undefined;\n    }\n    if (object.entries !== undefined && object.entries !== null) {\n      for (const e of object.entries) {\n        message.entries.push(exports.RedelegationEntryResponse.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst basePool = {\n  notBondedTokens: \"\",\n  bondedTokens: \"\"\n};\nexports.Pool = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.notBondedTokens !== \"\") {\n      writer.uint32(10).string(message.notBondedTokens);\n    }\n    if (message.bondedTokens !== \"\") {\n      writer.uint32(18).string(message.bondedTokens);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, basePool);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.notBondedTokens = reader.string();\n          break;\n        case 2:\n          message.bondedTokens = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, basePool);\n    if (object.notBondedTokens !== undefined && object.notBondedTokens !== null) {\n      message.notBondedTokens = String(object.notBondedTokens);\n    } else {\n      message.notBondedTokens = \"\";\n    }\n    if (object.bondedTokens !== undefined && object.bondedTokens !== null) {\n      message.bondedTokens = String(object.bondedTokens);\n    } else {\n      message.bondedTokens = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.notBondedTokens !== undefined && (obj.notBondedTokens = message.notBondedTokens);\n    message.bondedTokens !== undefined && (obj.bondedTokens = message.bondedTokens);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, basePool);\n    if (object.notBondedTokens !== undefined && object.notBondedTokens !== null) {\n      message.notBondedTokens = object.notBondedTokens;\n    } else {\n      message.notBondedTokens = \"\";\n    }\n    if (object.bondedTokens !== undefined && object.bondedTokens !== null) {\n      message.bondedTokens = object.bondedTokens;\n    } else {\n      message.bondedTokens = \"\";\n    }\n    return message;\n  }\n};\nfunction toTimestamp(date) {\n  const seconds = numberToLong(date.getTime() / 1000);\n  const nanos = date.getTime() % 1000 * 1000000;\n  return {\n    seconds,\n    nanos\n  };\n}\nfunction fromTimestamp(t) {\n  let millis = t.seconds.toNumber() * 1000;\n  millis += t.nanos / 1000000;\n  return new Date(millis);\n}\nfunction fromJsonTimestamp(o) {\n  if (o instanceof Date) {\n    return o;\n  } else if (typeof o === \"string\") {\n    return new Date(o);\n  } else {\n    return fromTimestamp(timestamp_1.Timestamp.fromJSON(o));\n  }\n}\nfunction numberToLong(number) {\n  return long_1.default.fromNumber(number);\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=staking.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}