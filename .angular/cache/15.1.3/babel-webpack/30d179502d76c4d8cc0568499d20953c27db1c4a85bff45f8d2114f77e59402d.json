{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.GrpcWebImpl = exports.MsgClearAdminDesc = exports.MsgUpdateAdminDesc = exports.MsgMigrateContractDesc = exports.MsgExecuteContractDesc = exports.MsgInstantiateContractDesc = exports.MsgStoreCodeDesc = exports.MsgDesc = exports.MsgClientImpl = exports.MsgClearAdminResponse = exports.MsgClearAdmin = exports.MsgUpdateAdminResponse = exports.MsgUpdateAdmin = exports.MsgMigrateContractResponse = exports.MsgMigrateContract = exports.MsgExecuteContractResponse = exports.MsgExecuteContract = exports.MsgInstantiateContractResponse = exports.MsgInstantiateContract = exports.MsgStoreCodeResponse = exports.MsgStoreCode = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst grpc_web_1 = require(\"@improbable-eng/grpc-web\");\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst types_1 = require(\"../../../cosmwasm/wasm/v1/types\");\nconst browser_headers_1 = require(\"browser-headers\");\nconst coin_1 = require(\"../../../cosmos/base/v1beta1/coin\");\nexports.protobufPackage = \"cosmwasm.wasm.v1\";\nconst baseMsgStoreCode = {\n  sender: \"\"\n};\nexports.MsgStoreCode = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.wasmByteCode.length !== 0) {\n      writer.uint32(18).bytes(message.wasmByteCode);\n    }\n    if (message.instantiatePermission !== undefined) {\n      types_1.AccessConfig.encode(message.instantiatePermission, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgStoreCode);\n    message.wasmByteCode = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.wasmByteCode = reader.bytes();\n          break;\n        case 5:\n          message.instantiatePermission = types_1.AccessConfig.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgStoreCode);\n    message.wasmByteCode = new Uint8Array();\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.wasmByteCode !== undefined && object.wasmByteCode !== null) {\n      message.wasmByteCode = bytesFromBase64(object.wasmByteCode);\n    }\n    if (object.instantiatePermission !== undefined && object.instantiatePermission !== null) {\n      message.instantiatePermission = types_1.AccessConfig.fromJSON(object.instantiatePermission);\n    } else {\n      message.instantiatePermission = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.wasmByteCode !== undefined && (obj.wasmByteCode = base64FromBytes(message.wasmByteCode !== undefined ? message.wasmByteCode : new Uint8Array()));\n    message.instantiatePermission !== undefined && (obj.instantiatePermission = message.instantiatePermission ? types_1.AccessConfig.toJSON(message.instantiatePermission) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgStoreCode);\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.wasmByteCode !== undefined && object.wasmByteCode !== null) {\n      message.wasmByteCode = object.wasmByteCode;\n    } else {\n      message.wasmByteCode = new Uint8Array();\n    }\n    if (object.instantiatePermission !== undefined && object.instantiatePermission !== null) {\n      message.instantiatePermission = types_1.AccessConfig.fromPartial(object.instantiatePermission);\n    } else {\n      message.instantiatePermission = undefined;\n    }\n    return message;\n  }\n};\nconst baseMsgStoreCodeResponse = {\n  codeId: long_1.default.UZERO\n};\nexports.MsgStoreCodeResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.codeId.isZero()) {\n      writer.uint32(8).uint64(message.codeId);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgStoreCodeResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.codeId = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgStoreCodeResponse);\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgStoreCodeResponse);\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nconst baseMsgInstantiateContract = {\n  sender: \"\",\n  admin: \"\",\n  codeId: long_1.default.UZERO,\n  label: \"\"\n};\nexports.MsgInstantiateContract = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.admin !== \"\") {\n      writer.uint32(18).string(message.admin);\n    }\n    if (!message.codeId.isZero()) {\n      writer.uint32(24).uint64(message.codeId);\n    }\n    if (message.label !== \"\") {\n      writer.uint32(34).string(message.label);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(42).bytes(message.msg);\n    }\n    for (const v of message.funds) {\n      coin_1.Coin.encode(v, writer.uint32(50).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgInstantiateContract);\n    message.funds = [];\n    message.msg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.admin = reader.string();\n          break;\n        case 3:\n          message.codeId = reader.uint64();\n          break;\n        case 4:\n          message.label = reader.string();\n          break;\n        case 5:\n          message.msg = reader.bytes();\n          break;\n        case 6:\n          message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgInstantiateContract);\n    message.funds = [];\n    message.msg = new Uint8Array();\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = String(object.admin);\n    } else {\n      message.admin = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.label !== undefined && object.label !== null) {\n      message.label = String(object.label);\n    } else {\n      message.label = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = bytesFromBase64(object.msg);\n    }\n    if (object.funds !== undefined && object.funds !== null) {\n      for (const e of object.funds) {\n        message.funds.push(coin_1.Coin.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.admin !== undefined && (obj.admin = message.admin);\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    message.label !== undefined && (obj.label = message.label);\n    message.msg !== undefined && (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n    if (message.funds) {\n      obj.funds = message.funds.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.funds = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgInstantiateContract);\n    message.funds = [];\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.admin !== undefined && object.admin !== null) {\n      message.admin = object.admin;\n    } else {\n      message.admin = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.label !== undefined && object.label !== null) {\n      message.label = object.label;\n    } else {\n      message.label = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = object.msg;\n    } else {\n      message.msg = new Uint8Array();\n    }\n    if (object.funds !== undefined && object.funds !== null) {\n      for (const e of object.funds) {\n        message.funds.push(coin_1.Coin.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseMsgInstantiateContractResponse = {\n  address: \"\"\n};\nexports.MsgInstantiateContractResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.address !== \"\") {\n      writer.uint32(10).string(message.address);\n    }\n    if (message.data.length !== 0) {\n      writer.uint32(18).bytes(message.data);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgInstantiateContractResponse);\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.address = reader.string();\n          break;\n        case 2:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgInstantiateContractResponse);\n    message.data = new Uint8Array();\n    if (object.address !== undefined && object.address !== null) {\n      message.address = String(object.address);\n    } else {\n      message.address = \"\";\n    }\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.address !== undefined && (obj.address = message.address);\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgInstantiateContractResponse);\n    if (object.address !== undefined && object.address !== null) {\n      message.address = object.address;\n    } else {\n      message.address = \"\";\n    }\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgExecuteContract = {\n  sender: \"\",\n  contract: \"\"\n};\nexports.MsgExecuteContract = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(18).string(message.contract);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(26).bytes(message.msg);\n    }\n    for (const v of message.funds) {\n      coin_1.Coin.encode(v, writer.uint32(42).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgExecuteContract);\n    message.funds = [];\n    message.msg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.contract = reader.string();\n          break;\n        case 3:\n          message.msg = reader.bytes();\n          break;\n        case 5:\n          message.funds.push(coin_1.Coin.decode(reader, reader.uint32()));\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgExecuteContract);\n    message.funds = [];\n    message.msg = new Uint8Array();\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = bytesFromBase64(object.msg);\n    }\n    if (object.funds !== undefined && object.funds !== null) {\n      for (const e of object.funds) {\n        message.funds.push(coin_1.Coin.fromJSON(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.msg !== undefined && (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n    if (message.funds) {\n      obj.funds = message.funds.map(e => e ? coin_1.Coin.toJSON(e) : undefined);\n    } else {\n      obj.funds = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgExecuteContract);\n    message.funds = [];\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = object.msg;\n    } else {\n      message.msg = new Uint8Array();\n    }\n    if (object.funds !== undefined && object.funds !== null) {\n      for (const e of object.funds) {\n        message.funds.push(coin_1.Coin.fromPartial(e));\n      }\n    }\n    return message;\n  }\n};\nconst baseMsgExecuteContractResponse = {};\nexports.MsgExecuteContractResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.data.length !== 0) {\n      writer.uint32(10).bytes(message.data);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgExecuteContractResponse);\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgExecuteContractResponse);\n    message.data = new Uint8Array();\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgExecuteContractResponse);\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgMigrateContract = {\n  sender: \"\",\n  contract: \"\",\n  codeId: long_1.default.UZERO\n};\nexports.MsgMigrateContract = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(18).string(message.contract);\n    }\n    if (!message.codeId.isZero()) {\n      writer.uint32(24).uint64(message.codeId);\n    }\n    if (message.msg.length !== 0) {\n      writer.uint32(34).bytes(message.msg);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgMigrateContract);\n    message.msg = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.contract = reader.string();\n          break;\n        case 3:\n          message.codeId = reader.uint64();\n          break;\n        case 4:\n          message.msg = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgMigrateContract);\n    message.msg = new Uint8Array();\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = long_1.default.fromString(object.codeId);\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = bytesFromBase64(object.msg);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.contract !== undefined && (obj.contract = message.contract);\n    message.codeId !== undefined && (obj.codeId = (message.codeId || long_1.default.UZERO).toString());\n    message.msg !== undefined && (obj.msg = base64FromBytes(message.msg !== undefined ? message.msg : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgMigrateContract);\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    if (object.codeId !== undefined && object.codeId !== null) {\n      message.codeId = object.codeId;\n    } else {\n      message.codeId = long_1.default.UZERO;\n    }\n    if (object.msg !== undefined && object.msg !== null) {\n      message.msg = object.msg;\n    } else {\n      message.msg = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgMigrateContractResponse = {};\nexports.MsgMigrateContractResponse = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.data.length !== 0) {\n      writer.uint32(10).bytes(message.data);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgMigrateContractResponse);\n    message.data = new Uint8Array();\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.data = reader.bytes();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgMigrateContractResponse);\n    message.data = new Uint8Array();\n    if (object.data !== undefined && object.data !== null) {\n      message.data = bytesFromBase64(object.data);\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.data !== undefined && (obj.data = base64FromBytes(message.data !== undefined ? message.data : new Uint8Array()));\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgMigrateContractResponse);\n    if (object.data !== undefined && object.data !== null) {\n      message.data = object.data;\n    } else {\n      message.data = new Uint8Array();\n    }\n    return message;\n  }\n};\nconst baseMsgUpdateAdmin = {\n  sender: \"\",\n  newAdmin: \"\",\n  contract: \"\"\n};\nexports.MsgUpdateAdmin = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.newAdmin !== \"\") {\n      writer.uint32(18).string(message.newAdmin);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(26).string(message.contract);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgUpdateAdmin);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 2:\n          message.newAdmin = reader.string();\n          break;\n        case 3:\n          message.contract = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgUpdateAdmin);\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.newAdmin !== undefined && object.newAdmin !== null) {\n      message.newAdmin = String(object.newAdmin);\n    } else {\n      message.newAdmin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.newAdmin !== undefined && (obj.newAdmin = message.newAdmin);\n    message.contract !== undefined && (obj.contract = message.contract);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgUpdateAdmin);\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.newAdmin !== undefined && object.newAdmin !== null) {\n      message.newAdmin = object.newAdmin;\n    } else {\n      message.newAdmin = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgUpdateAdminResponse = {};\nexports.MsgUpdateAdminResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgUpdateAdminResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgUpdateAdminResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgUpdateAdminResponse);\n    return message;\n  }\n};\nconst baseMsgClearAdmin = {\n  sender: \"\",\n  contract: \"\"\n};\nexports.MsgClearAdmin = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.sender !== \"\") {\n      writer.uint32(10).string(message.sender);\n    }\n    if (message.contract !== \"\") {\n      writer.uint32(26).string(message.contract);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgClearAdmin);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.sender = reader.string();\n          break;\n        case 3:\n          message.contract = reader.string();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseMsgClearAdmin);\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = String(object.sender);\n    } else {\n      message.sender = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = String(object.contract);\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.sender !== undefined && (obj.sender = message.sender);\n    message.contract !== undefined && (obj.contract = message.contract);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseMsgClearAdmin);\n    if (object.sender !== undefined && object.sender !== null) {\n      message.sender = object.sender;\n    } else {\n      message.sender = \"\";\n    }\n    if (object.contract !== undefined && object.contract !== null) {\n      message.contract = object.contract;\n    } else {\n      message.contract = \"\";\n    }\n    return message;\n  }\n};\nconst baseMsgClearAdminResponse = {};\nexports.MsgClearAdminResponse = {\n  encode(_, writer = minimal_1.default.Writer.create()) {\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseMsgClearAdminResponse);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(_) {\n    const message = Object.assign({}, baseMsgClearAdminResponse);\n    return message;\n  },\n  toJSON(_) {\n    const obj = {};\n    return obj;\n  },\n  fromPartial(_) {\n    const message = Object.assign({}, baseMsgClearAdminResponse);\n    return message;\n  }\n};\nclass MsgClientImpl {\n  constructor(rpc) {\n    this.rpc = rpc;\n    this.StoreCode = this.StoreCode.bind(this);\n    this.InstantiateContract = this.InstantiateContract.bind(this);\n    this.ExecuteContract = this.ExecuteContract.bind(this);\n    this.MigrateContract = this.MigrateContract.bind(this);\n    this.UpdateAdmin = this.UpdateAdmin.bind(this);\n    this.ClearAdmin = this.ClearAdmin.bind(this);\n  }\n  StoreCode(request, metadata) {\n    return this.rpc.unary(exports.MsgStoreCodeDesc, exports.MsgStoreCode.fromPartial(request), metadata);\n  }\n  InstantiateContract(request, metadata) {\n    return this.rpc.unary(exports.MsgInstantiateContractDesc, exports.MsgInstantiateContract.fromPartial(request), metadata);\n  }\n  ExecuteContract(request, metadata) {\n    return this.rpc.unary(exports.MsgExecuteContractDesc, exports.MsgExecuteContract.fromPartial(request), metadata);\n  }\n  MigrateContract(request, metadata) {\n    return this.rpc.unary(exports.MsgMigrateContractDesc, exports.MsgMigrateContract.fromPartial(request), metadata);\n  }\n  UpdateAdmin(request, metadata) {\n    return this.rpc.unary(exports.MsgUpdateAdminDesc, exports.MsgUpdateAdmin.fromPartial(request), metadata);\n  }\n  ClearAdmin(request, metadata) {\n    return this.rpc.unary(exports.MsgClearAdminDesc, exports.MsgClearAdmin.fromPartial(request), metadata);\n  }\n}\nexports.MsgClientImpl = MsgClientImpl;\nexports.MsgDesc = {\n  serviceName: \"cosmwasm.wasm.v1.Msg\"\n};\nexports.MsgStoreCodeDesc = {\n  methodName: \"StoreCode\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgStoreCode.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgStoreCodeResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgInstantiateContractDesc = {\n  methodName: \"InstantiateContract\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgInstantiateContract.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgInstantiateContractResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgExecuteContractDesc = {\n  methodName: \"ExecuteContract\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgExecuteContract.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgExecuteContractResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgMigrateContractDesc = {\n  methodName: \"MigrateContract\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgMigrateContract.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgMigrateContractResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgUpdateAdminDesc = {\n  methodName: \"UpdateAdmin\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgUpdateAdmin.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgUpdateAdminResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nexports.MsgClearAdminDesc = {\n  methodName: \"ClearAdmin\",\n  service: exports.MsgDesc,\n  requestStream: false,\n  responseStream: false,\n  requestType: {\n    serializeBinary() {\n      return exports.MsgClearAdmin.encode(this).finish();\n    }\n  },\n  responseType: {\n    deserializeBinary(data) {\n      return Object.assign(Object.assign({}, exports.MsgClearAdminResponse.decode(data)), {\n        toObject() {\n          return this;\n        }\n      });\n    }\n  }\n};\nclass GrpcWebImpl {\n  constructor(host, options) {\n    this.host = host;\n    this.options = options;\n  }\n  unary(methodDesc, _request, metadata) {\n    var _a;\n    const request = Object.assign(Object.assign({}, _request), methodDesc.requestType);\n    const maybeCombinedMetadata = metadata && this.options.metadata ? new browser_headers_1.BrowserHeaders(Object.assign(Object.assign({}, (_a = this.options) === null || _a === void 0 ? void 0 : _a.metadata.headersMap), metadata === null || metadata === void 0 ? void 0 : metadata.headersMap)) : metadata || this.options.metadata;\n    return new Promise((resolve, reject) => {\n      grpc_web_1.grpc.unary(methodDesc, {\n        request,\n        host: this.host,\n        metadata: maybeCombinedMetadata,\n        transport: this.options.transport,\n        debug: this.options.debug,\n        onEnd: function (response) {\n          if (response.status === grpc_web_1.grpc.Code.OK) {\n            resolve(response.message);\n          } else {\n            const err = new Error(response.statusMessage);\n            err.code = response.status;\n            err.metadata = response.trailers;\n            reject(err);\n          }\n        }\n      });\n    });\n  }\n}\nexports.GrpcWebImpl = GrpcWebImpl;\nvar globalThis = (() => {\n  if (typeof globalThis !== \"undefined\") return globalThis;\n  if (typeof self !== \"undefined\") return self;\n  if (typeof window !== \"undefined\") return window;\n  if (typeof global !== \"undefined\") return global;\n  throw \"Unable to locate global object\";\n})();\nconst atob = globalThis.atob || (b64 => globalThis.Buffer.from(b64, \"base64\").toString(\"binary\"));\nfunction bytesFromBase64(b64) {\n  const bin = atob(b64);\n  const arr = new Uint8Array(bin.length);\n  for (let i = 0; i < bin.length; ++i) {\n    arr[i] = bin.charCodeAt(i);\n  }\n  return arr;\n}\nconst btoa = globalThis.btoa || (bin => globalThis.Buffer.from(bin, \"binary\").toString(\"base64\"));\nfunction base64FromBytes(arr) {\n  const bin = [];\n  for (const byte of arr) {\n    bin.push(String.fromCharCode(byte));\n  }\n  return btoa(bin.join(\"\"));\n}\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=tx.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}