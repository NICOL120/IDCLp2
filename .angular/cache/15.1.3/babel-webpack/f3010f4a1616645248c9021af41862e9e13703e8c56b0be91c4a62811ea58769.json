{"ast":null,"code":"\"use strict\";\n\nvar __importDefault = this && this.__importDefault || function (mod) {\n  return mod && mod.__esModule ? mod : {\n    \"default\": mod\n  };\n};\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Params = exports.Version = exports.ConnectionPaths = exports.ClientPaths = exports.Counterparty = exports.IdentifiedConnection = exports.ConnectionEnd = exports.stateToJSON = exports.stateFromJSON = exports.State = exports.protobufPackage = void 0;\n/* eslint-disable */\nconst long_1 = __importDefault(require(\"long\"));\nconst minimal_1 = __importDefault(require(\"protobufjs/minimal\"));\nconst commitment_1 = require(\"../../../../ibc/core/commitment/v1/commitment\");\nexports.protobufPackage = \"ibc.core.connection.v1\";\n/**\n * State defines if a connection is in one of the following states:\n * INIT, TRYOPEN, OPEN or UNINITIALIZED.\n */\nvar State;\n(function (State) {\n  /** STATE_UNINITIALIZED_UNSPECIFIED - Default State */\n  State[State[\"STATE_UNINITIALIZED_UNSPECIFIED\"] = 0] = \"STATE_UNINITIALIZED_UNSPECIFIED\";\n  /** STATE_INIT - A connection end has just started the opening handshake. */\n  State[State[\"STATE_INIT\"] = 1] = \"STATE_INIT\";\n  /**\n   * STATE_TRYOPEN - A connection end has acknowledged the handshake step on the counterparty\n   * chain.\n   */\n  State[State[\"STATE_TRYOPEN\"] = 2] = \"STATE_TRYOPEN\";\n  /** STATE_OPEN - A connection end has completed the handshake. */\n  State[State[\"STATE_OPEN\"] = 3] = \"STATE_OPEN\";\n  State[State[\"UNRECOGNIZED\"] = -1] = \"UNRECOGNIZED\";\n})(State = exports.State || (exports.State = {}));\nfunction stateFromJSON(object) {\n  switch (object) {\n    case 0:\n    case \"STATE_UNINITIALIZED_UNSPECIFIED\":\n      return State.STATE_UNINITIALIZED_UNSPECIFIED;\n    case 1:\n    case \"STATE_INIT\":\n      return State.STATE_INIT;\n    case 2:\n    case \"STATE_TRYOPEN\":\n      return State.STATE_TRYOPEN;\n    case 3:\n    case \"STATE_OPEN\":\n      return State.STATE_OPEN;\n    case -1:\n    case \"UNRECOGNIZED\":\n    default:\n      return State.UNRECOGNIZED;\n  }\n}\nexports.stateFromJSON = stateFromJSON;\nfunction stateToJSON(object) {\n  switch (object) {\n    case State.STATE_UNINITIALIZED_UNSPECIFIED:\n      return \"STATE_UNINITIALIZED_UNSPECIFIED\";\n    case State.STATE_INIT:\n      return \"STATE_INIT\";\n    case State.STATE_TRYOPEN:\n      return \"STATE_TRYOPEN\";\n    case State.STATE_OPEN:\n      return \"STATE_OPEN\";\n    default:\n      return \"UNKNOWN\";\n  }\n}\nexports.stateToJSON = stateToJSON;\nconst baseConnectionEnd = {\n  clientId: \"\",\n  state: 0,\n  delayPeriod: long_1.default.UZERO\n};\nexports.ConnectionEnd = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    for (const v of message.versions) {\n      exports.Version.encode(v, writer.uint32(18).fork()).ldelim();\n    }\n    if (message.state !== 0) {\n      writer.uint32(24).int32(message.state);\n    }\n    if (message.counterparty !== undefined) {\n      exports.Counterparty.encode(message.counterparty, writer.uint32(34).fork()).ldelim();\n    }\n    if (!message.delayPeriod.isZero()) {\n      writer.uint32(40).uint64(message.delayPeriod);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseConnectionEnd);\n    message.versions = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.versions.push(exports.Version.decode(reader, reader.uint32()));\n          break;\n        case 3:\n          message.state = reader.int32();\n          break;\n        case 4:\n          message.counterparty = exports.Counterparty.decode(reader, reader.uint32());\n          break;\n        case 5:\n          message.delayPeriod = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseConnectionEnd);\n    message.versions = [];\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.versions !== undefined && object.versions !== null) {\n      for (const e of object.versions) {\n        message.versions.push(exports.Version.fromJSON(e));\n      }\n    }\n    if (object.state !== undefined && object.state !== null) {\n      message.state = stateFromJSON(object.state);\n    } else {\n      message.state = 0;\n    }\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = exports.Counterparty.fromJSON(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    if (message.versions) {\n      obj.versions = message.versions.map(e => e ? exports.Version.toJSON(e) : undefined);\n    } else {\n      obj.versions = [];\n    }\n    message.state !== undefined && (obj.state = stateToJSON(message.state));\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseConnectionEnd);\n    message.versions = [];\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.versions !== undefined && object.versions !== null) {\n      for (const e of object.versions) {\n        message.versions.push(exports.Version.fromPartial(e));\n      }\n    }\n    if (object.state !== undefined && object.state !== null) {\n      message.state = object.state;\n    } else {\n      message.state = 0;\n    }\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = exports.Counterparty.fromPartial(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = object.delayPeriod;\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nconst baseIdentifiedConnection = {\n  id: \"\",\n  clientId: \"\",\n  state: 0,\n  delayPeriod: long_1.default.UZERO\n};\nexports.IdentifiedConnection = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.id !== \"\") {\n      writer.uint32(10).string(message.id);\n    }\n    if (message.clientId !== \"\") {\n      writer.uint32(18).string(message.clientId);\n    }\n    for (const v of message.versions) {\n      exports.Version.encode(v, writer.uint32(26).fork()).ldelim();\n    }\n    if (message.state !== 0) {\n      writer.uint32(32).int32(message.state);\n    }\n    if (message.counterparty !== undefined) {\n      exports.Counterparty.encode(message.counterparty, writer.uint32(42).fork()).ldelim();\n    }\n    if (!message.delayPeriod.isZero()) {\n      writer.uint32(48).uint64(message.delayPeriod);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseIdentifiedConnection);\n    message.versions = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.id = reader.string();\n          break;\n        case 2:\n          message.clientId = reader.string();\n          break;\n        case 3:\n          message.versions.push(exports.Version.decode(reader, reader.uint32()));\n          break;\n        case 4:\n          message.state = reader.int32();\n          break;\n        case 5:\n          message.counterparty = exports.Counterparty.decode(reader, reader.uint32());\n          break;\n        case 6:\n          message.delayPeriod = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseIdentifiedConnection);\n    message.versions = [];\n    if (object.id !== undefined && object.id !== null) {\n      message.id = String(object.id);\n    } else {\n      message.id = \"\";\n    }\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.versions !== undefined && object.versions !== null) {\n      for (const e of object.versions) {\n        message.versions.push(exports.Version.fromJSON(e));\n      }\n    }\n    if (object.state !== undefined && object.state !== null) {\n      message.state = stateFromJSON(object.state);\n    } else {\n      message.state = 0;\n    }\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = exports.Counterparty.fromJSON(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = long_1.default.fromString(object.delayPeriod);\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.id !== undefined && (obj.id = message.id);\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    if (message.versions) {\n      obj.versions = message.versions.map(e => e ? exports.Version.toJSON(e) : undefined);\n    } else {\n      obj.versions = [];\n    }\n    message.state !== undefined && (obj.state = stateToJSON(message.state));\n    message.counterparty !== undefined && (obj.counterparty = message.counterparty ? exports.Counterparty.toJSON(message.counterparty) : undefined);\n    message.delayPeriod !== undefined && (obj.delayPeriod = (message.delayPeriod || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseIdentifiedConnection);\n    message.versions = [];\n    if (object.id !== undefined && object.id !== null) {\n      message.id = object.id;\n    } else {\n      message.id = \"\";\n    }\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.versions !== undefined && object.versions !== null) {\n      for (const e of object.versions) {\n        message.versions.push(exports.Version.fromPartial(e));\n      }\n    }\n    if (object.state !== undefined && object.state !== null) {\n      message.state = object.state;\n    } else {\n      message.state = 0;\n    }\n    if (object.counterparty !== undefined && object.counterparty !== null) {\n      message.counterparty = exports.Counterparty.fromPartial(object.counterparty);\n    } else {\n      message.counterparty = undefined;\n    }\n    if (object.delayPeriod !== undefined && object.delayPeriod !== null) {\n      message.delayPeriod = object.delayPeriod;\n    } else {\n      message.delayPeriod = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nconst baseCounterparty = {\n  clientId: \"\",\n  connectionId: \"\"\n};\nexports.Counterparty = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    if (message.connectionId !== \"\") {\n      writer.uint32(18).string(message.connectionId);\n    }\n    if (message.prefix !== undefined) {\n      commitment_1.MerklePrefix.encode(message.prefix, writer.uint32(26).fork()).ldelim();\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseCounterparty);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.connectionId = reader.string();\n          break;\n        case 3:\n          message.prefix = commitment_1.MerklePrefix.decode(reader, reader.uint32());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseCounterparty);\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = String(object.connectionId);\n    } else {\n      message.connectionId = \"\";\n    }\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = commitment_1.MerklePrefix.fromJSON(object.prefix);\n    } else {\n      message.prefix = undefined;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    message.connectionId !== undefined && (obj.connectionId = message.connectionId);\n    message.prefix !== undefined && (obj.prefix = message.prefix ? commitment_1.MerklePrefix.toJSON(message.prefix) : undefined);\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseCounterparty);\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.connectionId !== undefined && object.connectionId !== null) {\n      message.connectionId = object.connectionId;\n    } else {\n      message.connectionId = \"\";\n    }\n    if (object.prefix !== undefined && object.prefix !== null) {\n      message.prefix = commitment_1.MerklePrefix.fromPartial(object.prefix);\n    } else {\n      message.prefix = undefined;\n    }\n    return message;\n  }\n};\nconst baseClientPaths = {\n  paths: \"\"\n};\nexports.ClientPaths = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    for (const v of message.paths) {\n      writer.uint32(10).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseClientPaths);\n    message.paths = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.paths.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseClientPaths);\n    message.paths = [];\n    if (object.paths !== undefined && object.paths !== null) {\n      for (const e of object.paths) {\n        message.paths.push(String(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    if (message.paths) {\n      obj.paths = message.paths.map(e => e);\n    } else {\n      obj.paths = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseClientPaths);\n    message.paths = [];\n    if (object.paths !== undefined && object.paths !== null) {\n      for (const e of object.paths) {\n        message.paths.push(e);\n      }\n    }\n    return message;\n  }\n};\nconst baseConnectionPaths = {\n  clientId: \"\",\n  paths: \"\"\n};\nexports.ConnectionPaths = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.clientId !== \"\") {\n      writer.uint32(10).string(message.clientId);\n    }\n    for (const v of message.paths) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseConnectionPaths);\n    message.paths = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.clientId = reader.string();\n          break;\n        case 2:\n          message.paths.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseConnectionPaths);\n    message.paths = [];\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = String(object.clientId);\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.paths !== undefined && object.paths !== null) {\n      for (const e of object.paths) {\n        message.paths.push(String(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.clientId !== undefined && (obj.clientId = message.clientId);\n    if (message.paths) {\n      obj.paths = message.paths.map(e => e);\n    } else {\n      obj.paths = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseConnectionPaths);\n    message.paths = [];\n    if (object.clientId !== undefined && object.clientId !== null) {\n      message.clientId = object.clientId;\n    } else {\n      message.clientId = \"\";\n    }\n    if (object.paths !== undefined && object.paths !== null) {\n      for (const e of object.paths) {\n        message.paths.push(e);\n      }\n    }\n    return message;\n  }\n};\nconst baseVersion = {\n  identifier: \"\",\n  features: \"\"\n};\nexports.Version = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (message.identifier !== \"\") {\n      writer.uint32(10).string(message.identifier);\n    }\n    for (const v of message.features) {\n      writer.uint32(18).string(v);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseVersion);\n    message.features = [];\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.identifier = reader.string();\n          break;\n        case 2:\n          message.features.push(reader.string());\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseVersion);\n    message.features = [];\n    if (object.identifier !== undefined && object.identifier !== null) {\n      message.identifier = String(object.identifier);\n    } else {\n      message.identifier = \"\";\n    }\n    if (object.features !== undefined && object.features !== null) {\n      for (const e of object.features) {\n        message.features.push(String(e));\n      }\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.identifier !== undefined && (obj.identifier = message.identifier);\n    if (message.features) {\n      obj.features = message.features.map(e => e);\n    } else {\n      obj.features = [];\n    }\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseVersion);\n    message.features = [];\n    if (object.identifier !== undefined && object.identifier !== null) {\n      message.identifier = object.identifier;\n    } else {\n      message.identifier = \"\";\n    }\n    if (object.features !== undefined && object.features !== null) {\n      for (const e of object.features) {\n        message.features.push(e);\n      }\n    }\n    return message;\n  }\n};\nconst baseParams = {\n  maxExpectedTimePerBlock: long_1.default.UZERO\n};\nexports.Params = {\n  encode(message, writer = minimal_1.default.Writer.create()) {\n    if (!message.maxExpectedTimePerBlock.isZero()) {\n      writer.uint32(8).uint64(message.maxExpectedTimePerBlock);\n    }\n    return writer;\n  },\n  decode(input, length) {\n    const reader = input instanceof minimal_1.default.Reader ? input : new minimal_1.default.Reader(input);\n    let end = length === undefined ? reader.len : reader.pos + length;\n    const message = Object.assign({}, baseParams);\n    while (reader.pos < end) {\n      const tag = reader.uint32();\n      switch (tag >>> 3) {\n        case 1:\n          message.maxExpectedTimePerBlock = reader.uint64();\n          break;\n        default:\n          reader.skipType(tag & 7);\n          break;\n      }\n    }\n    return message;\n  },\n  fromJSON(object) {\n    const message = Object.assign({}, baseParams);\n    if (object.maxExpectedTimePerBlock !== undefined && object.maxExpectedTimePerBlock !== null) {\n      message.maxExpectedTimePerBlock = long_1.default.fromString(object.maxExpectedTimePerBlock);\n    } else {\n      message.maxExpectedTimePerBlock = long_1.default.UZERO;\n    }\n    return message;\n  },\n  toJSON(message) {\n    const obj = {};\n    message.maxExpectedTimePerBlock !== undefined && (obj.maxExpectedTimePerBlock = (message.maxExpectedTimePerBlock || long_1.default.UZERO).toString());\n    return obj;\n  },\n  fromPartial(object) {\n    const message = Object.assign({}, baseParams);\n    if (object.maxExpectedTimePerBlock !== undefined && object.maxExpectedTimePerBlock !== null) {\n      message.maxExpectedTimePerBlock = object.maxExpectedTimePerBlock;\n    } else {\n      message.maxExpectedTimePerBlock = long_1.default.UZERO;\n    }\n    return message;\n  }\n};\nif (minimal_1.default.util.Long !== long_1.default) {\n  minimal_1.default.util.Long = long_1.default;\n  minimal_1.default.configure();\n}\n//# sourceMappingURL=connection.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}