{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SignatureV2 = exports.SignMode = void 0;\nvar PublicKey_1 = require(\"./PublicKey\");\nvar Tx_1 = require(\"./Tx\");\nvar CompactBitArray_1 = require(\"./CompactBitArray\");\nvar signing_1 = require(\"@terra-money/terra.proto/cosmos/tx/signing/v1beta1/signing\");\nvar multisig_1 = require(\"@terra-money/terra.proto/cosmos/crypto/multisig/v1beta1/multisig\");\nvar signing_2 = require(\"@terra-money/terra.proto/cosmos/tx/signing/v1beta1/signing\");\nObject.defineProperty(exports, \"SignMode\", {\n  enumerable: true,\n  get: function () {\n    return signing_2.SignMode;\n  }\n});\nvar SignatureV2 = /** @class */function () {\n  function SignatureV2(public_key, data, sequence) {\n    this.public_key = public_key;\n    this.data = data;\n    this.sequence = sequence;\n  }\n  SignatureV2.fromData = function (data) {\n    return new SignatureV2(PublicKey_1.PublicKey.fromData(data.public_key), SignatureV2.Descriptor.fromData(data.data), Number.parseInt(data.sequence));\n  };\n  SignatureV2.prototype.toData = function () {\n    return {\n      public_key: this.public_key.toData(),\n      data: this.data.toData(),\n      sequence: this.sequence.toFixed()\n    };\n  };\n  SignatureV2.fromAmino = function (data) {\n    return new SignatureV2(PublicKey_1.PublicKey.fromAmino(data.pub_key), new SignatureV2.Descriptor(new SignatureV2.Descriptor.Single(SignatureV2.SignMode.SIGN_MODE_LEGACY_AMINO_JSON, data.signature)), 0);\n  };\n  return SignatureV2;\n}();\nexports.SignatureV2 = SignatureV2;\n(function (SignatureV2) {\n  SignatureV2.SignMode = signing_1.SignMode;\n  var Descriptor = /** @class */function () {\n    function Descriptor(data) {\n      data instanceof Descriptor.Single ? this.single = data : this.multi = data;\n    }\n    Descriptor.fromData = function (data) {\n      if (data.single) {\n        return new Descriptor(Descriptor.Single.fromData(data.single));\n      }\n      if (data.multi) {\n        return new Descriptor(Descriptor.Multi.fromData(data.multi));\n      }\n      throw new Error('must be one of single or multi');\n    };\n    Descriptor.prototype.toData = function () {\n      if (this.single) {\n        return {\n          single: this.single.toData()\n        };\n      }\n      if (this.multi) {\n        return {\n          multi: this.multi.toData()\n        };\n      }\n      throw new Error('must be one of single or multi');\n    };\n    Descriptor.prototype.toModeInfoAndSignature = function () {\n      if (this.single) {\n        var sigData = this.single;\n        return [new Tx_1.ModeInfo(new Tx_1.ModeInfo.Single(sigData.mode)), Buffer.from(sigData.signature, 'base64')];\n      }\n      if (this.multi) {\n        var sigData = this.multi;\n        var modeInfos = [];\n        var signatures = [];\n        for (var _i = 0, _a = sigData.signatures; _i < _a.length; _i++) {\n          var signature = _a[_i];\n          var _b = signature.toModeInfoAndSignature(),\n            modeInfo = _b[0],\n            sigBytes = _b[1];\n          modeInfos.push(modeInfo);\n          signatures.push(sigBytes);\n        }\n        var multisigBytes = multisig_1.MultiSignature.encode(multisig_1.MultiSignature.fromPartial({\n          signatures: signatures\n        })).finish();\n        return [new Tx_1.ModeInfo(new Tx_1.ModeInfo.Multi(sigData.bitarray, modeInfos)), multisigBytes];\n      }\n      throw new Error('invalid signature descriptor');\n    };\n    return Descriptor;\n  }();\n  SignatureV2.Descriptor = Descriptor;\n  (function (Descriptor) {\n    var Single = /** @class */function () {\n      function Single(mode, signature) {\n        this.mode = mode;\n        this.signature = signature;\n      }\n      Single.fromData = function (data) {\n        return new Single((0, signing_1.signModeFromJSON)(data.mode), data.signature);\n      };\n      Single.prototype.toData = function () {\n        var _a = this,\n          mode = _a.mode,\n          signature = _a.signature;\n        return {\n          mode: (0, signing_1.signModeToJSON)(mode),\n          signature: signature\n        };\n      };\n      return Single;\n    }();\n    Descriptor.Single = Single;\n    var Multi = /** @class */function () {\n      function Multi(bitarray, signatures) {\n        this.bitarray = bitarray;\n        this.signatures = signatures;\n      }\n      Multi.fromData = function (data) {\n        return new Multi(CompactBitArray_1.CompactBitArray.fromData(data.bitarray), data.signatures.map(function (v) {\n          return Descriptor.fromData(v);\n        }));\n      };\n      Multi.prototype.toData = function () {\n        return {\n          bitarray: this.bitarray.toData(),\n          signatures: this.signatures.map(function (sig) {\n            return sig.toData();\n          })\n        };\n      };\n      return Multi;\n    }();\n    Descriptor.Multi = Multi;\n  })(Descriptor = SignatureV2.Descriptor || (SignatureV2.Descriptor = {}));\n})(SignatureV2 = exports.SignatureV2 || (exports.SignatureV2 = {}));\nexports.SignatureV2 = SignatureV2;\n//# sourceMappingURL=SignatureV2.js.map","map":null,"metadata":{},"sourceType":"script","externalDependencies":[]}